<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VW: VNL::MatrixFixed&lt; m, n, T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen_vw.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
  <div class="navpath"><a class="el" href="namespaceVNL.html">VNL</a>::<a class="el" href="classVNL_1_1MatrixFixed.html">MatrixFixed</a>
  </div>
<div class="contents">
<h1>VNL::MatrixFixed&lt; m, n, T &gt; Class Template Reference</h1><!-- doxytag: class="VNL::MatrixFixed" --><!-- doxytag: inherits="VNL::MatrixFixedRef" -->
<p>Fixed size matrix.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="matrixfixed_8h_source.html">matrixfixed.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for VNL::MatrixFixed&lt; m, n, T &gt;:</div>
<div class="dynsection">
 <div class="center">
  <img src="classVNL_1_1MatrixFixed.gif" usemap="#VNL::MatrixFixed&lt; m, n, T &gt;_map" alt=""/>
  <map id="VNL::MatrixFixed&lt; m, n, T &gt;_map" name="VNL::MatrixFixed&lt; m, n, T &gt;_map">
<area href="classVNL_1_1MatrixFixedRef.html" alt="VNL::MatrixFixedRef&lt; m, n, T &gt;" shape="rect" coords="0,56,193,80"/>
<area href="classVNL_1_1Matrix.html" alt="VNL::Matrix&lt; T &gt;" shape="rect" coords="0,0,193,24"/>
</map>
 </div>
</div>

<p><a href="classVNL_1_1MatrixFixed-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classVNL_1_1CVector.html">CVector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type def for norms.  <a href="#a34d7b88b6e43815aa9ba7b9ba833ba77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#acafd662b2adb865bf437c9db33cbfb26">element_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a06cbb6154eff4ab9a4aa104e14c88431">iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterators.  <a href="#a06cbb6154eff4ab9a4aa104e14c88431"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef T const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a6235d47d391413ca573e3a93b6f35d59">const_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Const iterators.  <a href="#a6235d47d391413ca573e3a93b6f35d59"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1MatrixFixed.html#ad0acc0c76e45382fd445573384b7133a">MatrixFixed</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an empty m*n matrix.  <a href="#ad0acc0c76e45382fd445573384b7133a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1MatrixFixed.html#aa9d8dce9627a404762e8e390e8e05096">MatrixFixed</a> (const T &amp;value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an m*n matrix and fill with value.  <a href="#aa9d8dce9627a404762e8e390e8e05096"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1MatrixFixed.html#a911e76340fca6092d7c341aa1c9fb878">MatrixFixed</a> (const T *datablck)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an m*n <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> and copy data into it row-wise.  <a href="#a911e76340fca6092d7c341aa1c9fb878"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1MatrixFixed.html#a06bda9c34fc517e569dd61193657048b">MatrixFixed</a> (const <a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an m*n <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> and copy rhs into it.  <a href="#a06bda9c34fc517e569dd61193657048b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1MatrixFixed.html#accb989a3a4a6dcf7816ff64827e17493">~MatrixFixed</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1MatrixFixed.html">MatrixFixed</a>&lt; m, n, T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1MatrixFixed.html#a8509d9bdb02076c2adf3b3814f44c048">operator=</a> (const <a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy a vnl_matrix into this.  <a href="#a8509d9bdb02076c2adf3b3814f44c048"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1MatrixFixed.html">MatrixFixed</a>&lt; m, n, T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1MatrixFixed.html#a00edcf61e4d37c8dbd071a5f00568130">operator=</a> (const <a class="el" href="classVNL_1_1MatrixFixed.html">MatrixFixed</a>&lt; m, n, T &gt; &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy another MatrixFixed&lt;m,n,T&gt; into this.  <a href="#a00edcf61e4d37c8dbd071a5f00568130"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1MatrixFixed.html#a50976c1402a305a41369a970b4c570e1">MatrixFixed</a> (const <a class="el" href="classVNL_1_1MatrixFixed.html">MatrixFixed</a>&lt; m, n, T &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1MatrixFixedRef.html#af080a0023d9f6630e4585d8b383b8710">resize</a> (unsigned int, unsigned int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resizing a vnl_matrix_ref fails.  <a href="#af080a0023d9f6630e4585d8b383b8710"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aff5c94adfdf10c50c421097ae55c055e">Rows</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of rows.  <a href="#aff5c94adfdf10c50c421097ae55c055e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#add52389f027d9a631813400db620f162">Columns</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of columns.  <a href="#add52389f027d9a631813400db620f162"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ad63ed64557a003f336a5ff0dca39ee72">Cols</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of columns.  <a href="#ad63ed64557a003f336a5ff0dca39ee72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#acc663489b8784632af9b648a67d7740b">Size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of elements.  <a href="#acc663489b8784632af9b648a67d7740b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a38883927f7b47ec3f8c7e88e41f6ebdd">size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of elements.  <a href="#a38883927f7b47ec3f8c7e88e41f6ebdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a4b3228f51e4a445a651a529f49aaeb9d">Put</a> (unsigned r, unsigned c, T const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set element with boundary checks if error checking is on.  <a href="#a4b3228f51e4a445a651a529f49aaeb9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a3af3fc536ac0f6b7bbc6ce05010b29d7">Get</a> (unsigned r, unsigned c) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get element with boundary checks if error checking is on.  <a href="#a3af3fc536ac0f6b7bbc6ce05010b29d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#acfbe7f98f9bd824ff8d642ace7395f6e">operator[]</a> (unsigned r)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return pointer to given row.  <a href="#acfbe7f98f9bd824ff8d642ace7395f6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#adf099168a9c6309e99f1ae786990def8">operator[]</a> (unsigned r) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return pointer to given row.  <a href="#adf099168a9c6309e99f1ae786990def8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aa0d12208d46190033757830a17aa0046">operator()</a> (unsigned r, unsigned c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access an element for reading or writing.  <a href="#aa0d12208d46190033757830a17aa0046"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T const &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a51ae5629bc2b2d798d794df622e74b39">operator()</a> (unsigned r, unsigned c) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access an element for reading.  <a href="#a51ae5629bc2b2d798d794df622e74b39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#abebe72526015607ee129e2d4687bc7e2">Fill</a> (T const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set all elements of matrix to specified value.  <a href="#abebe72526015607ee129e2d4687bc7e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a8d451a78fc2585574896abac68e4c008">FillDiagonal</a> (T const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set all diagonal elements of matrix to specified value.  <a href="#a8d451a78fc2585574896abac68e4c008"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#afeb71efdf105aed29b5d726eb0a2f915">CopyIn</a> (T const *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill (laminate) this matrix with the given data.  <a href="#afeb71efdf105aed29b5d726eb0a2f915"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aa211aa5409bc801d0fed44d65c25dd20">Set</a> (T const *d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill (laminate) this matrix with the given data.  <a href="#aa211aa5409bc801d0fed44d65c25dd20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aac98f4f0c40b2bb0899d2eea24565054">CopyOut</a> (T *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill the given array with this matrix.  <a href="#aac98f4f0c40b2bb0899d2eea24565054"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a0911f03689d46fa04ea2d39732fbb279">operator+=</a> (T value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add rhs to each element of lhs matrix in situ.  <a href="#a0911f03689d46fa04ea2d39732fbb279"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a1477b046be621c17db6ab42ff3d352b3">operator+=</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add rhs to lhs matrix in situ.  <a href="#a1477b046be621c17db6ab42ff3d352b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aa3cbbc42d832538eba3923c822270a37">operator-=</a> (T value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract rhs from each element of lhs matrix in situ.  <a href="#aa3cbbc42d832538eba3923c822270a37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a08d9aa32756c09656774d0e1524d96e2">operator-=</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract rhs from lhs matrix in situ.  <a href="#a08d9aa32756c09656774d0e1524d96e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aa25de30c7bec38b9e7d4d68897a16c9f">operator*=</a> (T value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scalar multiplication in situ of lhs matrix by rhs.  <a href="#aa25de30c7bec38b9e7d4d68897a16c9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ab72f951f10015a1c640473f453b81a8f">operator*=</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply lhs matrix in situ by rhs.  <a href="#ab72f951f10015a1c640473f453b81a8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a829bdb4502e89901e406ec8d9f2c3575">operator/=</a> (T value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scalar division of lhs matrix in situ by rhs.  <a href="#a829bdb4502e89901e406ec8d9f2c3575"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ab871cf6a47e22652615c6f48461df4e8">operator-</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate all elements of matrix.  <a href="#ab871cf6a47e22652615c6f48461df4e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a8b4d5a955e42f3fb3c54c499006ba9b8">operator-</a> (T const &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract rhs from each element of lhs matrix and return result in new matrix.  <a href="#a8b4d5a955e42f3fb3c54c499006ba9b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a8abcfc4fbc2c1e740f33205fee765d0f">operator-</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;rhs) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> subtract rhs from lhs and return result in new matrix.  <a href="#a8abcfc4fbc2c1e740f33205fee765d0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ac61fc52d0ff23284bc7cf80e92ed745c">operator+</a> (T const &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add rhs to each element of lhs matrix and return result in new matrix.  <a href="#ac61fc52d0ff23284bc7cf80e92ed745c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a6d7e026a1d1ffa09b127931b1ba61fd7">operator+</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;rhs) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> add rhs to lhs matrix and return result in new matrix.  <a href="#a6d7e026a1d1ffa09b127931b1ba61fd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a609fc3a2ffb60df4c1128df41c5ea101">operator*</a> (T const &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scalar multiplication of lhs matrix by rhs and return result in new matrix.  <a href="#a609fc3a2ffb60df4c1128df41c5ea101"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ac3f61ef87d7084a78510d8c2aedf78d3">operator*</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;rhs) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> multiply lhs by rhs matrix and return result in new matrix.  <a href="#ac3f61ef87d7084a78510d8c2aedf78d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a97bdea276efcc84a7556429f07061d9b">operator/</a> (T const &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scalar division of lhs matrix by rhs and return result in new matrix.  <a href="#a97bdea276efcc84a7556429f07061d9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a7c95a6fc9f329a9f8bb0197243219a5e">Apply</a> (T(*f)(T)) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a new matrix by applying function to each element.  <a href="#a7c95a6fc9f329a9f8bb0197243219a5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a217e6df8c3e79ffad8c8ef50256a660b">Apply</a> (T(*f)(T const &amp;)) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a new matrix by applying function to each element.  <a href="#a217e6df8c3e79ffad8c8ef50256a660b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a7c5d1b0934192972fa6c77c8aa0f4c04">Transpose</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return transpose.  <a href="#a7c5d1b0934192972fa6c77c8aa0f4c04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ac0fecc5000343427236e3bbe55c9caf0">ConjugateTranspose</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return conjugate transpose.  <a href="#ac0fecc5000343427236e3bbe55c9caf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a16b330765547529c3dffe01a9d3220a6">Update</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;, unsigned top=0, unsigned left=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set values of this matrix to those of M, starting at [top,left].  <a href="#a16b330765547529c3dffe01a9d3220a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#af37d6c7e5f69eeb882d0485d2a1fff7c">SetColumn</a> (unsigned i, T const *v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the elements of the i'th column to v[j] (No bounds checking).  <a href="#af37d6c7e5f69eeb882d0485d2a1fff7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ac8b884756ccd26369f114543b2f9e066">SetColumn</a> (unsigned i, T value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the elements of the i'th column to value.  <a href="#ac8b884756ccd26369f114543b2f9e066"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a3709e2eaea0b9eb4197c2f3b72167ba3">SetColumn</a> (unsigned j, <a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set j-th colum to v.  <a href="#a3709e2eaea0b9eb4197c2f3b72167ba3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aa008e53c4cff6449118e28d8308959f7">SetColumns</a> (unsigned starting_column, <a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;M)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set columns to those in M, starting at starting_column.  <a href="#aa008e53c4cff6449118e28d8308959f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#af707998ccb85f8d61b95480a28176de5">SetRow</a> (unsigned i, T const *v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the elements of the i'th row to v[j] (No bounds checking).  <a href="#af707998ccb85f8d61b95480a28176de5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ac8b55c00bcb24d7fcf2d68de80c0214e">SetRow</a> (unsigned i, T value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the elements of the i'th row to value.  <a href="#ac8b55c00bcb24d7fcf2d68de80c0214e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a0cea699795ff2ee5ecf6aa633c49422f">SetRow</a> (unsigned i, <a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the i-th row.  <a href="#a0cea699795ff2ee5ecf6aa633c49422f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a2c98629ea08b40937333f8748f0a6302">Extract</a> (unsigned rows, unsigned cols, unsigned top=0, unsigned left=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a sub-matrix of size rows x cols, starting at (top,left).  <a href="#a2c98629ea08b40937333f8748f0a6302"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#afb919d16fb23272d7eab455f354850b7">GetRow</a> (unsigned row) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a vector equal to the given row.  <a href="#afb919d16fb23272d7eab455f354850b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#af375829bf73f5fa22f9850f5baf506f7">GetColumn</a> (unsigned col) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a vector equal to the given column.  <a href="#af375829bf73f5fa22f9850f5baf506f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a58a59fd9cf8b6d0ba980dafc417e1919">GetNRows</a> (unsigned rowstart, unsigned n) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get n rows beginning at rowstart.  <a href="#a58a59fd9cf8b6d0ba980dafc417e1919"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#af9c364e71f7fb25698a68e6b9eea119d">GetNColumns</a> (unsigned colstart, unsigned n) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get n columns beginning at colstart.  <a href="#af9c364e71f7fb25698a68e6b9eea119d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a75233a9e40259eac0bb7e1f0cf849cf9">SetIdentity</a> (T val=T(1))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set this matrix to an identity (or diagonal) matrix.  <a href="#a75233a9e40259eac0bb7e1f0cf849cf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a4cd44931db0fb741dfdf85801eaa88df">InplaceTranspose</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classVNL_1_1Transpose.html" title="Efficient matrix transpose.">Transpose</a> this matrix efficiently.  <a href="#a4cd44931db0fb741dfdf85801eaa88df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ae48802566d7d5996c3de908a03884b13">FlipUD</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverse order of rows.  <a href="#ae48802566d7d5996c3de908a03884b13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a3e86c8f6fb3958ff7d536be32a5b065c">FlipLR</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverse order of columns.  <a href="#a3e86c8f6fb3958ff7d536be32a5b065c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aa9d7c8321f1342c39e804de6656c5204">NormalizeRows</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize each row so it is a unit vector.  <a href="#aa9d7c8321f1342c39e804de6656c5204"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#acdb264e08aaa86e5ad6a992299510700">NormalizeColumns</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize each column so it is a unit vector.  <a href="#acdb264e08aaa86e5ad6a992299510700"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a4e9f7b2c295c2b992efc0a94bf4808f2">ScaleRow</a> (unsigned row, T value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scale elements in given row by a factor of T.  <a href="#a4e9f7b2c295c2b992efc0a94bf4808f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ae87be7fafd426f9ee5f7567663c79078">ScaleColumn</a> (unsigned col, T value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scale elements in given column by a factor of T.  <a href="#ae87be7fafd426f9ee5f7567663c79078"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a2f3c40b3a1e7f2b09cc567f820f36849">Swap</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;that)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap this matrix with that matrix.  <a href="#a2f3c40b3a1e7f2b09cc567f820f36849"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a634092e42eeae1e814146b0009afa914">ArrayOneNorm</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sum of absolute values of elements.  <a href="#a634092e42eeae1e814146b0009afa914"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a1f7dcc0e2369c2c0964e9562d4631bb2">ArrayTwoNorm</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return square root of sum of squared absolute element values.  <a href="#a1f7dcc0e2369c2c0964e9562d4631bb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ad0fbeb1d59ac1458409904aca44b2396">ArrayInfNorm</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return largest absolute element value.  <a href="#ad0fbeb1d59ac1458409904aca44b2396"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a0df05e3904c3c920f04a5f8afdbbff47">AbsoluteValueSum</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sum of absolute values of elements.  <a href="#a0df05e3904c3c920f04a5f8afdbbff47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aabe9d927a5fb1ab62ade531476657411">AbsoluteValueMax</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return largest absolute value.  <a href="#aabe9d927a5fb1ab62ade531476657411"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a3307db07670668e0e713d1ae139a9cae">operatorOneNorm</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a0eae6d0de0a9e4b15f33905325f7df52">operatorInfNorm</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a73d64afb4bcb316f06e023b2b1935565">FrobeniusNorm</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return frobenius norm of matrix (sqrt of sum of squares of its elements).  <a href="#a73d64afb4bcb316f06e023b2b1935565"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aa2722f239eb9b210314d40f4b7c77d1c">FroNorm</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return frobenius norm of matrix (sqrt of sum of squares of its elements).  <a href="#aa2722f239eb9b210314d40f4b7c77d1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a35ae0df75f8e397bd6a9100fcf677c26">RMS</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return RMS of all elements.  <a href="#a35ae0df75f8e397bd6a9100fcf677c26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ac5ab77cee1837ed306d744934c5d13df">MinValue</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return minimum value of elements.  <a href="#ac5ab77cee1837ed306d744934c5d13df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a1493fd44296bcfbc4773f538283245af">MaxValue</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum value of elements.  <a href="#a1493fd44296bcfbc4773f538283245af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a9f33a276b125d6cfa7d9fd8e4a1e6d8a">Mean</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return mean of all matrix elements.  <a href="#a9f33a276b125d6cfa7d9fd8e4a1e6d8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a3ac85e6520d6ff3ef4606e0907e9bfac">IsEmpty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true iff the size is zero.  <a href="#a3ac85e6520d6ff3ef4606e0907e9bfac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#af41eb3b97b367b64bbba36bab9ec2c74">IsIdentity</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if all elements equal to identity.  <a href="#af41eb3b97b367b64bbba36bab9ec2c74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ac4eceaf3f07acc5b986eae5b2b45d33f">IsIdentity</a> (double tol) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if all elements equal to identity, within given tolerance.  <a href="#ac4eceaf3f07acc5b986eae5b2b45d33f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a18897a2283edbe81f212be1e436956c0">IsZero</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if all elements equal to zero.  <a href="#a18897a2283edbe81f212be1e436956c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a56aa9ceb181a20c7f039dece5007d72a">IsZero</a> (double tol) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if all elements equal to zero, within given tolerance.  <a href="#a56aa9ceb181a20c7f039dece5007d72a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a11aec14aa996623f274d4707b2d6be32">IsFinite</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if finite.  <a href="#a11aec14aa996623f274d4707b2d6be32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a99a10121cdbbf6d034897a7de4fe2c26">HasNaNs</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if matrix contains NaNs.  <a href="#a99a10121cdbbf6d034897a7de4fe2c26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a6969051a9c0f635d6f428993bfaa9f4b">assert_size</a> (unsigned rows, unsigned cols) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">abort if size is not as expected.  <a href="#a6969051a9c0f635d6f428993bfaa9f4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a2864a8e27dd897ad1edb41c3439a54e3">assert_finite</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">abort if matrix containins any INFs or NANs.  <a href="#a2864a8e27dd897ad1edb41c3439a54e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a7a6980b7a9f7dc98cff9989874a315d9">ReadASCII</a> (std::istream &amp;s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> from an ascii std::istream.  <a href="#a7a6980b7a9f7dc98cff9989874a315d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a998b3369c5b384b2a6ecb7711d1908d5">DataBlock</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the contiguous block storing the elements in the matrix row-wise. O(1).  <a href="#a998b3369c5b384b2a6ecb7711d1908d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ab3965a2cb2da2bd6000880cb57ced592">DataBlock</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the contiguous block storing the elements in the matrix row-wise. O(1).  <a href="#ab3965a2cb2da2bd6000880cb57ced592"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T const *const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a6fd65e9be20311a7eb6cd6d41aee165c">DataArray</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the 2D array, so that elements can be accessed with array[row][col] directly.  <a href="#a6fd65e9be20311a7eb6cd6d41aee165c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a85e69ba573321510ec08c639d13a404e">DataArray</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the 2D array, so that elements can be accessed with array[row][col] directly.  <a href="#a85e69ba573321510ec08c639d13a404e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a06cbb6154eff4ab9a4aa104e14c88431">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a219c6230062678233916d5c5d4d53757">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator pointing to start of data.  <a href="#a219c6230062678233916d5c5d4d53757"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a6235d47d391413ca573e3a93b6f35d59">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a9a588e20ba3d6db3a00ea8059c0a5c3d">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator pointing to start of data.  <a href="#a9a588e20ba3d6db3a00ea8059c0a5c3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a06cbb6154eff4ab9a4aa104e14c88431">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a35920c1f1f6487229aeb25015b982a9c">end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator pointing to element beyond end of data.  <a href="#a35920c1f1f6487229aeb25015b982a9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a6235d47d391413ca573e3a93b6f35d59">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ad32ecc9db9edf97c6212228352b85f7a">end</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator pointing to element beyond end of data.  <a href="#ad32ecc9db9edf97c6212228352b85f7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a3bd270c6cbcfb5fe7e1ea9cb28672dc6">operator_eq</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;rhs) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if *this == rhs.  <a href="#a3bd270c6cbcfb5fe7e1ea9cb28672dc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a0cdbeca4b99a73ba13e618e352c58493">operator==</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;that) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality operator.  <a href="#a0cdbeca4b99a73ba13e618e352c58493"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a78669d703385e313e0ad6a501028477d">operator!=</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;that) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality operator.  <a href="#a78669d703385e313e0ad6a501028477d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aebbe2d0d79a10b0732d1ad7261cb10bb">print</a> (std::ostream &amp;os) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print matrix to os in some hopefully sensible format.  <a href="#aebbe2d0d79a10b0732d1ad7261cb10bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a976dea052cf6a822270d1b1f1962d2f8">Clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make the matrix as if it had been default-constructed.  <a href="#a976dea052cf6a822270d1b1f1962d2f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ad3221c841512da857742c2cdc8cb53f0">Resize</a> (unsigned r, unsigned c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize to r rows by c columns. Old data lost.  <a href="#ad3221c841512da857742c2cdc8cb53f0"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a1dc673309070ddaffc84a8985ee939f0">Read</a> (std::istream &amp;s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> from an ascii std::istream.  <a href="#a1dc673309070ddaffc84a8985ee939f0"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ad4ca59ce3f2bbec2c0111b1a4c35cfc2">assert_size_internal</a> (unsigned rows, unsigned cols) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abort unless M has the given size.  <a href="#ad4ca59ce3f2bbec2c0111b1a4c35cfc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ab482094e4fb6dc6d6dcf134d1e39253e">assert_finite_internal</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abort if any element of M is inf or nan.  <a href="#ab482094e4fb6dc6d6dcf134d1e39253e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aafd89e336f8e0b9ff934de98825fff1b">destroy</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete data.  <a href="#aafd89e336f8e0b9ff934de98825fff1b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a3caa4ee02f27a6e3790fa9b7bc9ead0f">inline_function_tickler</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a3127ff55911a8a63e45247949a7692d3">num_rows</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#af91a774473dbda01863adad84753302f">num_cols</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a394794c6c1f9a966c3b222c7ea7e177a">data</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int m, int n, class T = double&gt;<br/>
 class VNL::MatrixFixed&lt; m, n, T &gt;</h3>

<p>Fixed size matrix. </p>
<p>A subclass of vnl_matrix_fixed_ref, all storage is local and all vnl_matrix operations are valid. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a34d7b88b6e43815aa9ba7b9ba833ba77"></a><!-- doxytag: member="VNL::MatrixFixed::abs_t" ref="a34d7b88b6e43815aa9ba7b9ba833ba77" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classVNL_1_1CVector.html">CVector</a>&lt;T&gt;::<a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type def for norms. </p>

</div>
</div>
<a class="anchor" id="a6235d47d391413ca573e3a93b6f35d59"></a><!-- doxytag: member="VNL::MatrixFixed::const_iterator" ref="a6235d47d391413ca573e3a93b6f35d59" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T const* <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Matrix.html#a6235d47d391413ca573e3a93b6f35d59">const_iterator</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Const iterators. </p>

</div>
</div>
<a class="anchor" id="acafd662b2adb865bf437c9db33cbfb26"></a><!-- doxytag: member="VNL::MatrixFixed::element_type" ref="acafd662b2adb865bf437c9db33cbfb26" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Matrix.html#acafd662b2adb865bf437c9db33cbfb26">element_type</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a06cbb6154eff4ab9a4aa104e14c88431"></a><!-- doxytag: member="VNL::MatrixFixed::iterator" ref="a06cbb6154eff4ab9a4aa104e14c88431" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Matrix.html#a06cbb6154eff4ab9a4aa104e14c88431">iterator</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterators. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad0acc0c76e45382fd445573384b7133a"></a><!-- doxytag: member="VNL::MatrixFixed::MatrixFixed" ref="ad0acc0c76e45382fd445573384b7133a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int m, int n, class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1MatrixFixed.html">VNL::MatrixFixed</a>&lt; m, n, T &gt;::<a class="el" href="classVNL_1_1MatrixFixed.html">MatrixFixed</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct an empty m*n matrix. </p>

</div>
</div>
<a class="anchor" id="aa9d8dce9627a404762e8e390e8e05096"></a><!-- doxytag: member="VNL::MatrixFixed::MatrixFixed" ref="aa9d8dce9627a404762e8e390e8e05096" args="(const T &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int m, int n, class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1MatrixFixed.html">VNL::MatrixFixed</a>&lt; m, n, T &gt;::<a class="el" href="classVNL_1_1MatrixFixed.html">MatrixFixed</a> </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct an m*n matrix and fill with value. </p>

</div>
</div>
<a class="anchor" id="a911e76340fca6092d7c341aa1c9fb878"></a><!-- doxytag: member="VNL::MatrixFixed::MatrixFixed" ref="a911e76340fca6092d7c341aa1c9fb878" args="(const T *datablck)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int m, int n, class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1MatrixFixed.html">VNL::MatrixFixed</a>&lt; m, n, T &gt;::<a class="el" href="classVNL_1_1MatrixFixed.html">MatrixFixed</a> </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>datablck</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct an m*n <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> and copy data into it row-wise. </p>

</div>
</div>
<a class="anchor" id="a06bda9c34fc517e569dd61193657048b"></a><!-- doxytag: member="VNL::MatrixFixed::MatrixFixed" ref="a06bda9c34fc517e569dd61193657048b" args="(const Matrix&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int m, int n, class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1MatrixFixed.html">VNL::MatrixFixed</a>&lt; m, n, T &gt;::<a class="el" href="classVNL_1_1MatrixFixed.html">MatrixFixed</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct an m*n <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> and copy rhs into it. </p>
<p>Abort if rhs is not the same size. </p>

</div>
</div>
<a class="anchor" id="accb989a3a4a6dcf7816ff64827e17493"></a><!-- doxytag: member="VNL::MatrixFixed::~MatrixFixed" ref="accb989a3a4a6dcf7816ff64827e17493" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int m, int n, class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1MatrixFixed.html">VNL::MatrixFixed</a>&lt; m, n, T &gt;::~<a class="el" href="classVNL_1_1MatrixFixed.html">MatrixFixed</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a50976c1402a305a41369a970b4c570e1"></a><!-- doxytag: member="VNL::MatrixFixed::MatrixFixed" ref="a50976c1402a305a41369a970b4c570e1" args="(const MatrixFixed&lt; m, n, T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int m, int n, class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1MatrixFixed.html">VNL::MatrixFixed</a>&lt; m, n, T &gt;::<a class="el" href="classVNL_1_1MatrixFixed.html">MatrixFixed</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVNL_1_1MatrixFixed.html">MatrixFixed</a>&lt; m, n, T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aabe9d927a5fb1ab62ade531476657411"></a><!-- doxytag: member="VNL::MatrixFixed::AbsoluteValueMax" ref="aabe9d927a5fb1ab62ade531476657411" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::AbsoluteValueMax </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return largest absolute value. </p>

</div>
</div>
<a class="anchor" id="a0df05e3904c3c920f04a5f8afdbbff47"></a><!-- doxytag: member="VNL::MatrixFixed::AbsoluteValueSum" ref="a0df05e3904c3c920f04a5f8afdbbff47" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::AbsoluteValueSum </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return sum of absolute values of elements. </p>

</div>
</div>
<a class="anchor" id="a217e6df8c3e79ffad8c8ef50256a660b"></a><!-- doxytag: member="VNL::MatrixFixed::Apply" ref="a217e6df8c3e79ffad8c8ef50256a660b" args="(T(*f)(T const &amp;)) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Apply </td>
          <td>(</td>
          <td class="paramtype">T(*)(T const &amp;)&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a new matrix by applying function to each element. </p>
<p>Return the matrix made by applying "f" to each element. </p>

<p>References <a class="el" href="matrix_8tpp_source.html#l00658">VNL::Matrix&lt; T &gt;::Apply()</a>, <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8h_source.html#l00564">VNL::Matrix&lt; T &gt;::DataBlock()</a>, and <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>.</p>

</div>
</div>
<a class="anchor" id="a7c95a6fc9f329a9f8bb0197243219a5e"></a><!-- doxytag: member="VNL::MatrixFixed::Apply" ref="a7c95a6fc9f329a9f8bb0197243219a5e" args="(T(*f)(T)) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Apply </td>
          <td>(</td>
          <td class="paramtype">T(*)(T)&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a new matrix by applying function to each element. </p>
<p>Return the matrix made by applying "f" to each element. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8h_source.html#l00564">VNL::Matrix&lt; T &gt;::DataBlock()</a>, and <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>.</p>

<p>Referenced by <a class="el" href="matrix_8tpp_source.html#l00649">VNL::Matrix&lt; T &gt;::Apply()</a>.</p>

</div>
</div>
<a class="anchor" id="ad0fbeb1d59ac1458409904aca44b2396"></a><!-- doxytag: member="VNL::MatrixFixed::ArrayInfNorm" ref="ad0fbeb1d59ac1458409904aca44b2396" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::ArrayInfNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return largest absolute element value. </p>

<p>Referenced by <a class="el" href="matrix_8h_source.html#l00459">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::AbsoluteValueMax()</a>.</p>

</div>
</div>
<a class="anchor" id="a634092e42eeae1e814146b0009afa914"></a><!-- doxytag: member="VNL::MatrixFixed::ArrayOneNorm" ref="a634092e42eeae1e814146b0009afa914" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::ArrayOneNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return sum of absolute values of elements. </p>

<p>Referenced by <a class="el" href="matrix_8h_source.html#l00455">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::AbsoluteValueSum()</a>.</p>

</div>
</div>
<a class="anchor" id="a1f7dcc0e2369c2c0964e9562d4631bb2"></a><!-- doxytag: member="VNL::MatrixFixed::ArrayTwoNorm" ref="a1f7dcc0e2369c2c0964e9562d4631bb2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::ArrayTwoNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return square root of sum of squared absolute element values. </p>

</div>
</div>
<a class="anchor" id="a2864a8e27dd897ad1edb41c3439a54e3"></a><!-- doxytag: member="VNL::MatrixFixed::assert_finite" ref="a2864a8e27dd897ad1edb41c3439a54e3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::assert_finite </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>abort if matrix containins any INFs or NANs. </p>
<p>This function does or tests nothing if NDEBUG is defined </p>

<p>Referenced by <a class="el" href="svd_8tpp_source.html#l00042">VNL::SVD&lt; T &gt;::SVD()</a>, and <a class="el" href="symmetriceigensystem_8cpp_source.html#l00034">VNL::SymmetricEigensystemCompute()</a>.</p>

</div>
</div>
<a class="anchor" id="ab482094e4fb6dc6d6dcf134d1e39253e"></a><!-- doxytag: member="VNL::MatrixFixed::assert_finite_internal" ref="ab482094e4fb6dc6d6dcf134d1e39253e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::assert_finite_internal </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abort if any element of M is inf or nan. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, <a class="el" href="bignum_8h_source.html#l00396">VNL::IsFinite()</a>, <a class="el" href="matrix_8tpp_source.html#l01167">VNL::Matrix&lt; T &gt;::IsFinite()</a>, and <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>.</p>

<p>Referenced by <a class="el" href="matrix_8h_source.html#l00543">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::assert_finite()</a>.</p>

</div>
</div>
<a class="anchor" id="a6969051a9c0f635d6f428993bfaa9f4b"></a><!-- doxytag: member="VNL::MatrixFixed::assert_size" ref="a6969051a9c0f635d6f428993bfaa9f4b" args="(unsigned rows, unsigned cols) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::assert_size </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>cols</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>abort if size is not as expected. </p>
<p>This function does or tests nothing if NDEBUG is defined </p>

<p>Referenced by <a class="el" href="adjugate_8tpp_source.html#l00018">VNL::Adjugate()</a>, <a class="el" href="complexeigensystem_8cpp_source.html#l00102">VNL::ComplexEigensystem::ComplexEigensystem()</a>, and <a class="el" href="matrixexp_8tpp_source.html#l00014">VNL::MatrixExp()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4ca59ce3f2bbec2c0111b1a4c35cfc2"></a><!-- doxytag: member="VNL::MatrixFixed::assert_size_internal" ref="ad4ca59ce3f2bbec2c0111b1a4c35cfc2" args="(unsigned rows, unsigned cols) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::assert_size_internal </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>cols</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abort unless M has the given size. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, and <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>.</p>

<p>Referenced by <a class="el" href="matrix_8h_source.html#l00535">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::assert_size()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a588e20ba3d6db3a00ea8059c0a5c3d"></a><!-- doxytag: member="VNL::MatrixFixed::begin" ref="a9a588e20ba3d6db3a00ea8059c0a5c3d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a6235d47d391413ca573e3a93b6f35d59">const_iterator</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator pointing to start of data. </p>

</div>
</div>
<a class="anchor" id="a219c6230062678233916d5c5d4d53757"></a><!-- doxytag: member="VNL::MatrixFixed::begin" ref="a219c6230062678233916d5c5d4d53757" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a06cbb6154eff4ab9a4aa104e14c88431">iterator</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator pointing to start of data. </p>

<p>Referenced by <a class="el" href="matrix_8h_source.html#l00451">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::ArrayInfNorm()</a>, <a class="el" href="matrix_8h_source.html#l00443">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::ArrayOneNorm()</a>, <a class="el" href="matrix_8h_source.html#l00447">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::ArrayTwoNorm()</a>, <a class="el" href="complexeigensystem_8cpp_source.html#l00102">VNL::ComplexEigensystem::ComplexEigensystem()</a>, <a class="el" href="matrix_8tpp_source.html#l00682">VNL::Matrix&lt; T &gt;::ConjugateTranspose()</a>, <a class="el" href="matrix_8h_source.html#l00469">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::FrobeniusNorm()</a>, <a class="el" href="generalizedschur_8h_source.html#l00047">VNL::GeneralizedSchur()</a>, <a class="el" href="matrix_8h_source.html#l00485">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::MaxValue()</a>, <a class="el" href="matrix_8h_source.html#l00489">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::Mean()</a>, <a class="el" href="matrix_8h_source.html#l00481">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::MinValue()</a>, <a class="el" href="matrix_8h_source.html#l00477">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::RMS()</a>, and <a class="el" href="complexops_8tpp_source.html#l00048">vnl_complexify()</a>.</p>

</div>
</div>
<a class="anchor" id="a976dea052cf6a822270d1b1f1962d2f8"></a><!-- doxytag: member="VNL::MatrixFixed::Clear" ref="a976dea052cf6a822270d1b1f1962d2f8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make the matrix as if it had been default-constructed. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8tpp_source.html#l00344">VNL::Matrix&lt; T &gt;::destroy()</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00633">VNL::Matrix&lt; T &gt;::num_rows</a>.</p>

<p>Referenced by <a class="el" href="binary_8cpp_source.html#l00065">VNL::BinaryLoad()</a>, and <a class="el" href="matrix_8tpp_source.html#l00425">VNL::Matrix&lt; T &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="ad63ed64557a003f336a5ff0dca39ee72"></a><!-- doxytag: member="VNL::MatrixFixed::Cols" ref="ad63ed64557a003f336a5ff0dca39ee72" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Cols </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return number of columns. </p>
<p>A synonym for columns() </p>

<p>Referenced by <a class="el" href="binary_8cpp_source.html#l00052">VNL::BinarySave()</a>, <a class="el" href="generalizedschur_8h_source.html#l00047">VNL::GeneralizedSchur()</a>, <a class="el" href="matlabread_8cpp_source.html#l00209">VNL::MatlabReadOrDie()</a>, <a class="el" href="matrixexp_8tpp_source.html#l00052">VNL::MatrixExp()</a>, <a class="el" href="matrix_8h_source.html#l00201">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::operator()()</a>, <a class="el" href="homography2d_8h_source.html#l00299">VW::Homography2DCovariance::operator=()</a>, <a class="el" href="fmatrixaffine_8h_source.html#l00305">VW::FMatrixAffineCovariance::operator=()</a>, <a class="el" href="fmatrixaffine_8h_source.html#l00168">VW::FMatrixAffine::operator=()</a>, <a class="el" href="fmatrix_8h_source.html#l00257">VW::FMatrixCovariance::operator=()</a>, <a class="el" href="symmatrix_8tpp_source.html#l00112">operator==()</a>, <a class="el" href="realnpolynomial_8cpp_source.html#l00096">VNL::RealNPolynomial::Set()</a>, <a class="el" href="matrix_8h_source.html#l00178">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::size()</a>, <a class="el" href="matrix_8h_source.html#l00173">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::Size()</a>, <a class="el" href="symmatrix_8h_source.html#l00190">VNL::SymMatrix&lt; T &gt;::SymMatrix()</a>, <a class="el" href="trace_8cpp_source.html#l00015">VNL::Trace()</a>, and <a class="el" href="matlabfilewrite_8cpp_source.html#l00060">VNL::MatlabFilewrite::Write()</a>.</p>

</div>
</div>
<a class="anchor" id="add52389f027d9a631813400db620f162"></a><!-- doxytag: member="VNL::MatrixFixed::Columns" ref="add52389f027d9a631813400db620f162" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Columns </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return number of columns. </p>
<p>A synonym for cols() </p>

<p>Referenced by <a class="el" href="fastops_8cpp_source.html#l00062">vnl_fastops::AB()</a>, <a class="el" href="fastops_8cpp_source.html#l00162">vnl_fastops::ABt()</a>, <a class="el" href="adjugate_8tpp_source.html#l00036">VNL::Adjugate()</a>, <a class="el" href="matrix_8tpp_source.html#l01180">VNL::Matrix&lt; T &gt;::assert_finite_internal()</a>, <a class="el" href="matrix_8tpp_source.html#l01208">VNL::Matrix&lt; T &gt;::assert_size_internal()</a>, <a class="el" href="fastops_8cpp_source.html#l00020">vnl_fastops::AtA()</a>, <a class="el" href="fastops_8cpp_source.html#l00096">vnl_fastops::AtB()</a>, <a class="el" href="matops_8cpp_source.html#l00019">vnl_matops::cat()</a>, <a class="el" href="cholesky_8tpp_source.html#l00051">VNL::Cholesky&lt; T &gt;::Cholesky()</a>, <a class="el" href="fastops_8cpp_source.html#l00363">vnl_fastops::dec_X_by_ABt()</a>, <a class="el" href="fastops_8cpp_source.html#l00304">vnl_fastops::dec_X_by_AtB()</a>, <a class="el" href="determinant_8tpp_source.html#l00060">VNL::Determinant()</a>, <a class="el" href="leastsquaresfunction_8cpp_source.html#l00075">VNL::LeastSquaresFunction::FDGradF()</a>, <a class="el" href="matrix_8tpp_source.html#l01376">VNL::Matrix&lt; T &gt;::FlipLR()</a>, <a class="el" href="matrix_8tpp_source.html#l01357">VNL::Matrix&lt; T &gt;::FlipUD()</a>, <a class="el" href="essentialmatrixcompute5point_8cpp_source.html#l00187">GetRowEchelonForm()</a>, <a class="el" href="leastsquarescostfunction_8cpp_source.html#l00030">VNL::LeastSquaresCostFunction::GradF()</a>, <a class="el" href="matrix_8tpp_source.html#l01154">VNL::Matrix&lt; T &gt;::HasNaNs()</a>, <a class="el" href="fastops_8cpp_source.html#l00196">vnl_fastops::inc_X_by_AtA()</a>, <a class="el" href="fastops_8cpp_source.html#l00235">vnl_fastops::inc_X_by_AtB()</a>, <a class="el" href="matrix_8tpp_source.html#l01549">VNL::Matrix&lt; T &gt;::InplaceTranspose()</a>, <a class="el" href="matrix_8tpp_source.html#l01167">VNL::Matrix&lt; T &gt;::IsFinite()</a>, <a class="el" href="matrix_8tpp_source.html#l01097">VNL::Matrix&lt; T &gt;::IsIdentity()</a>, <a class="el" href="matrix_8tpp_source.html#l01127">VNL::Matrix&lt; T &gt;::IsZero()</a>, <a class="el" href="matlabprint_8tpp_source.html#l00075">VNL::MatlabPrint()</a>, <a class="el" href="matrixfixed_8h_source.html#l00065">VNL::MatrixFixed&lt; 9, 9, double &gt;::MatrixFixed()</a>, <a class="el" href="transpose_8h_source.html#l00064">VNL::Transpose::operator*()</a>, <a class="el" href="diagmatrix_8h_source.html#l00190">VNL::operator*()</a>, <a class="el" href="projectionmatrix_8h_source.html#l00152">VW::ProjectionMatrix::operator=()</a>, <a class="el" href="matrixfixedref_8h_source.html#l00096">VNL::MatrixFixedRef&lt; m, n, float &gt;::operator=()</a>, <a class="el" href="matrixfixed_8h_source.html#l00079">VNL::MatrixFixed&lt; 9, 9, double &gt;::operator=()</a>, <a class="el" href="homography2d_8h_source.html#l00267">VW::Homography2D::operator=()</a>, <a class="el" href="fmatrix_8h_source.html#l00165">VW::FMatrix::operator=()</a>, <a class="el" href="essentialmatrix_8h_source.html#l00107">VW::EssentialMatrix::operator=()</a>, <a class="el" href="vector_8tpp_source.html#l00494">VNL::Vector&lt; T &gt;::PostMultiply()</a>, <a class="el" href="vector_8tpp_source.html#l00470">VNL::Vector&lt; T &gt;::PreMultiply()</a>, <a class="el" href="matrix_8tpp_source.html#l00442">VNL::Matrix&lt; T &gt;::print()</a>, <a class="el" href="projectionmatrix_8h_source.html#l00108">VW::ProjectionMatrix::ProjectionMatrix()</a>, <a class="el" href="qr_8tpp_source.html#l00040">VNL::QR&lt; T &gt;::QR()</a>, <a class="el" href="matrix_8tpp_source.html#l01221">VNL::Matrix&lt; T &gt;::ReadASCII()</a>, <a class="el" href="realeigensystem_8cpp_source.html#l00023">VNL::RealEigensystem::RealEigensystem()</a>, <a class="el" href="svd_8tpp_source.html#l00301">VNL::SVD&lt; T &gt;::Solve()</a>, <a class="el" href="svd_8tpp_source.html#l00042">VNL::SVD&lt; T &gt;::SVD()</a>, <a class="el" href="symmetriceigensystem_8cpp_source.html#l00020">VNL::SymmetricEigensystemCompute()</a>, <a class="el" href="matops_8cpp_source.html#l00062">vnl_matops::vcat()</a>, <a class="el" href="vector_8tpp_source.html#l00234">VNL::Vector&lt; T &gt;::Vector()</a>, <a class="el" href="complexops_8tpp_source.html#l00048">vnl_complexify()</a>, <a class="el" href="discretediff_8cpp_source.html#l00034">vnl_discrete_diff_fwd()</a>, <a class="el" href="discretediff_8cpp_source.html#l00072">vnl_discrete_diff_sym()</a>, and <a class="el" href="fortrancopy_8tpp_source.html#l00015">vnl_fortran_copy&lt; T &gt;::vnl_fortran_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ac0fecc5000343427236e3bbe55c9caf0"></a><!-- doxytag: member="VNL::MatrixFixed::ConjugateTranspose" ref="ac0fecc5000343427236e3bbe55c9caf0" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::ConjugateTranspose </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return conjugate transpose. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00588">VNL::Matrix&lt; T &gt;::begin()</a>, <a class="el" href="matrix_8h_source.html#l00178">VNL::Matrix&lt; T &gt;::size()</a>, and <a class="el" href="matrix_8tpp_source.html#l00671">VNL::Matrix&lt; T &gt;::Transpose()</a>.</p>

</div>
</div>
<a class="anchor" id="afeb71efdf105aed29b5d726eb0a2f915"></a><!-- doxytag: member="VNL::MatrixFixed::CopyIn" ref="afeb71efdf105aed29b5d726eb0a2f915" args="(T const *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::CopyIn </td>
          <td>(</td>
          <td class="paramtype">T const *&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill (laminate) this matrix with the given data. </p>
<p>Fill this matrix with the given data.</p>
<p>We assume that p points to a contiguous rows*cols array, stored rowwise. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, and <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>.</p>

<p>Referenced by <a class="el" href="computefuncs_8h_source.html#l00034">VW::ComputeFuncs::ConvertParamVectorToTransform()</a>, and <a class="el" href="matrix_8h_source.html#l00243">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::Set()</a>.</p>

</div>
</div>
<a class="anchor" id="aac98f4f0c40b2bb0899d2eea24565054"></a><!-- doxytag: member="VNL::MatrixFixed::CopyOut" ref="aac98f4f0c40b2bb0899d2eea24565054" args="(T *) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::CopyOut </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill the given array with this matrix. </p>
<p>We assume that p points to a contiguous rows*cols array, stored rowwise. No bounds checking on the array</p>
<p>We assume that p points to a contiguous rows*cols array, stored rowwise. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, and <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>.</p>

<p>Referenced by <a class="el" href="computefuncs_8h_source.html#l00017">VW::ComputeFuncs::ConvertTransformToParamVector()</a>.</p>

</div>
</div>
<a class="anchor" id="a85e69ba573321510ec08c639d13a404e"></a><!-- doxytag: member="VNL::MatrixFixed::DataArray" ref="a85e69ba573321510ec08c639d13a404e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* * <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::DataArray </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the 2D array, so that elements can be accessed with array[row][col] directly. </p>
<p>2d array, [row][column]. </p>

</div>
</div>
<a class="anchor" id="a6fd65e9be20311a7eb6cd6d41aee165c"></a><!-- doxytag: member="VNL::MatrixFixed::DataArray" ref="a6fd65e9be20311a7eb6cd6d41aee165c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T const* const* <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::DataArray </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the 2D array, so that elements can be accessed with array[row][col] directly. </p>
<p>2d array, [row][column]. </p>

<p>Referenced by <a class="el" href="fastops_8cpp_source.html#l00062">vnl_fastops::AB()</a>, <a class="el" href="fastops_8cpp_source.html#l00162">vnl_fastops::ABt()</a>, <a class="el" href="fastops_8cpp_source.html#l00020">vnl_fastops::AtA()</a>, <a class="el" href="fastops_8cpp_source.html#l00096">vnl_fastops::AtB()</a>, <a class="el" href="binary_8cpp_source.html#l00052">VNL::BinarySave()</a>, <a class="el" href="fastops_8cpp_source.html#l00363">vnl_fastops::dec_X_by_ABt()</a>, <a class="el" href="fastops_8cpp_source.html#l00304">vnl_fastops::dec_X_by_AtB()</a>, <a class="el" href="fastops_8cpp_source.html#l00196">vnl_fastops::inc_X_by_AtA()</a>, <a class="el" href="fastops_8cpp_source.html#l00235">vnl_fastops::inc_X_by_AtB()</a>, <a class="el" href="matlabread_8cpp_source.html#l00209">VNL::MatlabReadOrDie()</a>, and <a class="el" href="matlabfilewrite_8cpp_source.html#l00060">VNL::MatlabFilewrite::Write()</a>.</p>

</div>
</div>
<a class="anchor" id="ab3965a2cb2da2bd6000880cb57ced592"></a><!-- doxytag: member="VNL::MatrixFixed::DataBlock" ref="ab3965a2cb2da2bd6000880cb57ced592" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::DataBlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the contiguous block storing the elements in the matrix row-wise. O(1). </p>
<p>1d array, row-major order. </p>

</div>
</div>
<a class="anchor" id="a998b3369c5b384b2a6ecb7711d1908d5"></a><!-- doxytag: member="VNL::MatrixFixed::DataBlock" ref="a998b3369c5b384b2a6ecb7711d1908d5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T const* <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::DataBlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the contiguous block storing the elements in the matrix row-wise. O(1). </p>
<p>1d array, row-major order. </p>

<p>Referenced by <a class="el" href="matrix_8tpp_source.html#l00649">VNL::Matrix&lt; T &gt;::Apply()</a>, <a class="el" href="binary_8cpp_source.html#l00065">VNL::BinaryLoad()</a>, <a class="el" href="binary_8cpp_source.html#l00052">VNL::BinarySave()</a>, <a class="el" href="parametricflow_8cpp_source.html#l00374">VW::ParametricFlowNonLin::Compute()</a>, <a class="el" href="cholesky_8tpp_source.html#l00109">VNL::Cholesky&lt; T &gt;::Determinant()</a>, <a class="el" href="matrix_8tpp_source.html#l01549">VNL::Matrix&lt; T &gt;::InplaceTranspose()</a>, <a class="el" href="cholesky_8tpp_source.html#l00122">VNL::Cholesky&lt; T &gt;::Inverse()</a>, <a class="el" href="matrixfixed_8h_source.html#l00065">VNL::MatrixFixed&lt; 9, 9, double &gt;::MatrixFixed()</a>, <a class="el" href="levenbergmarquardt_8cpp_source.html#l00276">VNL::LevenbergMarquardt::MinimizeUsingGradient()</a>, <a class="el" href="levenbergmarquardt_8cpp_source.html#l00145">VNL::LevenbergMarquardt::MinimizeWithoutGradient()</a>, <a class="el" href="matrixfixedref_8h_source.html#l00096">VNL::MatrixFixedRef&lt; m, n, float &gt;::operator=()</a>, <a class="el" href="matrixfixed_8h_source.html#l00079">VNL::MatrixFixed&lt; 9, 9, double &gt;::operator=()</a>, <a class="el" href="homography2d_8h_source.html#l00299">VW::Homography2DCovariance::operator=()</a>, <a class="el" href="fmatrixaffine_8h_source.html#l00305">VW::FMatrixAffineCovariance::operator=()</a>, <a class="el" href="fmatrix_8h_source.html#l00257">VW::FMatrixCovariance::operator=()</a>, <a class="el" href="realeigensystem_8cpp_source.html#l00023">VNL::RealEigensystem::RealEigensystem()</a>, and <a class="el" href="symmetriceigensystem_8cpp_source.html#l00034">VNL::SymmetricEigensystemCompute()</a>.</p>

</div>
</div>
<a class="anchor" id="aafd89e336f8e0b9ff934de98825fff1b"></a><!-- doxytag: member="VNL::MatrixFixed::destroy" ref="aafd89e336f8e0b9ff934de98825fff1b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::destroy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete data. </p>
<p>Frees up the dynamic storage used by matrix.</p>
<p>O(m*n). </p>

<p>References <a class="el" href="matrix_8tpp_source.html#l00120">vnl_matrix_free_blah</a>.</p>

<p>Referenced by <a class="el" href="matrix_8tpp_source.html#l00350">VNL::Matrix&lt; T &gt;::Clear()</a>, and <a class="el" href="matrix_8h_source.html#l00148">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::~Matrix()</a>.</p>

</div>
</div>
<a class="anchor" id="ad32ecc9db9edf97c6212228352b85f7a"></a><!-- doxytag: member="VNL::MatrixFixed::end" ref="ad32ecc9db9edf97c6212228352b85f7a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a6235d47d391413ca573e3a93b6f35d59">const_iterator</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator pointing to element beyond end of data. </p>

</div>
</div>
<a class="anchor" id="a35920c1f1f6487229aeb25015b982a9c"></a><!-- doxytag: member="VNL::MatrixFixed::end" ref="a35920c1f1f6487229aeb25015b982a9c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a06cbb6154eff4ab9a4aa104e14c88431">iterator</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator pointing to element beyond end of data. </p>

<p>Referenced by <a class="el" href="generalizedschur_8h_source.html#l00047">VNL::GeneralizedSchur()</a>.</p>

</div>
</div>
<a class="anchor" id="a2c98629ea08b40937333f8748f0a6302"></a><!-- doxytag: member="VNL::MatrixFixed::Extract" ref="a2c98629ea08b40937333f8748f0a6302" args="(unsigned rows, unsigned cols, unsigned top=0, unsigned left=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Extract </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>rowz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>colz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>top</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>left</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract a sub-matrix of size rows x cols, starting at (top,left). </p>
<p>Returns a copy of submatrix of THIS matrix, specified by the top-left corner and size in rows, cols. O(m*n).</p>
<p>Thus it contains elements [top,top+rows-1][left,left+cols-1]</p>
<p>Use update() to copy new values of this submatrix back into THIS matrix. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00074">VNL::ErrorMatrixDimension()</a>, and <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>.</p>

</div>
</div>
<a class="anchor" id="abebe72526015607ee129e2d4687bc7e2"></a><!-- doxytag: member="VNL::MatrixFixed::Fill" ref="abebe72526015607ee129e2d4687bc7e2" args="(T const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Fill </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set all elements of matrix to specified value. </p>
<p>Sets all elements of matrix to specified value. O(m*n).</p>
<p>Complexity <img class="formulaInl" alt="$O(r.c)$" src="form_31.png"/> </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00633">VNL::Matrix&lt; T &gt;::num_rows</a>.</p>

<p>Referenced by <a class="el" href="covariance2d_8cpp_source.html#l00028">VW::Covariance2D::CholeskyDecompose()</a>, and <a class="el" href="matrix_8h_source.html#l00256">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a8d451a78fc2585574896abac68e4c008"></a><!-- doxytag: member="VNL::MatrixFixed::FillDiagonal" ref="a8d451a78fc2585574896abac68e4c008" args="(T const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::FillDiagonal </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set all diagonal elements of matrix to specified value. </p>
<p>Sets all diagonal elements of matrix to specified value. O(n).</p>
<p>Complexity <img class="formulaInl" alt="$O(\min(r,c))$" src="form_33.png"/> </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00633">VNL::Matrix&lt; T &gt;::num_rows</a>.</p>

</div>
</div>
<a class="anchor" id="a3e86c8f6fb3958ff7d536be32a5b065c"></a><!-- doxytag: member="VNL::MatrixFixed::FlipLR" ref="a3e86c8f6fb3958ff7d536be32a5b065c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::FlipLR </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverse order of columns. </p>

<p>References <a class="el" href="qr_8tpp.html#aafc737ea9ef91f59cf9acd287fb8d085">c</a>, <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, and <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>.</p>

</div>
</div>
<a class="anchor" id="ae48802566d7d5996c3de908a03884b13"></a><!-- doxytag: member="VNL::MatrixFixed::FlipUD" ref="ae48802566d7d5996c3de908a03884b13" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::FlipUD </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverse order of rows. </p>
<p>Reverse order of rows. Name is from Matlab, meaning "flip upside down". </p>

<p>References <a class="el" href="qr_8tpp.html#aafc737ea9ef91f59cf9acd287fb8d085">c</a>, <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, and <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>.</p>

</div>
</div>
<a class="anchor" id="a73d64afb4bcb316f06e023b2b1935565"></a><!-- doxytag: member="VNL::MatrixFixed::FrobeniusNorm" ref="a73d64afb4bcb316f06e023b2b1935565" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::FrobeniusNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return frobenius norm of matrix (sqrt of sum of squares of its elements). </p>

<p>Referenced by <a class="el" href="computefuncs_8h_source.html#l00034">VW::ComputeFuncs::ConvertParamVectorToTransform()</a>, <a class="el" href="computefuncs_8h_source.html#l00017">VW::ComputeFuncs::ConvertTransformToParamVector()</a>, <a class="el" href="matrix_8h_source.html#l00473">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::FroNorm()</a>, <a class="el" href="fmatrixcomputenonlinear_8cpp_source.html#l00043">VW::FMatrixCompute::GenerateParameterVector()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00032">VW::FMPlanarCompute::GenerateParameterVectorHZ()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00224">VW::FMPlanarCompute::GenerateParameterVectorHZJK()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00118">VW::FMPlanarCompute::GenerateParameterVectorVLJK()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00094">VW::FMPlanarCompute::ReconstructTransformHZ()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00302">VW::FMPlanarCompute::ReconstructTransformHZJK()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00190">VW::FMPlanarCompute::ReconstructTransformVLJK()</a>, and <a class="el" href="svd_8tpp_source.html#l00042">VNL::SVD&lt; T &gt;::SVD()</a>.</p>

</div>
</div>
<a class="anchor" id="aa2722f239eb9b210314d40f4b7c77d1c"></a><!-- doxytag: member="VNL::MatrixFixed::FroNorm" ref="aa2722f239eb9b210314d40f4b7c77d1c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::FroNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return frobenius norm of matrix (sqrt of sum of squares of its elements). </p>

</div>
</div>
<a class="anchor" id="a3af3fc536ac0f6b7bbc6ce05010b29d7"></a><!-- doxytag: member="VNL::MatrixFixed::Get" ref="a3af3fc536ac0f6b7bbc6ce05010b29d7" args="(unsigned r, unsigned c) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Get </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>column</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get element with boundary checks if error checking is on. </p>
<p>get -- Returns the value of the element at specified row and column. O(1).</p>
<p>Checks for valid range of indices. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00633">VNL::Matrix&lt; T &gt;::num_rows</a>.</p>

</div>
</div>
<a class="anchor" id="af375829bf73f5fa22f9850f5baf506f7"></a><!-- doxytag: member="VNL::MatrixFixed::GetColumn" ref="af375829bf73f5fa22f9850f5baf506f7" args="(unsigned col) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::GetColumn </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a vector equal to the given column. </p>
<p>Create a vector out of column[column_index]. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00065">VNL::ErrorMatrixColIndex()</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00036">v</a>.</p>

<p>Referenced by <a class="el" href="determinant_8tpp_source.html#l00060">VNL::Determinant()</a>.</p>

</div>
</div>
<a class="anchor" id="af9c364e71f7fb25698a68e6b9eea119d"></a><!-- doxytag: member="VNL::MatrixFixed::GetNColumns" ref="af9c364e71f7fb25698a68e6b9eea119d" args="(unsigned colstart, unsigned n) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::GetNColumns </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>colstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get n columns beginning at colstart. </p>
<p>Returns a copy of n columns, starting from "column". </p>

<p>References <a class="el" href="qr_8tpp.html#aafc737ea9ef91f59cf9acd287fb8d085">c</a>, <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00065">VNL::ErrorMatrixColIndex()</a>, and <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>.</p>

<p>Referenced by <a class="el" href="generalizedeigensystem_8cpp_source.html#l00023">VNL::GeneralizedEigensystem::GeneralizedEigensystem()</a>.</p>

</div>
</div>
<a class="anchor" id="a58a59fd9cf8b6d0ba980dafc417e1919"></a><!-- doxytag: member="VNL::MatrixFixed::GetNRows" ref="a58a59fd9cf8b6d0ba980dafc417e1919" args="(unsigned rowstart, unsigned n) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::GetNRows </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>rowstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get n rows beginning at rowstart. </p>
<p>Returns a copy of n rows, starting from "row". </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00055">VNL::ErrorMatrixRowIndex()</a>, and <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>.</p>

</div>
</div>
<a class="anchor" id="afb919d16fb23272d7eab455f354850b7"></a><!-- doxytag: member="VNL::MatrixFixed::GetRow" ref="afb919d16fb23272d7eab455f354850b7" args="(unsigned row) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::GetRow </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a vector equal to the given row. </p>
<p>Create a vector out of row[row_index]. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00055">VNL::ErrorMatrixRowIndex()</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00036">v</a>.</p>

<p>Referenced by <a class="el" href="determinant_8tpp_source.html#l00060">VNL::Determinant()</a>, <a class="el" href="essentialmatrixcompute5point_8cpp_source.html#l00187">GetRowEchelonForm()</a>, <a class="el" href="complexeigensystem_8h_source.html#l00061">VNL::ComplexEigensystem::LeftEigenVector()</a>, and <a class="el" href="complexeigensystem_8h_source.html#l00063">VNL::ComplexEigensystem::RightEigenVector()</a>.</p>

</div>
</div>
<a class="anchor" id="a99a10121cdbbf6d034897a7de4fe2c26"></a><!-- doxytag: member="VNL::MatrixFixed::HasNaNs" ref="a99a10121cdbbf6d034897a7de4fe2c26" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::HasNaNs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if matrix contains NaNs. </p>
<p>Return true if any element of (*this) is nan. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, <a class="el" href="bignum_8h_source.html#l00395">VNL::IsNaN()</a>, and <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>.</p>

</div>
</div>
<a class="anchor" id="a3caa4ee02f27a6e3790fa9b7bc9ead0f"></a><!-- doxytag: member="VNL::MatrixFixed::inline_function_tickler" ref="a3caa4ee02f27a6e3790fa9b7bc9ead0f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::inline_function_tickler </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4cd44931db0fb741dfdf85801eaa88df"></a><!-- doxytag: member="VNL::MatrixFixed::InplaceTranspose" ref="a4cd44931db0fb741dfdf85801eaa88df" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::InplaceTranspose </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classVNL_1_1Transpose.html" title="Efficient matrix transpose.">Transpose</a> this matrix efficiently. </p>
<p><a class="el" href="classVNL_1_1Transpose.html" title="Efficient matrix transpose.">Transpose</a> matrix M in place.</p>
<p>Works for rectangular matrices using an enormously clever algorithm from ACM TOMS. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8h_source.html#l00564">VNL::Matrix&lt; T &gt;::DataBlock()</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>.</p>

<p>Referenced by <a class="el" href="levenbergmarquardt_8cpp_source.html#l00234">VNL::LevenbergMarquardt::lmder_lsqfun()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ac85e6520d6ff3ef4606e0907e9bfac"></a><!-- doxytag: member="VNL::MatrixFixed::IsEmpty" ref="a3ac85e6520d6ff3ef4606e0907e9bfac" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true iff the size is zero. </p>

</div>
</div>
<a class="anchor" id="a11aec14aa996623f274d4707b2d6be32"></a><!-- doxytag: member="VNL::MatrixFixed::IsFinite" ref="a11aec14aa996623f274d4707b2d6be32" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::IsFinite </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if finite. </p>
<p>Return false if any element of (*this) is inf or nan. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, <a class="el" href="bignum_8h_source.html#l00396">VNL::IsFinite()</a>, and <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>.</p>

<p>Referenced by <a class="el" href="matrix_8tpp_source.html#l01180">VNL::Matrix&lt; T &gt;::assert_finite_internal()</a>.</p>

</div>
</div>
<a class="anchor" id="ac4eceaf3f07acc5b986eae5b2b45d33f"></a><!-- doxytag: member="VNL::MatrixFixed::IsIdentity" ref="ac4eceaf3f07acc5b986eae5b2b45d33f" args="(double tol) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::IsIdentity </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if all elements equal to identity, within given tolerance. </p>
<p>Return true if maximum absolute deviation of M from identity is &lt;= tol. </p>

<p>References <a class="el" href="bignum_8h_source.html#l00392">VNL::Abs()</a>, <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, and <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>.</p>

</div>
</div>
<a class="anchor" id="af41eb3b97b367b64bbba36bab9ec2c74"></a><!-- doxytag: member="VNL::MatrixFixed::IsIdentity" ref="af41eb3b97b367b64bbba36bab9ec2c74" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::IsIdentity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if all elements equal to identity. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, and <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>.</p>

</div>
</div>
<a class="anchor" id="a56aa9ceb181a20c7f039dece5007d72a"></a><!-- doxytag: member="VNL::MatrixFixed::IsZero" ref="a56aa9ceb181a20c7f039dece5007d72a" args="(double tol) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::IsZero </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if all elements equal to zero, within given tolerance. </p>
<p>Return true if max(abs((*this))) &lt;= tol. </p>

<p>References <a class="el" href="bignum_8h_source.html#l00392">VNL::Abs()</a>, <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, and <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>.</p>

</div>
</div>
<a class="anchor" id="a18897a2283edbe81f212be1e436956c0"></a><!-- doxytag: member="VNL::MatrixFixed::IsZero" ref="a18897a2283edbe81f212be1e436956c0" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::IsZero </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if all elements equal to zero. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, and <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>.</p>

</div>
</div>
<a class="anchor" id="a1493fd44296bcfbc4773f538283245af"></a><!-- doxytag: member="VNL::MatrixFixed::MaxValue" ref="a1493fd44296bcfbc4773f538283245af" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::MaxValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return maximum value of elements. </p>

<p>Referenced by <a class="el" href="matrix_8h_source.html#l00485">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::MaxValue()</a>, and <a class="el" href="realnpolynomial_8cpp_source.html#l00096">VNL::RealNPolynomial::Set()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f33a276b125d6cfa7d9fd8e4a1e6d8a"></a><!-- doxytag: member="VNL::MatrixFixed::Mean" ref="a9f33a276b125d6cfa7d9fd8e4a1e6d8a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Mean </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return mean of all matrix elements. </p>

<p>Referenced by <a class="el" href="matops_8cpp_source.html#l00081">vnl_matops::homg_diff()</a>, and <a class="el" href="matrix_8h_source.html#l00489">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::Mean()</a>.</p>

</div>
</div>
<a class="anchor" id="ac5ab77cee1837ed306d744934c5d13df"></a><!-- doxytag: member="VNL::MatrixFixed::MinValue" ref="ac5ab77cee1837ed306d744934c5d13df" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::MinValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return minimum value of elements. </p>

<p>Referenced by <a class="el" href="matrix_8h_source.html#l00481">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::MinValue()</a>.</p>

</div>
</div>
<a class="anchor" id="acdb264e08aaa86e5ad6a992299510700"></a><!-- doxytag: member="VNL::MatrixFixed::NormalizeColumns" ref="acdb264e08aaa86e5ad6a992299510700" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::NormalizeColumns </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize each column so it is a unit vector. </p>
<p>Make each column of the matrix have unit norm.</p>
<p>Zero columns are ignored</p>
<p>All-zero columns are ignored. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, <a class="el" href="bignum_8h_source.html#l00386">std::sqrt()</a>, and <a class="el" href="bignum_8h_source.html#l00393">VNL::SquaredMagnitude()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9d7c8321f1342c39e804de6656c5204"></a><!-- doxytag: member="VNL::MatrixFixed::NormalizeRows" ref="aa9d7c8321f1342c39e804de6656c5204" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::NormalizeRows </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize each row so it is a unit vector. </p>
<p>Make each row of the matrix have unit norm.</p>
<p>Zero rows are ignored</p>
<p>All-zero rows are ignored. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, <a class="el" href="bignum_8h_source.html#l00386">std::sqrt()</a>, and <a class="el" href="bignum_8h_source.html#l00393">VNL::SquaredMagnitude()</a>.</p>

</div>
</div>
<a class="anchor" id="a78669d703385e313e0ad6a501028477d"></a><!-- doxytag: member="VNL::MatrixFixed::operator!=" ref="a78669d703385e313e0ad6a501028477d" args="(Matrix&lt; T &gt; const &amp;that) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inequality operator. </p>

</div>
</div>
<a class="anchor" id="a51ae5629bc2b2d798d794df622e74b39"></a><!-- doxytag: member="VNL::MatrixFixed::operator()" ref="a51ae5629bc2b2d798d794df622e74b39" args="(unsigned r, unsigned c) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T const&amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access an element for reading. </p>
<p>There are assert style boundary checks - define NDEBUG to turn them off. </p>

</div>
</div>
<a class="anchor" id="aa0d12208d46190033757830a17aa0046"></a><!-- doxytag: member="VNL::MatrixFixed::operator()" ref="aa0d12208d46190033757830a17aa0046" args="(unsigned r, unsigned c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access an element for reading or writing. </p>
<p>There are assert style boundary checks - define NDEBUG to turn them off. </p>

</div>
</div>
<a class="anchor" id="ac3f61ef87d7084a78510d8c2aedf78d3"></a><!-- doxytag: member="VNL::MatrixFixed::operator*" ref="ac3f61ef87d7084a78510d8c2aedf78d3" args="(Matrix&lt; T &gt; const &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt;T&gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> multiply lhs by rhs matrix and return result in new matrix. </p>

</div>
</div>
<a class="anchor" id="a609fc3a2ffb60df4c1128df41c5ea101"></a><!-- doxytag: member="VNL::MatrixFixed::operator*" ref="a609fc3a2ffb60df4c1128df41c5ea101" args="(T const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt;T&gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar multiplication of lhs matrix by rhs and return result in new matrix. </p>

</div>
</div>
<a class="anchor" id="ab72f951f10015a1c640473f453b81a8f"></a><!-- doxytag: member="VNL::MatrixFixed::operator*=" ref="ab72f951f10015a1c640473f453b81a8f" args="(Matrix&lt; T &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt;T&gt;&amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply lhs matrix in situ by rhs. </p>

</div>
</div>
<a class="anchor" id="aa25de30c7bec38b9e7d4d68897a16c9f"></a><!-- doxytag: member="VNL::MatrixFixed::operator*=" ref="aa25de30c7bec38b9e7d4d68897a16c9f" args="(T value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar multiplication in situ of lhs matrix by rhs. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00633">VNL::Matrix&lt; T &gt;::num_rows</a>.</p>

</div>
</div>
<a class="anchor" id="a6d7e026a1d1ffa09b127931b1ba61fd7"></a><!-- doxytag: member="VNL::MatrixFixed::operator+" ref="a6d7e026a1d1ffa09b127931b1ba61fd7" args="(Matrix&lt; T &gt; const &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt;T&gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> add rhs to lhs matrix and return result in new matrix. </p>

</div>
</div>
<a class="anchor" id="ac61fc52d0ff23284bc7cf80e92ed745c"></a><!-- doxytag: member="VNL::MatrixFixed::operator+" ref="ac61fc52d0ff23284bc7cf80e92ed745c" args="(T const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt;T&gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add rhs to each element of lhs matrix and return result in new matrix. </p>

</div>
</div>
<a class="anchor" id="a1477b046be621c17db6ab42ff3d352b3"></a><!-- doxytag: member="VNL::MatrixFixed::operator+=" ref="a1477b046be621c17db6ab42ff3d352b3" args="(Matrix&lt; T &gt; const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add rhs to lhs matrix in situ. </p>
<p>Adds lhs matrix with rhs matrix, and stores in place in lhs matrix.</p>
<p>O(m*n). The dimensions of the two matrices must be identical. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00074">VNL::ErrorMatrixDimension()</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00633">VNL::Matrix&lt; T &gt;::num_rows</a>.</p>

</div>
</div>
<a class="anchor" id="a0911f03689d46fa04ea2d39732fbb279"></a><!-- doxytag: member="VNL::MatrixFixed::operator+=" ref="a0911f03689d46fa04ea2d39732fbb279" args="(T value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add rhs to each element of lhs matrix in situ. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00633">VNL::Matrix&lt; T &gt;::num_rows</a>.</p>

</div>
</div>
<a class="anchor" id="a8abcfc4fbc2c1e740f33205fee765d0f"></a><!-- doxytag: member="VNL::MatrixFixed::operator&#45;" ref="a8abcfc4fbc2c1e740f33205fee765d0f" args="(Matrix&lt; T &gt; const &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt;T&gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> subtract rhs from lhs and return result in new matrix. </p>

</div>
</div>
<a class="anchor" id="a8b4d5a955e42f3fb3c54c499006ba9b8"></a><!-- doxytag: member="VNL::MatrixFixed::operator&#45;" ref="a8b4d5a955e42f3fb3c54c499006ba9b8" args="(T const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt;T&gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract rhs from each element of lhs matrix and return result in new matrix. </p>

</div>
</div>
<a class="anchor" id="ab871cf6a47e22652615c6f48461df4e8"></a><!-- doxytag: member="VNL::MatrixFixed::operator&#45;" ref="ab871cf6a47e22652615c6f48461df4e8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Negate all elements of matrix. </p>
<p>Returns new matrix which is the negation of THIS matrix.</p>
<p>O(m*n). </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, and <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>.</p>

</div>
</div>
<a class="anchor" id="a08d9aa32756c09656774d0e1524d96e2"></a><!-- doxytag: member="VNL::MatrixFixed::operator&#45;=" ref="a08d9aa32756c09656774d0e1524d96e2" args="(Matrix&lt; T &gt; const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract rhs from lhs matrix in situ. </p>
<p>Substract lhs matrix with rhs matrix and store in place in lhs matrix.</p>
<p>O(m*n). The dimensions of the two matrices must be identical. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00074">VNL::ErrorMatrixDimension()</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00633">VNL::Matrix&lt; T &gt;::num_rows</a>.</p>

</div>
</div>
<a class="anchor" id="aa3cbbc42d832538eba3923c822270a37"></a><!-- doxytag: member="VNL::MatrixFixed::operator&#45;=" ref="aa3cbbc42d832538eba3923c822270a37" args="(T value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract rhs from each element of lhs matrix in situ. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00633">VNL::Matrix&lt; T &gt;::num_rows</a>.</p>

</div>
</div>
<a class="anchor" id="a97bdea276efcc84a7556429f07061d9b"></a><!-- doxytag: member="VNL::MatrixFixed::operator/" ref="a97bdea276efcc84a7556429f07061d9b" args="(T const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt;T&gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar division of lhs matrix by rhs and return result in new matrix. </p>

</div>
</div>
<a class="anchor" id="a829bdb4502e89901e406ec8d9f2c3575"></a><!-- doxytag: member="VNL::MatrixFixed::operator/=" ref="a829bdb4502e89901e406ec8d9f2c3575" args="(T value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar division of lhs matrix in situ by rhs. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00633">VNL::Matrix&lt; T &gt;::num_rows</a>.</p>

</div>
</div>
<a class="anchor" id="a00edcf61e4d37c8dbd071a5f00568130"></a><!-- doxytag: member="VNL::MatrixFixed::operator=" ref="a00edcf61e4d37c8dbd071a5f00568130" args="(const MatrixFixed&lt; m, n, T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int m, int n, class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1MatrixFixed.html">MatrixFixed</a>&lt;m,n,T&gt;&amp; <a class="el" href="classVNL_1_1MatrixFixed.html">VNL::MatrixFixed</a>&lt; m, n, T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVNL_1_1MatrixFixed.html">MatrixFixed</a>&lt; m, n, T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy another MatrixFixed&lt;m,n,T&gt; into this. </p>

<p>Reimplemented from <a class="el" href="classVNL_1_1Matrix.html#a8ecd4ea408d9d9a631e9cc4b4f90f4b7">VNL::Matrix&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8509d9bdb02076c2adf3b3814f44c048"></a><!-- doxytag: member="VNL::MatrixFixed::operator=" ref="a8509d9bdb02076c2adf3b3814f44c048" args="(const Matrix&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int m, int n, class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1MatrixFixed.html">MatrixFixed</a>&lt;m,n,T&gt;&amp; <a class="el" href="classVNL_1_1MatrixFixed.html">VNL::MatrixFixed</a>&lt; m, n, T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a vnl_matrix into this. </p>
<p>Abort if rhs is not the same size. </p>

<p>Reimplemented from <a class="el" href="classVNL_1_1MatrixFixedRef.html#ad82cf99f5afe4bb3ee414adf83a46576">VNL::MatrixFixedRef&lt; m, n, T &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classVW_1_1EssentialMatrix.html#aa0c797791e99b2feff8e43f43477b05b">VW::EssentialMatrix</a>, <a class="el" href="classVW_1_1FMatrix.html#a3d5d505875dec44377365beee82cda16">VW::FMatrix</a>, <a class="el" href="classVW_1_1FMatrixCovariance.html#a36c1ebd02780b19a75c29b6e8b0aab85">VW::FMatrixCovariance</a>, <a class="el" href="classVW_1_1FMatrixAffineCovariance.html#a27c941bf6cb9dcd01c0352063f763148">VW::FMatrixAffineCovariance</a>, <a class="el" href="classVW_1_1Homography2DCovariance.html#ab184eacbfe41068e70a3ed8c8bd7d0ed">VW::Homography2DCovariance</a>, and <a class="el" href="classVW_1_1ProjectionMatrix.html#a9280826a5297a53d1fffd9010a16d3c8">VW::ProjectionMatrix</a>.</p>

</div>
</div>
<a class="anchor" id="a0cdbeca4b99a73ba13e618e352c58493"></a><!-- doxytag: member="VNL::MatrixFixed::operator==" ref="a0cdbeca4b99a73ba13e618e352c58493" args="(Matrix&lt; T &gt; const &amp;that) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equality operator. </p>

</div>
</div>
<a class="anchor" id="adf099168a9c6309e99f1ae786990def8"></a><!-- doxytag: member="VNL::MatrixFixed::operator[]" ref="adf099168a9c6309e99f1ae786990def8" args="(unsigned r) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T const* <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>r</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return pointer to given row. </p>
<p>No boundary checking here. </p>

</div>
</div>
<a class="anchor" id="acfbe7f98f9bd824ff8d642ace7395f6e"></a><!-- doxytag: member="VNL::MatrixFixed::operator[]" ref="acfbe7f98f9bd824ff8d642ace7395f6e" args="(unsigned r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>r</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return pointer to given row. </p>
<p>No boundary checking here. </p>

</div>
</div>
<a class="anchor" id="a3bd270c6cbcfb5fe7e1ea9cb28672dc6"></a><!-- doxytag: member="VNL::MatrixFixed::operator_eq" ref="a3bd270c6cbcfb5fe7e1ea9cb28672dc6" args="(Matrix&lt; T &gt; const &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operator_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if *this == rhs. </p>
<p>Two matrices are equal if and only if they have the same dimensions and the same values.</p>
<p>O(m*n). Elements are compared with operator== as default. Change this default with set_compare() at run time or by specializing Matrix_compare at compile time. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00633">VNL::Matrix&lt; T &gt;::num_rows</a>.</p>

<p>Referenced by <a class="el" href="matrix_8h_source.html#l00615">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::operator!=()</a>, and <a class="el" href="matrix_8h_source.html#l00611">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="a0eae6d0de0a9e4b15f33905325f7df52"></a><!-- doxytag: member="VNL::MatrixFixed::operatorInfNorm" ref="a0eae6d0de0a9e4b15f33905325f7df52" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operatorInfNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="bignum_8h_source.html#l00392">VNL::Abs()</a>, <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="f2c_8h_source.html#l00157">max</a>, and <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>.</p>

<p>Referenced by <a class="el" href="matrixexp_8tpp_source.html#l00014">VNL::MatrixExp()</a>.</p>

</div>
</div>
<a class="anchor" id="a3307db07670668e0e713d1ae139a9cae"></a><!-- doxytag: member="VNL::MatrixFixed::operatorOneNorm" ref="a3307db07670668e0e713d1ae139a9cae" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::operatorOneNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="bignum_8h_source.html#l00392">VNL::Abs()</a>, <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="f2c_8h_source.html#l00157">max</a>, and <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>.</p>

</div>
</div>
<a class="anchor" id="aebbe2d0d79a10b0732d1ad7261cb10bb"></a><!-- doxytag: member="VNL::MatrixFixed::print" ref="aebbe2d0d79a10b0732d1ad7261cb10bb" args="(std::ostream &amp;os) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print matrix to os in some hopefully sensible format. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, and <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>.</p>

</div>
</div>
<a class="anchor" id="a4b3228f51e4a445a651a529f49aaeb9d"></a><!-- doxytag: member="VNL::MatrixFixed::Put" ref="a4b3228f51e4a445a651a529f49aaeb9d" args="(unsigned r, unsigned c, T const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Put </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>set element with boundary checks if error checking is on. </p>
<p>put -- Puts value into element at specified row and column. O(1).</p>
<p>Checks for valid range of indices. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00633">VNL::Matrix&lt; T &gt;::num_rows</a>.</p>

</div>
</div>
<a class="anchor" id="a1dc673309070ddaffc84a8985ee939f0"></a><!-- doxytag: member="VNL::MatrixFixed::Read" ref="a1dc673309070ddaffc84a8985ee939f0" args="(std::istream &amp;s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> from an ascii std::istream. </p>
<p>Automatically determines file size if the input matrix has zero size. This is a static method so you can type &lt;verb&gt; <a class="el" href="classVNL_1_1Matrix.html">Matrix&lt;float&gt;</a> M = Matrix&lt;float&gt;::read(cin); &lt;/verb&gt; which many people prefer to the "&gt;&gt;" alternative. </p>

</div>
</div>
<a class="anchor" id="a7a6980b7a9f7dc98cff9989874a315d9"></a><!-- doxytag: member="VNL::MatrixFixed::ReadASCII" ref="a7a6980b7a9f7dc98cff9989874a315d9" args="(std::istream &amp;s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::ReadASCII </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> from an ascii std::istream. </p>
<p>Automatically determines file size if the input matrix has zero size. </p>

<p>References <a class="el" href="qr_8tpp.html#aafc737ea9ef91f59cf9acd287fb8d085">c</a>, <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8tpp_source.html#l00364">VNL::Matrix&lt; T &gt;::Resize()</a>, and <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>.</p>

<p>Referenced by <a class="el" href="filematrix_8tpp_source.html#l00021">VNL::FileMatrix&lt; T &gt;::FileMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="ad3221c841512da857742c2cdc8cb53f0"></a><!-- doxytag: member="VNL::MatrixFixed::Resize" ref="ad3221c841512da857742c2cdc8cb53f0" args="(unsigned r, unsigned c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Resize </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize to r rows by c columns. Old data lost. </p>
<p>returns true if size changed. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, <a class="el" href="matrix_8h_source.html#l00633">VNL::Matrix&lt; T &gt;::num_rows</a>, <a class="el" href="matrix_8tpp_source.html#l00100">vnl_matrix_alloc_blah</a>, and <a class="el" href="matrix_8tpp_source.html#l00120">vnl_matrix_free_blah</a>.</p>

<p>Referenced by <a class="el" href="binary_8cpp_source.html#l00065">VNL::BinaryLoad()</a>, <a class="el" href="matrix_8tpp_source.html#l00425">VNL::Matrix&lt; T &gt;::operator=()</a>, and <a class="el" href="matrix_8tpp_source.html#l01221">VNL::Matrix&lt; T &gt;::ReadASCII()</a>.</p>

</div>
</div>
<a class="anchor" id="af080a0023d9f6630e4585d8b383b8710"></a><!-- doxytag: member="VNL::MatrixFixed::resize" ref="af080a0023d9f6630e4585d8b383b8710" args="(unsigned int, unsigned int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int m, int n, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1MatrixFixedRef.html">VNL::MatrixFixedRef</a>&lt; m, n, T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>int</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resizing a vnl_matrix_ref fails. </p>

<p>Referenced by <a class="el" href="essentialmatrixcomputepreemptive_8cpp_source.html#l00066">VW::EssentialMatrixComputePreemptive::Compute()</a>.</p>

</div>
</div>
<a class="anchor" id="a35ae0df75f8e397bd6a9100fcf677c26"></a><!-- doxytag: member="VNL::MatrixFixed::RMS" ref="a35ae0df75f8e397bd6a9100fcf677c26" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::RMS </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return RMS of all elements. </p>

</div>
</div>
<a class="anchor" id="aff5c94adfdf10c50c421097ae55c055e"></a><!-- doxytag: member="VNL::MatrixFixed::Rows" ref="aff5c94adfdf10c50c421097ae55c055e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Rows </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return number of rows. </p>

<p>Referenced by <a class="el" href="fastops_8cpp_source.html#l00062">vnl_fastops::AB()</a>, <a class="el" href="fastops_8cpp_source.html#l00162">vnl_fastops::ABt()</a>, <a class="el" href="adjugate_8tpp_source.html#l00018">VNL::Adjugate()</a>, <a class="el" href="matrix_8tpp_source.html#l01180">VNL::Matrix&lt; T &gt;::assert_finite_internal()</a>, <a class="el" href="matrix_8tpp_source.html#l01208">VNL::Matrix&lt; T &gt;::assert_size_internal()</a>, <a class="el" href="fastops_8cpp_source.html#l00020">vnl_fastops::AtA()</a>, <a class="el" href="fastops_8cpp_source.html#l00096">vnl_fastops::AtB()</a>, <a class="el" href="binary_8cpp_source.html#l00052">VNL::BinarySave()</a>, <a class="el" href="matops_8cpp_source.html#l00019">vnl_matops::cat()</a>, <a class="el" href="cholesky_8tpp_source.html#l00051">VNL::Cholesky&lt; T &gt;::Cholesky()</a>, <a class="el" href="fastops_8cpp_source.html#l00363">vnl_fastops::dec_X_by_ABt()</a>, <a class="el" href="fastops_8cpp_source.html#l00304">vnl_fastops::dec_X_by_AtB()</a>, <a class="el" href="determinant_8tpp_source.html#l00060">VNL::Determinant()</a>, <a class="el" href="leastsquaresfunction_8cpp_source.html#l00075">VNL::LeastSquaresFunction::FDGradF()</a>, <a class="el" href="matrix_8tpp_source.html#l01376">VNL::Matrix&lt; T &gt;::FlipLR()</a>, <a class="el" href="matrix_8tpp_source.html#l01357">VNL::Matrix&lt; T &gt;::FlipUD()</a>, <a class="el" href="generalizedschur_8h_source.html#l00047">VNL::GeneralizedSchur()</a>, <a class="el" href="essentialmatrixcompute5point_8cpp_source.html#l00187">GetRowEchelonForm()</a>, <a class="el" href="leastsquarescostfunction_8cpp_source.html#l00030">VNL::LeastSquaresCostFunction::GradF()</a>, <a class="el" href="matrix_8tpp_source.html#l01154">VNL::Matrix&lt; T &gt;::HasNaNs()</a>, <a class="el" href="fastops_8cpp_source.html#l00196">vnl_fastops::inc_X_by_AtA()</a>, <a class="el" href="fastops_8cpp_source.html#l00235">vnl_fastops::inc_X_by_AtB()</a>, <a class="el" href="matrix_8tpp_source.html#l01549">VNL::Matrix&lt; T &gt;::InplaceTranspose()</a>, <a class="el" href="matrix_8tpp_source.html#l01167">VNL::Matrix&lt; T &gt;::IsFinite()</a>, <a class="el" href="matrix_8tpp_source.html#l01097">VNL::Matrix&lt; T &gt;::IsIdentity()</a>, <a class="el" href="matrix_8tpp_source.html#l01127">VNL::Matrix&lt; T &gt;::IsZero()</a>, <a class="el" href="matlabprint_8tpp_source.html#l00075">VNL::MatlabPrint()</a>, <a class="el" href="matlabread_8cpp_source.html#l00209">VNL::MatlabReadOrDie()</a>, <a class="el" href="matrixexp_8tpp_source.html#l00014">VNL::MatrixExp()</a>, <a class="el" href="matrixfixed_8h_source.html#l00065">VNL::MatrixFixed&lt; 9, 9, double &gt;::MatrixFixed()</a>, <a class="el" href="matrix_8h_source.html#l00201">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::operator()()</a>, <a class="el" href="diagmatrix_8h_source.html#l00190">VNL::operator*()</a>, <a class="el" href="projectionmatrix_8h_source.html#l00152">VW::ProjectionMatrix::operator=()</a>, <a class="el" href="matrixfixedref_8h_source.html#l00096">VNL::MatrixFixedRef&lt; m, n, float &gt;::operator=()</a>, <a class="el" href="matrixfixed_8h_source.html#l00079">VNL::MatrixFixed&lt; 9, 9, double &gt;::operator=()</a>, <a class="el" href="homography2d_8h_source.html#l00299">VW::Homography2DCovariance::operator=()</a>, <a class="el" href="homography2d_8h_source.html#l00267">VW::Homography2D::operator=()</a>, <a class="el" href="fmatrixaffine_8h_source.html#l00305">VW::FMatrixAffineCovariance::operator=()</a>, <a class="el" href="fmatrixaffine_8h_source.html#l00168">VW::FMatrixAffine::operator=()</a>, <a class="el" href="fmatrix_8h_source.html#l00257">VW::FMatrixCovariance::operator=()</a>, <a class="el" href="fmatrix_8h_source.html#l00165">VW::FMatrix::operator=()</a>, <a class="el" href="essentialmatrix_8h_source.html#l00107">VW::EssentialMatrix::operator=()</a>, <a class="el" href="symmatrix_8tpp_source.html#l00112">operator==()</a>, <a class="el" href="vector_8tpp_source.html#l00494">VNL::Vector&lt; T &gt;::PostMultiply()</a>, <a class="el" href="vector_8tpp_source.html#l00470">VNL::Vector&lt; T &gt;::PreMultiply()</a>, <a class="el" href="matrix_8tpp_source.html#l00442">VNL::Matrix&lt; T &gt;::print()</a>, <a class="el" href="projectionmatrix_8h_source.html#l00108">VW::ProjectionMatrix::ProjectionMatrix()</a>, <a class="el" href="qr_8tpp_source.html#l00040">VNL::QR&lt; T &gt;::QR()</a>, <a class="el" href="matrix_8tpp_source.html#l01221">VNL::Matrix&lt; T &gt;::ReadASCII()</a>, <a class="el" href="realeigensystem_8cpp_source.html#l00023">VNL::RealEigensystem::RealEigensystem()</a>, <a class="el" href="realnpolynomial_8cpp_source.html#l00036">VNL::RealNPolynomial::RealNPolynomial()</a>, <a class="el" href="realnpolynomial_8cpp_source.html#l00096">VNL::RealNPolynomial::Set()</a>, <a class="el" href="matrix_8h_source.html#l00178">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::size()</a>, <a class="el" href="matrix_8h_source.html#l00173">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::Size()</a>, <a class="el" href="svd_8tpp_source.html#l00301">VNL::SVD&lt; T &gt;::Solve()</a>, <a class="el" href="svd_8tpp_source.html#l00042">VNL::SVD&lt; T &gt;::SVD()</a>, <a class="el" href="symmetriceigensystem_8cpp_source.html#l00020">VNL::SymmetricEigensystemCompute()</a>, <a class="el" href="trace_8cpp_source.html#l00015">VNL::Trace()</a>, <a class="el" href="matops_8cpp_source.html#l00062">vnl_matops::vcat()</a>, <a class="el" href="vector_8tpp_source.html#l00234">VNL::Vector&lt; T &gt;::Vector()</a>, <a class="el" href="complexops_8tpp_source.html#l00048">vnl_complexify()</a>, <a class="el" href="discretediff_8cpp_source.html#l00034">vnl_discrete_diff_fwd()</a>, <a class="el" href="discretediff_8cpp_source.html#l00072">vnl_discrete_diff_sym()</a>, <a class="el" href="fortrancopy_8tpp_source.html#l00015">vnl_fortran_copy&lt; T &gt;::vnl_fortran_copy()</a>, and <a class="el" href="matlabfilewrite_8cpp_source.html#l00060">VNL::MatlabFilewrite::Write()</a>.</p>

</div>
</div>
<a class="anchor" id="ae87be7fafd426f9ee5f7567663c79078"></a><!-- doxytag: member="VNL::MatrixFixed::ScaleColumn" ref="ae87be7fafd426f9ee5f7567663c79078" args="(unsigned col, T value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::ScaleColumn </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scale elements in given column by a factor of T. </p>
<p>Multiply column[column_index] by value. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00065">VNL::ErrorMatrixColIndex()</a>, and <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>.</p>

<p>Referenced by <a class="el" href="determinant_8tpp_source.html#l00060">VNL::Determinant()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e9f7b2c295c2b992efc0a94bf4808f2"></a><!-- doxytag: member="VNL::MatrixFixed::ScaleRow" ref="a4e9f7b2c295c2b992efc0a94bf4808f2" args="(unsigned row, T value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::ScaleRow </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scale elements in given row by a factor of T. </p>
<p>Multiply row[row_index] by value. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00055">VNL::ErrorMatrixRowIndex()</a>, and <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>.</p>

<p>Referenced by <a class="el" href="determinant_8tpp_source.html#l00060">VNL::Determinant()</a>.</p>

</div>
</div>
<a class="anchor" id="aa211aa5409bc801d0fed44d65c25dd20"></a><!-- doxytag: member="VNL::MatrixFixed::Set" ref="aa211aa5409bc801d0fed44d65c25dd20" args="(T const *d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Set </td>
          <td>(</td>
          <td class="paramtype">T const *&nbsp;</td>
          <td class="paramname"> <em>d</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill (laminate) this matrix with the given data. </p>
<p>A synonym for copy_in() </p>

<p>Reimplemented in <a class="el" href="classVNL_1_1CrossProductMatrix.html#adc9640022a96ac8672eaf771561a8f16">VNL::CrossProductMatrix&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3709e2eaea0b9eb4197c2f3b72167ba3"></a><!-- doxytag: member="VNL::MatrixFixed::SetColumn" ref="a3709e2eaea0b9eb4197c2f3b72167ba3" args="(unsigned j, Vector&lt; T &gt; const &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::SetColumn </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set j-th colum to v. </p>
<p>Set column[column_index] to given vector. No bounds check. </p>

<p>References <a class="el" href="vector_8h_source.html#l00275">VNL::Vector&lt; T &gt;::DataBlock()</a>, and <a class="el" href="matrix_8tpp_source.html#l01029">VNL::Matrix&lt; T &gt;::SetColumn()</a>.</p>

</div>
</div>
<a class="anchor" id="ac8b884756ccd26369f114543b2f9e066"></a><!-- doxytag: member="VNL::MatrixFixed::SetColumn" ref="ac8b884756ccd26369f114543b2f9e066" args="(unsigned i, T value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::SetColumn </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the elements of the i'th column to value. </p>
<p>Set column[column_index] to given value. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>.</p>

</div>
</div>
<a class="anchor" id="af37d6c7e5f69eeb882d0485d2a1fff7c"></a><!-- doxytag: member="VNL::MatrixFixed::SetColumn" ref="af37d6c7e5f69eeb882d0485d2a1fff7c" args="(unsigned i, T const *v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::SetColumn </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the elements of the i'th column to v[j] (No bounds checking). </p>
<p>Set column[column_index] to data at given address. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>.</p>

<p>Referenced by <a class="el" href="vectorfixed_8h_source.html#l00186">VNL::VectorFixed&lt; 3, T &gt;::AsColumn()</a>, <a class="el" href="matops_8cpp_source.html#l00034">vnl_matops::cat()</a>, and <a class="el" href="matrix_8tpp_source.html#l01038">VNL::Matrix&lt; T &gt;::SetColumn()</a>.</p>

</div>
</div>
<a class="anchor" id="aa008e53c4cff6449118e28d8308959f7"></a><!-- doxytag: member="VNL::MatrixFixed::SetColumns" ref="aa008e53c4cff6449118e28d8308959f7" args="(unsigned starting_column, Matrix&lt; T &gt; const &amp;M)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::SetColumns </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>starting_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set columns to those in M, starting at starting_column. </p>
<p>Set columns starting at starting_column to given matrix. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00074">VNL::ErrorMatrixDimension()</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00633">VNL::Matrix&lt; T &gt;::num_rows</a>.</p>

</div>
</div>
<a class="anchor" id="a75233a9e40259eac0bb7e1f0cf849cf9"></a><!-- doxytag: member="VNL::MatrixFixed::SetIdentity" ref="a75233a9e40259eac0bb7e1f0cf849cf9" args="(T val=T(1))" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::SetIdentity </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>val</em> = <code>T(1)</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this matrix to an identity (or diagonal) matrix. </p>
<p>Fill this matrix with a row*row identity matrix.</p>
<p>Abort if the matrix is not square </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00084">VNL::ErrorMatrixNonSquare()</a>, and <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>.</p>

<p>Referenced by <a class="el" href="matrixexp_8tpp_source.html#l00014">VNL::MatrixExp()</a>, and <a class="el" href="warp_8h_source.html#l00113">VW::Warp::Warp()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cea699795ff2ee5ecf6aa633c49422f"></a><!-- doxytag: member="VNL::MatrixFixed::SetRow" ref="a0cea699795ff2ee5ecf6aa633c49422f" args="(unsigned i, Vector&lt; T &gt; const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::SetRow </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the i-th row. </p>
<p>Set row[row_index] to given vector. No bounds check. </p>

<p>References <a class="el" href="vector_8h_source.html#l00275">VNL::Vector&lt; T &gt;::DataBlock()</a>, and <a class="el" href="matrix_8tpp_source.html#l01001">VNL::Matrix&lt; T &gt;::SetRow()</a>.</p>

</div>
</div>
<a class="anchor" id="ac8b55c00bcb24d7fcf2d68de80c0214e"></a><!-- doxytag: member="VNL::MatrixFixed::SetRow" ref="ac8b55c00bcb24d7fcf2d68de80c0214e" args="(unsigned i, T value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::SetRow </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the elements of the i'th row to value. </p>
<p>Set row[row_index] to given value. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, and <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>.</p>

</div>
</div>
<a class="anchor" id="af707998ccb85f8d61b95480a28176de5"></a><!-- doxytag: member="VNL::MatrixFixed::SetRow" ref="af707998ccb85f8d61b95480a28176de5" args="(unsigned i, T const *v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::SetRow </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the elements of the i'th row to v[j] (No bounds checking). </p>
<p>Set row[row_index] to data at given address. No bounds check. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, and <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>.</p>

<p>Referenced by <a class="el" href="vectorfixed_8h_source.html#l00178">VNL::VectorFixed&lt; 3, T &gt;::AsRow()</a>, <a class="el" href="essentialmatrixcompute5point_8cpp_source.html#l00187">GetRowEchelonForm()</a>, <a class="el" href="matrix_8tpp_source.html#l01010">VNL::Matrix&lt; T &gt;::SetRow()</a>, and <a class="el" href="orthogonalcomplement_8tpp_source.html#l00011">vnl_orthogonal_complement()</a>.</p>

</div>
</div>
<a class="anchor" id="a38883927f7b47ec3f8c7e88e41f6ebdd"></a><!-- doxytag: member="VNL::MatrixFixed::size" ref="a38883927f7b47ec3f8c7e88e41f6ebdd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return number of elements. </p>
<p>This equals rows() * cols() </p>

<p>Referenced by <a class="el" href="matrix_8h_source.html#l00451">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::ArrayInfNorm()</a>, <a class="el" href="matrix_8h_source.html#l00443">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::ArrayOneNorm()</a>, <a class="el" href="matrix_8h_source.html#l00447">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::ArrayTwoNorm()</a>, <a class="el" href="binary_8cpp_source.html#l00065">VNL::BinaryLoad()</a>, <a class="el" href="binary_8cpp_source.html#l00052">VNL::BinarySave()</a>, <a class="el" href="complexeigensystem_8cpp_source.html#l00102">VNL::ComplexEigensystem::ComplexEigensystem()</a>, <a class="el" href="matrix_8tpp_source.html#l00682">VNL::Matrix&lt; T &gt;::ConjugateTranspose()</a>, <a class="el" href="computefuncs_8h_source.html#l00034">VW::ComputeFuncs::ConvertParamVectorToTransform()</a>, <a class="el" href="computefuncs_8h_source.html#l00017">VW::ComputeFuncs::ConvertTransformToParamVector()</a>, <a class="el" href="matrix_8h_source.html#l00469">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::FrobeniusNorm()</a>, <a class="el" href="generalizedschur_8h_source.html#l00047">VNL::GeneralizedSchur()</a>, <a class="el" href="matrix_8h_source.html#l00485">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::MaxValue()</a>, <a class="el" href="matrix_8h_source.html#l00489">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::Mean()</a>, <a class="el" href="matrix_8h_source.html#l00481">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::MinValue()</a>, <a class="el" href="matrix_8h_source.html#l00477">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::RMS()</a>, and <a class="el" href="complexops_8tpp_source.html#l00048">vnl_complexify()</a>.</p>

</div>
</div>
<a class="anchor" id="acc663489b8784632af9b648a67d7740b"></a><!-- doxytag: member="VNL::MatrixFixed::Size" ref="acc663489b8784632af9b648a67d7740b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return number of elements. </p>
<p>This equals rows() * cols() </p>

</div>
</div>
<a class="anchor" id="a2f3c40b3a1e7f2b09cc567f820f36849"></a><!-- doxytag: member="VNL::MatrixFixed::Swap" ref="a2f3c40b3a1e7f2b09cc567f820f36849" args="(Matrix&lt; T &gt; &amp;that)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap this matrix with that matrix. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00633">VNL::Matrix&lt; T &gt;::num_rows</a>.</p>

<p>Referenced by <a class="el" href="matrix_8h_source.html#l00716">VNL::Swap()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c5d1b0934192972fa6c77c8aa0f4c04"></a><!-- doxytag: member="VNL::MatrixFixed::Transpose" ref="a7c5d1b0934192972fa6c77c8aa0f4c04" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Transpose.html">Transpose</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return transpose. </p>
<p>Returns new matrix with rows and columns transposed.</p>
<p>O(m*n). </p>

<p>Reimplemented in <a class="el" href="classVW_1_1RotationMatrix.html#a50aa33fbdf3d8a4be75729dd10e26978">VW::RotationMatrix</a>.</p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, and <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>.</p>

<p>Referenced by <a class="el" href="transpose_8h_source.html#l00058">VNL::Transpose::AsMatrix()</a>, <a class="el" href="homography2dcomputelinear_8cpp_source.html#l00687">VW::Homography2DComputeLinear::Compute()</a>, <a class="el" href="fmatrixcomputemlesac_8cpp_source.html#l00372">VW::FMatrixComputeMLESAC::Compute()</a>, <a class="el" href="fmatrixcomputelinear_8cpp_source.html#l00311">VW::FMatrixComputeLinear::Compute()</a>, <a class="el" href="fmaffinecomputelinear_8cpp_source.html#l00333">VW::FMatrixAffineComputeLinear::Compute()</a>, <a class="el" href="essentialmatrixcomputemlesac_8cpp_source.html#l00237">VW::EssentialMatrixComputeMLESAC::Compute()</a>, <a class="el" href="matrix_8tpp_source.html#l00682">VNL::Matrix&lt; T &gt;::ConjugateTranspose()</a>, <a class="el" href="generalizedeigensystem_8cpp_source.html#l00023">VNL::GeneralizedEigensystem::GeneralizedEigensystem()</a>, <a class="el" href="fmatrixcomputenonlinear_8cpp_source.html#l00043">VW::FMatrixCompute::GenerateParameterVector()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00032">VW::FMPlanarCompute::GenerateParameterVectorHZ()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00224">VW::FMPlanarCompute::GenerateParameterVectorHZJK()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00118">VW::FMPlanarCompute::GenerateParameterVectorVLJK()</a>, <a class="el" href="transpose_8h_source.html#l00051">VNL::Transpose::operator Matrix&lt; double &gt;()</a>, and <a class="el" href="fmaffinecompute_8h_source.html#l00162">VW::FMatrixAffineCompute::Unnormalise()</a>.</p>

</div>
</div>
<a class="anchor" id="a16b330765547529c3dffe01a9d3220a6"></a><!-- doxytag: member="VNL::MatrixFixed::Update" ref="a16b330765547529c3dffe01a9d3220a6" args="(Matrix&lt; T &gt; const &amp;, unsigned top=0, unsigned left=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::Update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>top</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>left</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set values of this matrix to those of M, starting at [top,left]. </p>
<p>Replaces the submatrix of THIS matrix, starting at top left corner, by the elements of matrix m. O(m*n).</p>
<p>This is the reverse of extract(). </p>

<p>References <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00074">VNL::ErrorMatrixDimension()</a>, <a class="el" href="matrix_8h_source.html#l00634">VNL::Matrix&lt; T &gt;::num_cols</a>, and <a class="el" href="matrix_8h_source.html#l00633">VNL::Matrix&lt; T &gt;::num_rows</a>.</p>

<p>Referenced by <a class="el" href="matops_8cpp_source.html#l00019">vnl_matops::cat()</a>, <a class="el" href="generalizedeigensystem_8cpp_source.html#l00023">VNL::GeneralizedEigensystem::GeneralizedEigensystem()</a>, and <a class="el" href="matops_8cpp_source.html#l00062">vnl_matops::vcat()</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a394794c6c1f9a966c3b222c7ea7e177a"></a><!-- doxytag: member="VNL::MatrixFixed::data" ref="a394794c6c1f9a966c3b222c7ea7e177a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T** <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Matrix.html#a394794c6c1f9a966c3b222c7ea7e177a">data</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="matrix_8tpp_source.html#l00649">VNL::Matrix&lt; T &gt;::Apply()</a>, <a class="el" href="matrix_8h_source.html#l00588">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::begin()</a>, <a class="el" href="matrix_8tpp_source.html#l00350">VNL::Matrix&lt; T &gt;::Clear()</a>, <a class="el" href="matrix_8tpp_source.html#l00820">VNL::Matrix&lt; T &gt;::CopyIn()</a>, <a class="el" href="matrix_8tpp_source.html#l00832">VNL::Matrix&lt; T &gt;::CopyOut()</a>, <a class="el" href="matrix_8h_source.html#l00574">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::DataArray()</a>, <a class="el" href="matrix_8h_source.html#l00564">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::DataBlock()</a>, <a class="el" href="matrix_8h_source.html#l00591">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::end()</a>, <a class="el" href="matrix_8tpp_source.html#l00716">VNL::Matrix&lt; T &gt;::Extract()</a>, <a class="el" href="matrix_8tpp_source.html#l00392">VNL::Matrix&lt; T &gt;::Fill()</a>, <a class="el" href="matrix_8tpp_source.html#l00402">VNL::Matrix&lt; T &gt;::FillDiagonal()</a>, <a class="el" href="matrix_8h_source.html#l00674">VNL::Matrix&lt; T &gt;::Get()</a>, <a class="el" href="matrix_8tpp_source.html#l00983">VNL::Matrix&lt; T &gt;::GetColumn()</a>, <a class="el" href="matrix_8tpp_source.html#l00951">VNL::Matrix&lt; T &gt;::GetNColumns()</a>, <a class="el" href="matrix_8tpp_source.html#l00938">VNL::Matrix&lt; T &gt;::GetNRows()</a>, <a class="el" href="matrix_8tpp_source.html#l00967">VNL::Matrix&lt; T &gt;::GetRow()</a>, <a class="el" href="matrix_8tpp_source.html#l01549">VNL::Matrix&lt; T &gt;::InplaceTranspose()</a>, <a class="el" href="matrix_8h_source.html#l00506">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::IsEmpty()</a>, <a class="el" href="matrix_8tpp_source.html#l00146">VNL::Matrix&lt; T &gt;::Matrix()</a>, <a class="el" href="matrix_8h_source.html#l00142">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::Matrix()</a>, <a class="el" href="matrixfixedref_8h_source.html#l00076">VNL::MatrixFixedRef&lt; m, n, float &gt;::MatrixFixedRef()</a>, <a class="el" href="matrixref_8h_source.html#l00053">VNL::MatrixRef&lt; T &gt;::MatrixRef()</a>, <a class="el" href="matrix_8tpp_source.html#l00887">VNL::Matrix&lt; T &gt;::NormalizeColumns()</a>, <a class="el" href="matrix_8tpp_source.html#l00861">VNL::Matrix&lt; T &gt;::NormalizeRows()</a>, <a class="el" href="matrix_8h_source.html#l00201">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::operator()()</a>, <a class="el" href="matrix_8tpp_source.html#l00498">VNL::Matrix&lt; T &gt;::operator*=()</a>, <a class="el" href="matrix_8tpp_source.html#l00482">VNL::Matrix&lt; T &gt;::operator+=()</a>, <a class="el" href="matrix_8tpp_source.html#l00597">VNL::Matrix&lt; T &gt;::operator-()</a>, <a class="el" href="matrix_8tpp_source.html#l00490">VNL::Matrix&lt; T &gt;::operator-=()</a>, <a class="el" href="matrix_8tpp_source.html#l00506">VNL::Matrix&lt; T &gt;::operator/=()</a>, <a class="el" href="matrixfixedref_8h_source.html#l00096">VNL::MatrixFixedRef&lt; m, n, float &gt;::operator=()</a>, <a class="el" href="matrix_8tpp_source.html#l00425">VNL::Matrix&lt; T &gt;::operator=()</a>, <a class="el" href="matrix_8h_source.html#l00191">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::operator[]()</a>, <a class="el" href="matrix_8tpp_source.html#l01081">VNL::Matrix&lt; T &gt;::operator_eq()</a>, <a class="el" href="matrix_8tpp_source.html#l01413">VNL::Matrix&lt; T &gt;::operatorInfNorm()</a>, <a class="el" href="matrix_8tpp_source.html#l01396">VNL::Matrix&lt; T &gt;::operatorOneNorm()</a>, <a class="el" href="matrix_8tpp_source.html#l00442">VNL::Matrix&lt; T &gt;::print()</a>, <a class="el" href="matrix_8h_source.html#l00689">VNL::Matrix&lt; T &gt;::Put()</a>, <a class="el" href="matrix_8tpp_source.html#l01221">VNL::Matrix&lt; T &gt;::ReadASCII()</a>, <a class="el" href="matrix_8tpp_source.html#l00364">VNL::Matrix&lt; T &gt;::Resize()</a>, <a class="el" href="matrix_8tpp_source.html#l00925">VNL::Matrix&lt; T &gt;::ScaleColumn()</a>, <a class="el" href="matrix_8tpp_source.html#l00912">VNL::Matrix&lt; T &gt;::ScaleRow()</a>, <a class="el" href="matrix_8tpp_source.html#l01029">VNL::Matrix&lt; T &gt;::SetColumn()</a>, <a class="el" href="matrix_8tpp_source.html#l01056">VNL::Matrix&lt; T &gt;::SetColumns()</a>, <a class="el" href="matrix_8tpp_source.html#l00843">VNL::Matrix&lt; T &gt;::SetIdentity()</a>, <a class="el" href="matrix_8tpp_source.html#l01001">VNL::Matrix&lt; T &gt;::SetRow()</a>, <a class="el" href="matrix_8tpp_source.html#l01347">VNL::Matrix&lt; T &gt;::Swap()</a>, <a class="el" href="matrix_8tpp_source.html#l00671">VNL::Matrix&lt; T &gt;::Transpose()</a>, <a class="el" href="matrix_8tpp_source.html#l00695">VNL::Matrix&lt; T &gt;::Update()</a>, <a class="el" href="matrix_8h_source.html#l00148">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::~Matrix()</a>, <a class="el" href="matrixfixedref_8h_source.html#l00087">VNL::MatrixFixedRef&lt; m, n, float &gt;::~MatrixFixedRef()</a>, and <a class="el" href="matrixref_8h_source.html#l00060">VNL::MatrixRef&lt; T &gt;::~MatrixRef()</a>.</p>

</div>
</div>
<a class="anchor" id="af91a774473dbda01863adad84753302f"></a><!-- doxytag: member="VNL::MatrixFixed::num_cols" ref="af91a774473dbda01863adad84753302f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Matrix.html#af91a774473dbda01863adad84753302f">num_cols</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="matrix_8tpp_source.html#l00649">VNL::Matrix&lt; T &gt;::Apply()</a>, <a class="el" href="matrix_8tpp_source.html#l00350">VNL::Matrix&lt; T &gt;::Clear()</a>, <a class="el" href="matrix_8h_source.html#l00168">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::Cols()</a>, <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::Columns()</a>, <a class="el" href="matrix_8tpp_source.html#l00820">VNL::Matrix&lt; T &gt;::CopyIn()</a>, <a class="el" href="matrix_8tpp_source.html#l00832">VNL::Matrix&lt; T &gt;::CopyOut()</a>, <a class="el" href="matrix_8h_source.html#l00591">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::end()</a>, <a class="el" href="matrix_8tpp_source.html#l00716">VNL::Matrix&lt; T &gt;::Extract()</a>, <a class="el" href="matrix_8tpp_source.html#l00392">VNL::Matrix&lt; T &gt;::Fill()</a>, <a class="el" href="matrix_8tpp_source.html#l00402">VNL::Matrix&lt; T &gt;::FillDiagonal()</a>, <a class="el" href="matrix_8h_source.html#l00674">VNL::Matrix&lt; T &gt;::Get()</a>, <a class="el" href="matrix_8tpp_source.html#l00983">VNL::Matrix&lt; T &gt;::GetColumn()</a>, <a class="el" href="matrix_8tpp_source.html#l00951">VNL::Matrix&lt; T &gt;::GetNColumns()</a>, <a class="el" href="matrix_8tpp_source.html#l00938">VNL::Matrix&lt; T &gt;::GetNRows()</a>, <a class="el" href="matrix_8tpp_source.html#l00967">VNL::Matrix&lt; T &gt;::GetRow()</a>, <a class="el" href="matrix_8tpp_source.html#l01549">VNL::Matrix&lt; T &gt;::InplaceTranspose()</a>, <a class="el" href="matrix_8h_source.html#l00506">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::IsEmpty()</a>, <a class="el" href="matrix_8tpp_source.html#l00204">VNL::Matrix&lt; T &gt;::Matrix()</a>, <a class="el" href="matrix_8h_source.html#l00142">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::Matrix()</a>, <a class="el" href="matrixfixedref_8h_source.html#l00076">VNL::MatrixFixedRef&lt; m, n, float &gt;::MatrixFixedRef()</a>, <a class="el" href="matrixref_8h_source.html#l00053">VNL::MatrixRef&lt; T &gt;::MatrixRef()</a>, <a class="el" href="matrix_8tpp_source.html#l00887">VNL::Matrix&lt; T &gt;::NormalizeColumns()</a>, <a class="el" href="matrix_8tpp_source.html#l00861">VNL::Matrix&lt; T &gt;::NormalizeRows()</a>, <a class="el" href="matrix_8tpp_source.html#l00498">VNL::Matrix&lt; T &gt;::operator*=()</a>, <a class="el" href="matrix_8tpp_source.html#l00482">VNL::Matrix&lt; T &gt;::operator+=()</a>, <a class="el" href="matrix_8tpp_source.html#l00597">VNL::Matrix&lt; T &gt;::operator-()</a>, <a class="el" href="matrix_8tpp_source.html#l00490">VNL::Matrix&lt; T &gt;::operator-=()</a>, <a class="el" href="matrix_8tpp_source.html#l00506">VNL::Matrix&lt; T &gt;::operator/=()</a>, <a class="el" href="matrix_8tpp_source.html#l00425">VNL::Matrix&lt; T &gt;::operator=()</a>, <a class="el" href="matrix_8tpp_source.html#l01081">VNL::Matrix&lt; T &gt;::operator_eq()</a>, <a class="el" href="matrix_8tpp_source.html#l01413">VNL::Matrix&lt; T &gt;::operatorInfNorm()</a>, <a class="el" href="matrix_8tpp_source.html#l01396">VNL::Matrix&lt; T &gt;::operatorOneNorm()</a>, <a class="el" href="matrix_8h_source.html#l00689">VNL::Matrix&lt; T &gt;::Put()</a>, <a class="el" href="matrix_8tpp_source.html#l00364">VNL::Matrix&lt; T &gt;::Resize()</a>, <a class="el" href="matrix_8tpp_source.html#l00925">VNL::Matrix&lt; T &gt;::ScaleColumn()</a>, <a class="el" href="matrix_8tpp_source.html#l00912">VNL::Matrix&lt; T &gt;::ScaleRow()</a>, <a class="el" href="matrix_8tpp_source.html#l01056">VNL::Matrix&lt; T &gt;::SetColumns()</a>, <a class="el" href="matrix_8tpp_source.html#l00843">VNL::Matrix&lt; T &gt;::SetIdentity()</a>, <a class="el" href="matrix_8tpp_source.html#l01001">VNL::Matrix&lt; T &gt;::SetRow()</a>, <a class="el" href="matrix_8tpp_source.html#l01347">VNL::Matrix&lt; T &gt;::Swap()</a>, <a class="el" href="matrix_8tpp_source.html#l00671">VNL::Matrix&lt; T &gt;::Transpose()</a>, and <a class="el" href="matrix_8tpp_source.html#l00695">VNL::Matrix&lt; T &gt;::Update()</a>.</p>

</div>
</div>
<a class="anchor" id="a3127ff55911a8a63e45247949a7692d3"></a><!-- doxytag: member="VNL::MatrixFixed::num_rows" ref="a3127ff55911a8a63e45247949a7692d3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Matrix.html#a3127ff55911a8a63e45247949a7692d3">num_rows</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="matrix_8tpp_source.html#l00350">VNL::Matrix&lt; T &gt;::Clear()</a>, <a class="el" href="matrix_8h_source.html#l00591">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::end()</a>, <a class="el" href="matrix_8tpp_source.html#l00392">VNL::Matrix&lt; T &gt;::Fill()</a>, <a class="el" href="matrix_8tpp_source.html#l00402">VNL::Matrix&lt; T &gt;::FillDiagonal()</a>, <a class="el" href="matrix_8h_source.html#l00674">VNL::Matrix&lt; T &gt;::Get()</a>, <a class="el" href="matrix_8h_source.html#l00506">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::IsEmpty()</a>, <a class="el" href="matrix_8tpp_source.html#l00204">VNL::Matrix&lt; T &gt;::Matrix()</a>, <a class="el" href="matrix_8h_source.html#l00142">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::Matrix()</a>, <a class="el" href="matrixfixedref_8h_source.html#l00076">VNL::MatrixFixedRef&lt; m, n, float &gt;::MatrixFixedRef()</a>, <a class="el" href="matrixref_8h_source.html#l00053">VNL::MatrixRef&lt; T &gt;::MatrixRef()</a>, <a class="el" href="matrix_8tpp_source.html#l00498">VNL::Matrix&lt; T &gt;::operator*=()</a>, <a class="el" href="matrix_8tpp_source.html#l00482">VNL::Matrix&lt; T &gt;::operator+=()</a>, <a class="el" href="matrix_8tpp_source.html#l00490">VNL::Matrix&lt; T &gt;::operator-=()</a>, <a class="el" href="matrix_8tpp_source.html#l00506">VNL::Matrix&lt; T &gt;::operator/=()</a>, <a class="el" href="matrix_8tpp_source.html#l00425">VNL::Matrix&lt; T &gt;::operator=()</a>, <a class="el" href="matrix_8tpp_source.html#l01081">VNL::Matrix&lt; T &gt;::operator_eq()</a>, <a class="el" href="matrix_8h_source.html#l00689">VNL::Matrix&lt; T &gt;::Put()</a>, <a class="el" href="matrix_8tpp_source.html#l00364">VNL::Matrix&lt; T &gt;::Resize()</a>, <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; std::complex&lt; double &gt; &gt;::Rows()</a>, <a class="el" href="matrix_8tpp_source.html#l01056">VNL::Matrix&lt; T &gt;::SetColumns()</a>, <a class="el" href="matrix_8tpp_source.html#l01347">VNL::Matrix&lt; T &gt;::Swap()</a>, and <a class="el" href="matrix_8tpp_source.html#l00695">VNL::Matrix&lt; T &gt;::Update()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="matrixfixed_8h_source.html">matrixfixed.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Mar 21 09:55:52 2010 for VW by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

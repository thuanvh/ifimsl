<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VW: VNL::Vector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen_vw.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
  <div class="navpath"><a class="el" href="namespaceVNL.html">VNL</a>::<a class="el" href="classVNL_1_1Vector.html">Vector</a>
  </div>
<div class="contents">
<h1>VNL::Vector&lt; T &gt; Class Template Reference</h1><!-- doxytag: class="VNL::Vector" -->
<p>Mathematical vector class, templated by type of element.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector_8h_source.html">vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for VNL::Vector&lt; T &gt;:</div>
<div class="dynsection">
 <div class="center">
  <img src="classVNL_1_1Vector.gif" usemap="#VNL::Vector&lt; T &gt;_map" alt=""/>
  <map id="VNL::Vector&lt; T &gt;_map" name="VNL::Vector&lt; T &gt;_map">
<area href="classVNL_1_1FileVector.html" alt="VNL::FileVector&lt; T &gt;" shape="rect" coords="0,56,178,80"/>
<area href="classVNL_1_1VectorRef.html" alt="VNL::VectorRef&lt; T &gt;" shape="rect" coords="188,56,366,80"/>
<area href="classVNL_1_1VectorFixedRef.html" alt="VNL::VectorFixedRef&lt; n, T &gt;" shape="rect" coords="188,112,366,136"/>
<area href="classVNL_1_1VectorFixed.html" alt="VNL::VectorFixed&lt; n, T &gt;" shape="rect" coords="188,168,366,192"/>
</map>
 </div>
</div>

<p><a href="classVNL_1_1Vector-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#aa86eaf18e5e9e2e2227b7cc751e223ae">element_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type defs for iterators.  <a href="#aa86eaf18e5e9e2e2227b7cc751e223ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a30bd281b1f8e191d9e67020a95381600">iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type defs for iterators.  <a href="#a30bd281b1f8e191d9e67020a95381600"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef T const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a07536ceda54784ee2d68209ea6da0eb6">const_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Const iterator type.  <a href="#a07536ceda54784ee2d68209ea6da0eb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classVNL_1_1CVector.html">CVector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html#a3c3820b75a4a85f62604a425ff8ec66b">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a3c3820b75a4a85f62604a425ff8ec66b">abs_t</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a1c68aa94807fdb47949cbe23c5cf13fe">Vector</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an empty vector. O(1).  <a href="#a1c68aa94807fdb47949cbe23c5cf13fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a85a625f0adaa17c2e7161bd141321bce">Vector</a> (unsigned len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates vector containing n elements.  <a href="#a85a625f0adaa17c2e7161bd141321bce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a1890e1f54ec514831826a51a67d264e1">Vector</a> (unsigned len, T const &amp;v0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates vector of len elements, all set to v0.  <a href="#a1890e1f54ec514831826a51a67d264e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a4a7ae221a952372ef36a252b2dbd5924">Vector</a> (unsigned len, int n, T const values[])</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a vector of specified length and initialize first n elements with values. O(n).  <a href="#a4a7ae221a952372ef36a252b2dbd5924"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a051ee3b4cb0f76f0539bc19db729432d">Vector</a> (T const &amp;, T const &amp;, T const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a vector of length 3 and initializes with the arguments, x,y,z.  <a href="#a051ee3b4cb0f76f0539bc19db729432d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a7134b708a3ece71a50f636140e3fb088">Vector</a> (T const *data_block, unsigned int n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create n element vector and copy data from data_block.  <a href="#a7134b708a3ece71a50f636140e3fb088"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#abab9880ab6110ed086ffd432c5f451e5">Vector</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#abab9880ab6110ed086ffd432c5f451e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a3e927fa81d085e198d30cf2730c6a747">Vector</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;, <a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;, <a class="el" href="structVNL_1_1TagAdd.html">VNL::TagAdd</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#aeb15736ab23797a5fe84fc932a6d2b3f">Vector</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;, <a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;, <a class="el" href="structVNL_1_1TagSub.html">VNL::TagSub</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a919f72d1f9a8b7287eaa1b3613b1bcf4">Vector</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;, T, <a class="el" href="structVNL_1_1TagMul.html">VNL::TagMul</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a82f378d399cee005c7ae012e35723612">Vector</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;, T, <a class="el" href="structVNL_1_1TagDiv.html">VNL::TagDiv</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a6d05a204b6beb326ca0d388629f129a6">Vector</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;, T, <a class="el" href="structVNL_1_1TagAdd.html">VNL::TagAdd</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a2b8ab412dbebd58579b61f613a7d1de7">Vector</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;, T, <a class="el" href="structVNL_1_1TagSub.html">VNL::TagSub</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a001cc38762e8232a0de9bd82dfa0b23a">Vector</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;, <a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;, <a class="el" href="structVNL_1_1TagMul.html">VNL::TagMul</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a54e36f9f3568883c9f65dd35a803921e">Vector</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;, <a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;, <a class="el" href="structVNL_1_1TagMul.html">VNL::TagMul</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#ac38e4138096a1119c97407efdb4a34ac">Vector</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;that, <a class="el" href="structVNL_1_1TagGrab.html">VNL::TagGrab</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#aa9af5aa6bada4e697f7cd1a375e78d66">~Vector</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#aa9af5aa6bada4e697f7cd1a375e78d66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a31c3303fc4a4c5776fdf26d55ddaf0aa">size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the length, number of elements, dimension of this vector.  <a href="#a31c3303fc4a4c5776fdf26d55ddaf0aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a50587da2087e6693eac7791df2def5c1">Size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the length, number of elements, dimension of this vector.  <a href="#a50587da2087e6693eac7791df2def5c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a317cf202a66ff5b25207db18443055a7">Put</a> (unsigned int i, T const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put value at given position in vector.  <a href="#a317cf202a66ff5b25207db18443055a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a17db35b4d74ea5015b43bfc4eea99da7">Get</a> (unsigned int i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get value at element i.  <a href="#a17db35b4d74ea5015b43bfc4eea99da7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a414782dea8507be4cba5b530f48d4a19">Fill</a> (T const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set all values to v.  <a href="#a414782dea8507be4cba5b530f48d4a19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a89609b7eb82102c0309fc7c5f3a248bb">CopyIn</a> (T const *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets elements to ptr[i].  <a href="#a89609b7eb82102c0309fc7c5f3a248bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a970972b87c2b10b4e8fb8cb2202cdff0">CopyOut</a> (T *) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy elements to ptr[i].  <a href="#a970972b87c2b10b4e8fb8cb2202cdff0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#aaaee517447bf89ddf1c60eea4fef1e17">Set</a> (T const *ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets elements to ptr[i].  <a href="#aaaee517447bf89ddf1c60eea4fef1e17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a2bd26e49db56963cb790f6573fa9b364">operator()</a> (unsigned int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return reference to the element at specified index.  <a href="#a2bd26e49db56963cb790f6573fa9b364"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T const &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#accfd4a691b20d946910402bdddad5fd8">operator()</a> (unsigned int i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return reference to the element at specified index. No range checking.  <a href="#accfd4a691b20d946910402bdddad5fd8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#ac715ac6865b17dcd83786ab0ac7e59ab">operator[]</a> (unsigned int i)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return reference to the element at specified index. No range checking.  <a href="#ac715ac6865b17dcd83786ab0ac7e59ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T const &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a5ae76bbf564b3942ce14edaaaf4807df">operator[]</a> (unsigned int i) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return reference to the element at specified index. No range checking.  <a href="#a5ae76bbf564b3942ce14edaaaf4807df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#ae9171add4ccd20836bdeadf12704862f">operator=</a> (T const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set all elements to value v.  <a href="#ae9171add4ccd20836bdeadf12704862f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a4b6a9d13e22959f46646c2ba1f3245e8">operator=</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy operator.  <a href="#a4b6a9d13e22959f46646c2ba1f3245e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#abf9cbb88eb848b1847e3cdc77c0e9c3e">operator+=</a> (T)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add scalar value to all elements.  <a href="#abf9cbb88eb848b1847e3cdc77c0e9c3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#af176a58ea5236f88a346730bdb363aca">operator-=</a> (T)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract scalar value from all elements.  <a href="#af176a58ea5236f88a346730bdb363aca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a182190a2529b4bcf19734c953f4ced6a">operator*=</a> (T)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply all elements by scalar.  <a href="#a182190a2529b4bcf19734c953f4ced6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#ab54a3ec94a59ecb76a5762225f140b72">operator/=</a> (T)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Divide all elements by scalar.  <a href="#ab54a3ec94a59ecb76a5762225f140b72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a45d4729a17c936138e1dfd3e7a882574">operator+=</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add rhs to this and return *this.  <a href="#a45d4729a17c936138e1dfd3e7a882574"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a1b70955ee67fd6bed2f98399c95d1092">operator-=</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract rhs from this and return *this.  <a href="#a1b70955ee67fd6bed2f98399c95d1092"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a35c9b0ff6dea8426a2ad8843b32bb802">PreMultiply</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;M)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">*this = M*(*this) where M is a suitable matrix.  <a href="#a35c9b0ff6dea8426a2ad8843b32bb802"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a1b6d973a2c4b63e1338a369728874040">PostMultiply</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;M)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">*this = (*this)*M where M is a suitable matrix.  <a href="#a1b6d973a2c4b63e1338a369728874040"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a3146b4419bb22f1d33022a6fd5c9350e">operator*=</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;m)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">*this = (*this)*M where M is a suitable matrix.  <a href="#a3146b4419bb22f1d33022a6fd5c9350e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a97dc6d93e57af05c9daa67adf7812f0b">operator+</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unary plus operator.  <a href="#a97dc6d93e57af05c9daa67adf7812f0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a42afb531a77f5d662b852b883708c669">operator-</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unary minus operator.  <a href="#a42afb531a77f5d662b852b883708c669"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a14d96d3980cffdeb4782c569c09fc879">operator+</a> (T v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a8fdbd71b047565f5c318850027b112e1">operator-</a> (T v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#adf1310959505ca86294203f9c4d7409f">operator*</a> (T v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a052cd95caaa8afa71f5b91ba92e95c3f">operator/</a> (T v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a51f39381a19804bc225529dd18e1fd5a">operator+</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#aa32669fda74be65f77182818797896c8">operator-</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a318befeea4a894bea88f3b594ac6cca2">operator*</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;M) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a825cb2523c866454344e7ac3fd9aacbd">DataBlock</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the contiguous block storing the elements in the vector. O(1).  <a href="#a825cb2523c866454344e7ac3fd9aacbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a45b625ed23c29e272947466f0dfba1d6">DataBlock</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the contiguous block storing the elements in the vector. O(1).  <a href="#a45b625ed23c29e272947466f0dfba1d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html#a30bd281b1f8e191d9e67020a95381600">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#adc4bf8c37200ddc8e49603ac5224050d">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator pointing to start of data.  <a href="#adc4bf8c37200ddc8e49603ac5224050d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html#a30bd281b1f8e191d9e67020a95381600">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a14ae3cc0d59b2e6016cef301b2733b07">end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator pointing to element beyond end of data.  <a href="#a14ae3cc0d59b2e6016cef301b2733b07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html#a07536ceda54784ee2d68209ea6da0eb6">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a872de151b406868a86c96b0fd3c8c854">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator pointing to start of data.  <a href="#a872de151b406868a86c96b0fd3c8c854"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html#a07536ceda54784ee2d68209ea6da0eb6">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a3b63e6e11d2cf41d3e5965bc942d601c">end</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator pointing to element beyond end of data.  <a href="#a3b63e6e11d2cf41d3e5965bc942d601c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#aebb3ddc9ed168b9f8505a4ddf194d446">Apply</a> (T(*f)(T)) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies function to elements.  <a href="#aebb3ddc9ed168b9f8505a4ddf194d446"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a41edc640a4a338e5a402a16ce4deefb1">Apply</a> (T(*f)(T const &amp;)) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies function to elements.  <a href="#a41edc640a4a338e5a402a16ce4deefb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a7302cdb95397f4ca871fa438a1b6e87f">Extract</a> (unsigned int len, unsigned int start=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a subvector specified by the start index and length. O(n).  <a href="#a7302cdb95397f4ca871fa438a1b6e87f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a4c45bc78444fbabf8e5ddf82e2b64381">Update</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;, unsigned int start=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces elements with index begining at start, by values of v. O(n).  <a href="#a4c45bc78444fbabf8e5ddf82e2b64381"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html#a3c3820b75a4a85f62604a425ff8ec66b">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a5ba286c6da411acd5593e01efe8f0ae6">SquaredMagnitude</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sum of squares of elements.  <a href="#a5ba286c6da411acd5593e01efe8f0ae6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html#a3c3820b75a4a85f62604a425ff8ec66b">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a784c23b32b2a20840ff661ff767371e7">Magnitude</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return magnitude (length) of vector.  <a href="#a784c23b32b2a20840ff661ff767371e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html#a3c3820b75a4a85f62604a425ff8ec66b">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#aadf918aec5f7733369556f57c746301d">OneNorm</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sum of absolute values of the elements.  <a href="#aadf918aec5f7733369556f57c746301d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html#a3c3820b75a4a85f62604a425ff8ec66b">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a9915007a118ebd20be88e36ab61de2b6">TwoNorm</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sqrt of sum of squares of values of elements.  <a href="#a9915007a118ebd20be88e36ab61de2b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html#a3c3820b75a4a85f62604a425ff8ec66b">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a980aa75157dc1b391d37309ee9d6e535">InfNorm</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return largest absolute element value.  <a href="#a980aa75157dc1b391d37309ee9d6e535"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a774a49928599b951d3eb12eee4b06034">Normalize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalise by dividing through by the magnitude.  <a href="#a774a49928599b951d3eb12eee4b06034"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html#a3c3820b75a4a85f62604a425ff8ec66b">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#ac5f032f7fb83347f62747163137eace5">RMS</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Root Mean Squares of values.  <a href="#ac5f032f7fb83347f62747163137eace5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a4a706533089679b3ec8da6f0282ab52f">MinValue</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Smallest value.  <a href="#a4a706533089679b3ec8da6f0282ab52f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a5b2de8afa9cc6b48e5f1a75f7a28072a">MaxValue</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Largest value.  <a href="#a5b2de8afa9cc6b48e5f1a75f7a28072a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#ae7acc75caf5d396aeba932605993e07a">Mean</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mean of values in vector.  <a href="#ae7acc75caf5d396aeba932605993e07a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a31efc659d2fac19c15fffd247eb5e742">Sum</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sum of values in a vector.  <a href="#a31efc659d2fac19c15fffd247eb5e742"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#af6fbaf8f2bba435b7959814a05506a15">Flip</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverse the order of the elements.  <a href="#af6fbaf8f2bba435b7959814a05506a15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#af04323fccad418242258b09a15190781">Swap</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;that)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set this to that and that to this.  <a href="#af04323fccad418242258b09a15190781"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a29d01653414a6c0f4c98d2a3d18ab910">x</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return first element of vector.  <a href="#a29d01653414a6c0f4c98d2a3d18ab910"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#acecd5172ceb9461c5d69013d667b91a5">y</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return second element of vector.  <a href="#acecd5172ceb9461c5d69013d667b91a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#aa4cc062fb4afb06e122b6586be8d2bae">z</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return third element of vector.  <a href="#aa4cc062fb4afb06e122b6586be8d2bae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#ae84fadf45db6bc192fe0763f96dd031b">t</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return fourth element of vector.  <a href="#ae84fadf45db6bc192fe0763f96dd031b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a7e0ea6ebada443569254fce3dbd705c4">assert_size</a> (unsigned sz) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that <a class="el" href="classVNL_1_1Vector.html#a31c3303fc4a4c5776fdf26d55ddaf0aa" title="Return the length, number of elements, dimension of this vector.">size()</a>==sz if not, abort();.  <a href="#a7e0ea6ebada443569254fce3dbd705c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a12c40a28840fc375a39f283432c0b23c">assert_finite</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check that this is finite if not, abort();.  <a href="#a12c40a28840fc375a39f283432c0b23c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a9f59e4caf33ff5eef648e0d859787227">IsFinite</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if its finite.  <a href="#a9f59e4caf33ff5eef648e0d859787227"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a72e6fbc27ac878caccd020a8b17d0324">IsZero</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true iff all the entries are zero.  <a href="#a72e6fbc27ac878caccd020a8b17d0324"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#ae024eec01ce5d330222027371f95c6ae">IsEmpty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true iff the size is zero.  <a href="#ae024eec01ce5d330222027371f95c6ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a22c75af57a7e97e8c8fa6c996083c5b7">operator_eq</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;v) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if *this == v.  <a href="#a22c75af57a7e97e8c8fa6c996083c5b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a41d2f96b37b639c5842ac68b2f3f6909">operator==</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;that) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality test.  <a href="#a41d2f96b37b639c5842ac68b2f3f6909"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a2385267ab62f2ea35fdc575bc2073411">operator!=</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;that) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality test.  <a href="#a2385267ab62f2ea35fdc575bc2073411"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#ac03c16e02173ddc1d99b7c386b968112">Resize</a> (unsigned n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize to n elements.  <a href="#ac03c16e02173ddc1d99b7c386b968112"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a3976b2cdc793060bfb37d03b4fb018cf">Clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make the vector as if it had been default-constructed.  <a href="#a3976b2cdc793060bfb37d03b4fb018cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#aa4d736dc3fcb2e0251fe77160c8582f0">ReadASCII</a> (std::istream &amp;s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read from text stream.  <a href="#aa4d736dc3fcb2e0251fe77160c8582f0"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a83f80a7e43c1beece9924c034eee3924">Read</a> (std::istream &amp;s)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read from text stream.  <a href="#a83f80a7e43c1beece9924c034eee3924"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a0201cddcce6a2605ffbe71d0027f9f28">assert_size_internal</a> (unsigned sz) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a9d7bb988cde4547f263697437e8c34aa">assert_finite_internal</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#ad6c2dd8770d57c70a3ad867b81f48d78">destroy</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees up the array inside vector. O(1).  <a href="#ad6c2dd8770d57c70a3ad867b81f48d78"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a0cfcc3af720152c467a928b7b140a064">inline_function_tickler</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a36791cbcbbd3bcb8b0aab40b51724923">num_elmts</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#aac3e0552745ea3fdb6b84cf211578583">data</a></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Vector.html#a17fc06682c9f9c46f1e0e38b7af25b80">Matrix&lt; T &gt;</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T = double&gt;<br/>
 class VNL::Vector&lt; T &gt;</h3>

<p>Mathematical vector class, templated by type of element. </p>
<p>The Vector&lt;T&gt; class implements one-dimensional arithmetic vectors to be used with the Matrix&lt;T&gt; class. Vector&lt;T&gt; has size fixed by constructor time or changed by assignment operator. For faster, non-mallocing vectors with size known at compile time, use VectorFixed*.</p>
<p>NOTE: Vectors are indexed from zero! Thus valid elements are [0,<a class="el" href="classVNL_1_1Vector.html#a31c3303fc4a4c5776fdf26d55ddaf0aa" title="Return the length, number of elements, dimension of this vector.">size()</a>-1]. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a3c3820b75a4a85f62604a425ff8ec66b"></a><!-- doxytag: member="VNL::Vector::abs_t" ref="a3c3820b75a4a85f62604a425ff8ec66b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classVNL_1_1CVector.html">CVector</a>&lt;T&gt;::<a class="el" href="classVNL_1_1Vector.html#a3c3820b75a4a85f62604a425ff8ec66b">abs_t</a> <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html#a3c3820b75a4a85f62604a425ff8ec66b">abs_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a07536ceda54784ee2d68209ea6da0eb6"></a><!-- doxytag: member="VNL::Vector::const_iterator" ref="a07536ceda54784ee2d68209ea6da0eb6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T const* <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html#a07536ceda54784ee2d68209ea6da0eb6">const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Const iterator type. </p>

</div>
</div>
<a class="anchor" id="aa86eaf18e5e9e2e2227b7cc751e223ae"></a><!-- doxytag: member="VNL::Vector::element_type" ref="aa86eaf18e5e9e2e2227b7cc751e223ae" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html#aa86eaf18e5e9e2e2227b7cc751e223ae">element_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type defs for iterators. </p>

</div>
</div>
<a class="anchor" id="a30bd281b1f8e191d9e67020a95381600"></a><!-- doxytag: member="VNL::Vector::iterator" ref="a30bd281b1f8e191d9e67020a95381600" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html#a30bd281b1f8e191d9e67020a95381600">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type defs for iterators. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1c68aa94807fdb47949cbe23c5cf13fe"></a><!-- doxytag: member="VNL::Vector::Vector" ref="a1c68aa94807fdb47949cbe23c5cf13fe" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an empty vector. O(1). </p>

</div>
</div>
<a class="anchor" id="a85a625f0adaa17c2e7161bd141321bce"></a><!-- doxytag: member="VNL::Vector::Vector" ref="a85a625f0adaa17c2e7161bd141321bce" args="(unsigned len)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>len</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates vector containing n elements. </p>
<p>Creates a vector with specified length. O(n).</p>
<p>Elements are not initialized. </p>

<p>References <a class="el" href="vector_8tpp_source.html#l00052">vnl_vector_alloc_blah</a>.</p>

</div>
</div>
<a class="anchor" id="a1890e1f54ec514831826a51a67d264e1"></a><!-- doxytag: member="VNL::Vector::Vector" ref="a1890e1f54ec514831826a51a67d264e1" args="(unsigned len, T const &amp;v0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>v0</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates vector of len elements, all set to v0. </p>
<p>Creates a vector of specified length, and initialize all elements with value. O(n). </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8tpp_source.html#l00052">vnl_vector_alloc_blah</a>.</p>

</div>
</div>
<a class="anchor" id="a4a7ae221a952372ef36a252b2dbd5924"></a><!-- doxytag: member="VNL::Vector::Vector" ref="a4a7ae221a952372ef36a252b2dbd5924" args="(unsigned len, int n, T const values[])" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &nbsp;</td>
          <td class="paramname"> <em>values</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a vector of specified length and initialize first n elements with values. O(n). </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8tpp_source.html#l00052">vnl_vector_alloc_blah</a>.</p>

</div>
</div>
<a class="anchor" id="a051ee3b4cb0f76f0539bc19db729432d"></a><!-- doxytag: member="VNL::Vector::Vector" ref="a051ee3b4cb0f76f0539bc19db729432d" args="(T const &amp;, T const &amp;, T const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>py</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>pz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a vector of length 3 and initializes with the arguments, x,y,z. </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8tpp_source.html#l00052">vnl_vector_alloc_blah</a>.</p>

</div>
</div>
<a class="anchor" id="a7134b708a3ece71a50f636140e3fb088"></a><!-- doxytag: member="VNL::Vector::Vector" ref="a7134b708a3ece71a50f636140e3fb088" args="(T const *data_block, unsigned int n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">T const *&nbsp;</td>
          <td class="paramname"> <em>data_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create n element vector and copy data from data_block. </p>

</div>
</div>
<a class="anchor" id="abab9880ab6110ed086ffd432c5f451e5"></a><!-- doxytag: member="VNL::Vector::Vector" ref="abab9880ab6110ed086ffd432c5f451e5" args="(Vector&lt; T &gt; const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Creates a new copy of vector v. O(n). </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>, and <a class="el" href="vector_8tpp_source.html#l00052">vnl_vector_alloc_blah</a>.</p>

</div>
</div>
<a class="anchor" id="a3e927fa81d085e198d30cf2730c6a747"></a><!-- doxytag: member="VNL::Vector::Vector" ref="a3e927fa81d085e198d30cf2730c6a747" args="(Vector&lt; T &gt; const &amp;, Vector&lt; T &gt; const &amp;, VNL::TagAdd)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVNL_1_1TagAdd.html">VNL::TagAdd</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00036">VNL::ErrorVectorDimension()</a>, <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>, <a class="el" href="vector_8h_source.html#l00142">VNL::Vector&lt; T &gt;::size()</a>, and <a class="el" href="vector_8tpp_source.html#l00052">vnl_vector_alloc_blah</a>.</p>

</div>
</div>
<a class="anchor" id="aeb15736ab23797a5fe84fc932a6d2b3f"></a><!-- doxytag: member="VNL::Vector::Vector" ref="aeb15736ab23797a5fe84fc932a6d2b3f" args="(Vector&lt; T &gt; const &amp;, Vector&lt; T &gt; const &amp;, VNL::TagSub)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVNL_1_1TagSub.html">VNL::TagSub</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00036">VNL::ErrorVectorDimension()</a>, <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>, <a class="el" href="vector_8h_source.html#l00142">VNL::Vector&lt; T &gt;::size()</a>, and <a class="el" href="vector_8tpp_source.html#l00052">vnl_vector_alloc_blah</a>.</p>

</div>
</div>
<a class="anchor" id="a919f72d1f9a8b7287eaa1b3613b1bcf4"></a><!-- doxytag: member="VNL::Vector::Vector" ref="a919f72d1f9a8b7287eaa1b3613b1bcf4" args="(Vector&lt; T &gt; const &amp;, T, VNL::TagMul)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVNL_1_1TagMul.html">VNL::TagMul</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>, and <a class="el" href="vector_8tpp_source.html#l00052">vnl_vector_alloc_blah</a>.</p>

</div>
</div>
<a class="anchor" id="a82f378d399cee005c7ae012e35723612"></a><!-- doxytag: member="VNL::Vector::Vector" ref="a82f378d399cee005c7ae012e35723612" args="(Vector&lt; T &gt; const &amp;, T, VNL::TagDiv)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVNL_1_1TagDiv.html">VNL::TagDiv</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>, and <a class="el" href="vector_8tpp_source.html#l00052">vnl_vector_alloc_blah</a>.</p>

</div>
</div>
<a class="anchor" id="a6d05a204b6beb326ca0d388629f129a6"></a><!-- doxytag: member="VNL::Vector::Vector" ref="a6d05a204b6beb326ca0d388629f129a6" args="(Vector&lt; T &gt; const &amp;, T, VNL::TagAdd)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVNL_1_1TagAdd.html">VNL::TagAdd</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>, and <a class="el" href="vector_8tpp_source.html#l00052">vnl_vector_alloc_blah</a>.</p>

</div>
</div>
<a class="anchor" id="a2b8ab412dbebd58579b61f613a7d1de7"></a><!-- doxytag: member="VNL::Vector::Vector" ref="a2b8ab412dbebd58579b61f613a7d1de7" args="(Vector&lt; T &gt; const &amp;, T, VNL::TagSub)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVNL_1_1TagSub.html">VNL::TagSub</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>, and <a class="el" href="vector_8tpp_source.html#l00052">vnl_vector_alloc_blah</a>.</p>

</div>
</div>
<a class="anchor" id="a001cc38762e8232a0de9bd82dfa0b23a"></a><!-- doxytag: member="VNL::Vector::Vector" ref="a001cc38762e8232a0de9bd82dfa0b23a" args="(Matrix&lt; T &gt; const &amp;, Vector&lt; T &gt; const &amp;, VNL::TagMul)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVNL_1_1TagMul.html">VNL::TagMul</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00036">VNL::ErrorVectorDimension()</a>, <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>, <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>, <a class="el" href="vector_8h_source.html#l00142">VNL::Vector&lt; T &gt;::size()</a>, and <a class="el" href="vector_8tpp_source.html#l00052">vnl_vector_alloc_blah</a>.</p>

</div>
</div>
<a class="anchor" id="a54e36f9f3568883c9f65dd35a803921e"></a><!-- doxytag: member="VNL::Vector::Vector" ref="a54e36f9f3568883c9f65dd35a803921e" args="(Vector&lt; T &gt; const &amp;, Matrix&lt; T &gt; const &amp;, VNL::TagMul)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVNL_1_1TagMul.html">VNL::TagMul</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00036">VNL::ErrorVectorDimension()</a>, <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>, <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>, <a class="el" href="vector_8h_source.html#l00142">VNL::Vector&lt; T &gt;::size()</a>, and <a class="el" href="vector_8tpp_source.html#l00052">vnl_vector_alloc_blah</a>.</p>

</div>
</div>
<a class="anchor" id="ac38e4138096a1119c97407efdb4a34ac"></a><!-- doxytag: member="VNL::Vector::Vector" ref="ac38e4138096a1119c97407efdb4a34ac" args="(Vector&lt; T &gt; &amp;that, VNL::TagGrab)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVNL_1_1TagGrab.html">VNL::TagGrab</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa9af5aa6bada4e697f7cd1a375e78d66"></a><!-- doxytag: member="VNL::Vector::~Vector" ref="aa9af5aa6bada4e697f7cd1a375e78d66" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::~<a class="el" href="classVNL_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a41edc640a4a338e5a402a16ce4deefb1"></a><!-- doxytag: member="VNL::Vector::Apply" ref="a41edc640a4a338e5a402a16ce4deefb1" args="(T(*f)(T const &amp;)) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Apply </td>
          <td>(</td>
          <td class="paramtype">T(*)(T const &amp;)&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies function to elements. </p>

<p>References <a class="el" href="vector_8tpp_source.html#l00651">VNL::Vector&lt; T &gt;::Apply()</a>, <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>, and <a class="el" href="vector_8h_source.html#l00142">VNL::Vector&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="aebb3ddc9ed168b9f8505a4ddf194d446"></a><!-- doxytag: member="VNL::Vector::Apply" ref="aebb3ddc9ed168b9f8505a4ddf194d446" args="(T(*f)(T)) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Apply </td>
          <td>(</td>
          <td class="paramtype">T(*)(T)&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies function to elements. </p>
<p>Return the vector made by applying "f" to each element. </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>.</p>

<p>Referenced by <a class="el" href="vector_8tpp_source.html#l00642">VNL::Vector&lt; T &gt;::Apply()</a>.</p>

</div>
</div>
<a class="anchor" id="a12c40a28840fc375a39f283432c0b23c"></a><!-- doxytag: member="VNL::Vector::assert_finite" ref="a12c40a28840fc375a39f283432c0b23c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::assert_finite </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check that this is finite if not, abort();. </p>
<p>This function does or tests nothing if NDEBUG is defined </p>

<p>Referenced by <a class="el" href="rpolyroots_8cpp_source.html#l00028">VNL::RPolyRoots::RPolyRoots()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d7bb988cde4547f263697437e8c34aa"></a><!-- doxytag: member="VNL::Vector::assert_finite_internal" ref="a9d7bb988cde4547f263697437e8c34aa" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::assert_finite_internal </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="vector_8tpp_source.html#l00796">VNL::Vector&lt; T &gt;::IsFinite()</a>.</p>

<p>Referenced by <a class="el" href="vector_8h_source.html#l00420">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::assert_finite()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e0ea6ebada443569254fce3dbd705c4"></a><!-- doxytag: member="VNL::Vector::assert_size" ref="a7e0ea6ebada443569254fce3dbd705c4" args="(unsigned sz) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::assert_size </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>sz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check that <a class="el" href="classVNL_1_1Vector.html#a31c3303fc4a4c5776fdf26d55ddaf0aa" title="Return the length, number of elements, dimension of this vector.">size()</a>==sz if not, abort();. </p>
<p>This function does or tests nothing if NDEBUG is defined </p>

</div>
</div>
<a class="anchor" id="a0201cddcce6a2605ffbe71d0027f9f28"></a><!-- doxytag: member="VNL::Vector::assert_size_internal" ref="a0201cddcce6a2605ffbe71d0027f9f28" args="(unsigned sz) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::assert_size_internal </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>sz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="vector_8h_source.html#l00142">VNL::Vector&lt; T &gt;::size()</a>.</p>

<p>Referenced by <a class="el" href="vector_8h_source.html#l00411">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::assert_size()</a>.</p>

</div>
</div>
<a class="anchor" id="a872de151b406868a86c96b0fd3c8c854"></a><!-- doxytag: member="VNL::Vector::begin" ref="a872de151b406868a86c96b0fd3c8c854" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html#a07536ceda54784ee2d68209ea6da0eb6">const_iterator</a> <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator pointing to start of data. </p>

</div>
</div>
<a class="anchor" id="adc4bf8c37200ddc8e49603ac5224050d"></a><!-- doxytag: member="VNL::Vector::begin" ref="adc4bf8c37200ddc8e49603ac5224050d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html#a30bd281b1f8e191d9e67020a95381600">iterator</a> <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator pointing to start of data. </p>

<p>Referenced by <a class="el" href="radialdistortioncompute_8cpp_source.html#l00053">VW::RadialDistortionCompute::LeastSquaresFunction::F()</a>, <a class="el" href="pmatrixcomputenonlinear_8cpp_source.html#l00193">VW::PMatrixCompute::LSFuncPoints::F()</a>, <a class="el" href="homography2dcomputenonlinear_8cpp_source.html#l00085">VW::Homography2DCompute::LeastSquaresFunctionPoints::F()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00370">VW::FMPlanarCompute::LeastSquaresFunctionPoints::F()</a>, <a class="el" href="fmatrixcomputenonlinear_8cpp_source.html#l00121">VW::FMatrixCompute::LeastSquaresFunctionPoints::F()</a>, <a class="el" href="generalizedeigensystem_8cpp_source.html#l00023">VNL::GeneralizedEigensystem::GeneralizedEigensystem()</a>, <a class="el" href="generalizedschur_8h_source.html#l00047">VNL::GeneralizedSchur()</a>, <a class="el" href="vector_8h_source.html#l00342">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::InfNorm()</a>, <a class="el" href="matlabprint_8tpp_source.html#l00099">VNL::MatlabPrint()</a>, <a class="el" href="matlabread_8cpp_source.html#l00191">VNL::MatlabReadOrDie()</a>, <a class="el" href="vector_8h_source.html#l00361">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::MaxValue()</a>, <a class="el" href="vector_8h_source.html#l00365">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::Mean()</a>, <a class="el" href="vector_8h_source.html#l00357">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::MinValue()</a>, <a class="el" href="vector_8h_source.html#l00346">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::Normalize()</a>, <a class="el" href="vector_8h_source.html#l00334">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::OneNorm()</a>, <a class="el" href="vector_8h_source.html#l00353">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::RMS()</a>, <a class="el" href="vector_8h_source.html#l00326">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::SquaredMagnitude()</a>, <a class="el" href="vector_8h_source.html#l00369">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::Sum()</a>, <a class="el" href="vector_8h_source.html#l00338">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::TwoNorm()</a>, <a class="el" href="vector_8h_source.html#l00576">VNL::VectorSSD()</a>, and <a class="el" href="complexops_8tpp_source.html#l00033">vnl_complexify()</a>.</p>

</div>
</div>
<a class="anchor" id="a3976b2cdc793060bfb37d03b4fb018cf"></a><!-- doxytag: member="VNL::Vector::Clear" ref="a3976b2cdc793060bfb37d03b4fb018cf" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make the vector as if it had been default-constructed. </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="vector_8tpp_source.html#l00270">VNL::Vector&lt; T &gt;::destroy()</a>, and <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>.</p>

<p>Referenced by <a class="el" href="binary_8cpp_source.html#l00036">VNL::BinaryLoad()</a>, and <a class="el" href="vector_8tpp_source.html#l00380">VNL::Vector&lt; T &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a89609b7eb82102c0309fc7c5f3a248bb"></a><!-- doxytag: member="VNL::Vector::CopyIn" ref="a89609b7eb82102c0309fc7c5f3a248bb" args="(T const *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::CopyIn </td>
          <td>(</td>
          <td class="paramtype">T const *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets elements to ptr[i]. </p>
<p>Sets elements of a vector to those in an array. O(n).</p>
<p>Note: ptr[i] must be valid for i=0..<a class="el" href="classVNL_1_1Vector.html#a31c3303fc4a4c5776fdf26d55ddaf0aa" title="Return the length, number of elements, dimension of this vector.">size()</a>-1 </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>.</p>

<p>Referenced by <a class="el" href="computefuncs_8h_source.html#l00017">VW::ComputeFuncs::ConvertTransformToParamVector()</a>, and <a class="el" href="vector_8h_source.html#l00174">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::Set()</a>.</p>

</div>
</div>
<a class="anchor" id="a970972b87c2b10b4e8fb8cb2202cdff0"></a><!-- doxytag: member="VNL::Vector::CopyOut" ref="a970972b87c2b10b4e8fb8cb2202cdff0" args="(T *) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::CopyOut </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy elements to ptr[i]. </p>
<p>Sets elements of an array to those in vector. O(n).</p>
<p>Note: ptr[i] must be valid for i=0..<a class="el" href="classVNL_1_1Vector.html#a31c3303fc4a4c5776fdf26d55ddaf0aa" title="Return the length, number of elements, dimension of this vector.">size()</a>-1 </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>.</p>

<p>Referenced by <a class="el" href="computefuncs_8h_source.html#l00034">VW::ComputeFuncs::ConvertParamVectorToTransform()</a>, and <a class="el" href="symmatrix_8tpp_source.html#l00067">VNL::SymMatrix&lt; T &gt;::SetHalfRow()</a>.</p>

</div>
</div>
<a class="anchor" id="a45b625ed23c29e272947466f0dfba1d6"></a><!-- doxytag: member="VNL::Vector::DataBlock" ref="a45b625ed23c29e272947466f0dfba1d6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::DataBlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the contiguous block storing the elements in the vector. O(1). </p>
<p>data_block()[0] is the first element of the vector </p>

</div>
</div>
<a class="anchor" id="a825cb2523c866454344e7ac3fd9aacbd"></a><!-- doxytag: member="VNL::Vector::DataBlock" ref="a825cb2523c866454344e7ac3fd9aacbd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T const* <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::DataBlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the contiguous block storing the elements in the vector. O(1). </p>
<p>data_block()[0] is the first element of the vector </p>

<p>Referenced by <a class="el" href="fastops_8cpp_source.html#l00130">vnl_fastops::AtB()</a>, <a class="el" href="binary_8cpp_source.html#l00036">VNL::BinaryLoad()</a>, <a class="el" href="binary_8cpp_source.html#l00024">VNL::BinarySave()</a>, <a class="el" href="cholesky_8tpp_source.html#l00051">VNL::Cholesky&lt; T &gt;::Cholesky()</a>, <a class="el" href="rpolyroots_8cpp_source.html#l00078">VNL::RPolyRoots::Compute()</a>, <a class="el" href="convolve_8tpp_source.html#l00078">VNL::ConvolveUsingFFT()</a>, <a class="el" href="crossproductmatrix_8h_source.html#l00043">VNL::CrossProductMatrix&lt; T &gt;::CrossProductMatrix()</a>, <a class="el" href="realpolynomial_8cpp_source.html#l00073">VNL::RealPolynomial::Evaluate()</a>, <a class="el" href="realpolynomial_8cpp_source.html#l00115">VNL::RealPolynomial::EvaluateIntegral()</a>, <a class="el" href="parametricflow_8cpp_source.html#l00409">VW::ParametricFlowFunc&lt; Type &gt;::F()</a>, <a class="el" href="fastops_8cpp_source.html#l00271">vnl_fastops::inc_X_by_AtB()</a>, <a class="el" href="lsqr_8cpp_source.html#l00072">VNL::LSqr::Minimize()</a>, <a class="el" href="lbfgs_8cpp_source.html#l00083">VNL::LBFGS::Minimize()</a>, <a class="el" href="conjugategradient_8cpp_source.html#l00160">VNL::ConjugateGradient::Minimize()</a>, <a class="el" href="levenbergmarquardt_8cpp_source.html#l00276">VNL::LevenbergMarquardt::MinimizeUsingGradient()</a>, <a class="el" href="levenbergmarquardt_8cpp_source.html#l00145">VNL::LevenbergMarquardt::MinimizeWithoutGradient()</a>, <a class="el" href="vectorfixed_8h_source.html#l00125">VNL::VectorFixed&lt; 3, T &gt;::operator=()</a>, <a class="el" href="qr_8tpp_source.html#l00040">VNL::QR&lt; T &gt;::QR()</a>, <a class="el" href="qr_8tpp_source.html#l00218">VNL::QR&lt; T &gt;::QtB()</a>, <a class="el" href="realeigensystem_8cpp_source.html#l00023">VNL::RealEigensystem::RealEigensystem()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00094">VW::FMPlanarCompute::ReconstructTransformHZ()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00302">VW::FMPlanarCompute::ReconstructTransformHZJK()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00190">VW::FMPlanarCompute::ReconstructTransformVLJK()</a>, <a class="el" href="matrix_8tpp_source.html#l01038">VNL::Matrix&lt; T &gt;::SetColumn()</a>, <a class="el" href="matrix_8tpp_source.html#l01010">VNL::Matrix&lt; T &gt;::SetRow()</a>, <a class="el" href="qr_8tpp_source.html#l00187">VNL::QR&lt; T &gt;::Solve()</a>, <a class="el" href="cholesky_8tpp_source.html#l00096">VNL::Cholesky&lt; T &gt;::Solve()</a>, <a class="el" href="svd_8tpp_source.html#l00042">VNL::SVD&lt; T &gt;::SVD()</a>, <a class="el" href="vectorfixed_8h_source.html#l00077">VNL::VectorFixed&lt; 3, T &gt;::VectorFixed()</a>, <a class="el" href="vectorref_8h_source.html#l00050">VNL::VectorRef&lt; double &gt;::VectorRef()</a>, and <a class="el" href="matlabfilewrite_8cpp_source.html#l00050">VNL::MatlabFilewrite::Write()</a>.</p>

</div>
</div>
<a class="anchor" id="ad6c2dd8770d57c70a3ad867b81f48d78"></a><!-- doxytag: member="VNL::Vector::destroy" ref="ad6c2dd8770d57c70a3ad867b81f48d78" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::destroy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees up the array inside vector. O(1). </p>

<p>References <a class="el" href="vector_8tpp_source.html#l00059">vnl_vector_free_blah</a>.</p>

<p>Referenced by <a class="el" href="vector_8tpp_source.html#l00276">VNL::Vector&lt; T &gt;::Clear()</a>, and <a class="el" href="vector_8h_source.html#l00138">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::~Vector()</a>.</p>

</div>
</div>
<a class="anchor" id="a3b63e6e11d2cf41d3e5965bc942d601c"></a><!-- doxytag: member="VNL::Vector::end" ref="a3b63e6e11d2cf41d3e5965bc942d601c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html#a07536ceda54784ee2d68209ea6da0eb6">const_iterator</a> <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator pointing to element beyond end of data. </p>

</div>
</div>
<a class="anchor" id="a14ae3cc0d59b2e6016cef301b2733b07"></a><!-- doxytag: member="VNL::Vector::end" ref="a14ae3cc0d59b2e6016cef301b2733b07" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html#a30bd281b1f8e191d9e67020a95381600">iterator</a> <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator pointing to element beyond end of data. </p>

<p>Referenced by <a class="el" href="generalizedschur_8h_source.html#l00047">VNL::GeneralizedSchur()</a>.</p>

</div>
</div>
<a class="anchor" id="a7302cdb95397f4ca871fa438a1b6e87f"></a><!-- doxytag: member="VNL::Vector::Extract" ref="a7302cdb95397f4ca871fa438a1b6e87f" args="(unsigned int len, unsigned int start=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt;T&gt; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Extract </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>start</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a subvector specified by the start index and length. O(n). </p>

</div>
</div>
<a class="anchor" id="a414782dea8507be4cba5b530f48d4a19"></a><!-- doxytag: member="VNL::Vector::Fill" ref="a414782dea8507be4cba5b530f48d4a19" args="(T const &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Fill </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set all values to v. </p>
<p>Sets all elements of a vector to a specified fill value. O(n). </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>.</p>

<p>Referenced by <a class="el" href="sparsematrix_8tpp_source.html#l00427">VNL::SparseMatrix&lt; T &gt;::diag_AtA()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00238">VNL::SparseMatrix&lt; T &gt;::mult()</a>, <a class="el" href="realpolynomial_8cpp_source.html#l00187">VNL::operator*()</a>, <a class="el" href="vector_8h_source.html#l00206">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::operator=()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00265">VNL::SparseMatrix&lt; T &gt;::pre_mult()</a>, and <a class="el" href="qr_8tpp_source.html#l00040">VNL::QR&lt; T &gt;::QR()</a>.</p>

</div>
</div>
<a class="anchor" id="af6fbaf8f2bba435b7959814a05506a15"></a><!-- doxytag: member="VNL::Vector::Flip" ref="af6fbaf8f2bba435b7959814a05506a15" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Flip </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverse the order of the elements. </p>
<p>Element i swaps with element <a class="el" href="classVNL_1_1Vector.html#a31c3303fc4a4c5776fdf26d55ddaf0aa" title="Return the length, number of elements, dimension of this vector.">size()</a>-1-i </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>.</p>

</div>
</div>
<a class="anchor" id="a17db35b4d74ea5015b43bfc4eea99da7"></a><!-- doxytag: member="VNL::Vector::Get" ref="a17db35b4d74ea5015b43bfc4eea99da7" args="(unsigned int i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Get </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get value at element i. </p>
<p>Gets the element at specified index and return its value. O(1).</p>
<p>Range check is performed. </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>.</p>

</div>
</div>
<a class="anchor" id="a980aa75157dc1b391d37309ee9d6e535"></a><!-- doxytag: member="VNL::Vector::InfNorm" ref="a980aa75157dc1b391d37309ee9d6e535" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html#a3c3820b75a4a85f62604a425ff8ec66b">abs_t</a> <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::InfNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return largest absolute element value. </p>

<p>Referenced by <a class="el" href="vector_8h_source.html#l00342">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::InfNorm()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cfcc3af720152c467a928b7b140a064"></a><!-- doxytag: member="VNL::Vector::inline_function_tickler" ref="a0cfcc3af720152c467a928b7b140a064" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::inline_function_tickler </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae024eec01ce5d330222027371f95c6ae"></a><!-- doxytag: member="VNL::Vector::IsEmpty" ref="ae024eec01ce5d330222027371f95c6ae" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true iff the size is zero. </p>

</div>
</div>
<a class="anchor" id="a9f59e4caf33ff5eef648e0d859787227"></a><!-- doxytag: member="VNL::Vector::IsFinite" ref="a9f59e4caf33ff5eef648e0d859787227" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::IsFinite </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if its finite. </p>

<p>References <a class="el" href="bignum_8h_source.html#l00396">VNL::IsFinite()</a>, and <a class="el" href="vector_8h_source.html#l00142">VNL::Vector&lt; T &gt;::size()</a>.</p>

<p>Referenced by <a class="el" href="vector_8tpp_source.html#l00816">VNL::Vector&lt; T &gt;::assert_finite_internal()</a>.</p>

</div>
</div>
<a class="anchor" id="a72e6fbc27ac878caccd020a8b17d0324"></a><!-- doxytag: member="VNL::Vector::IsZero" ref="a72e6fbc27ac878caccd020a8b17d0324" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::IsZero </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true iff all the entries are zero. </p>

<p>References <a class="el" href="vector_8h_source.html#l00142">VNL::Vector&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a784c23b32b2a20840ff661ff767371e7"></a><!-- doxytag: member="VNL::Vector::Magnitude" ref="a784c23b32b2a20840ff661ff767371e7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html#a3c3820b75a4a85f62604a425ff8ec66b">abs_t</a> <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Magnitude </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return magnitude (length) of vector. </p>

<p>Referenced by <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00032">VW::FMPlanarCompute::GenerateParameterVectorHZ()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00224">VW::FMPlanarCompute::GenerateParameterVectorHZJK()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00118">VW::FMPlanarCompute::GenerateParameterVectorVLJK()</a>, <a class="el" href="levenbergmarquardt_8cpp_source.html#l00234">VNL::LevenbergMarquardt::lmder_lsqfun()</a>, <a class="el" href="levenbergmarquardt_8cpp_source.html#l00093">VNL::LevenbergMarquardt::lmdif_lsqfun()</a>, and <a class="el" href="lbfgs_8cpp_source.html#l00083">VNL::LBFGS::Minimize()</a>.</p>

</div>
</div>
<a class="anchor" id="a5b2de8afa9cc6b48e5f1a75f7a28072a"></a><!-- doxytag: member="VNL::Vector::MaxValue" ref="a5b2de8afa9cc6b48e5f1a75f7a28072a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::MaxValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Largest value. </p>

<p>Referenced by <a class="el" href="vector_8h_source.html#l00361">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::MaxValue()</a>.</p>

</div>
</div>
<a class="anchor" id="ae7acc75caf5d396aeba932605993e07a"></a><!-- doxytag: member="VNL::Vector::Mean" ref="ae7acc75caf5d396aeba932605993e07a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Mean </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mean of values in vector. </p>

<p>Referenced by <a class="el" href="vector_8h_source.html#l00365">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::Mean()</a>.</p>

</div>
</div>
<a class="anchor" id="a4a706533089679b3ec8da6f0282ab52f"></a><!-- doxytag: member="VNL::Vector::MinValue" ref="a4a706533089679b3ec8da6f0282ab52f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::MinValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Smallest value. </p>

<p>Referenced by <a class="el" href="vector_8h_source.html#l00357">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::MinValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a774a49928599b951d3eb12eee4b06034"></a><!-- doxytag: member="VNL::Vector::Normalize" ref="a774a49928599b951d3eb12eee4b06034" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt;T&gt;&amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Normalize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalise by dividing through by the magnitude. </p>

<p>Reimplemented in <a class="el" href="classVNL_1_1VectorFixedRef.html#a83988cbd014a3caae8c99498b48d5fcf">VNL::VectorFixedRef&lt; n, T &gt;</a>, and <a class="el" href="classVNL_1_1VectorFixedRef.html#a83988cbd014a3caae8c99498b48d5fcf">VNL::VectorFixedRef&lt; n, double &gt;</a>.</p>

<p>Referenced by <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00224">VW::FMPlanarCompute::GenerateParameterVectorHZJK()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00118">VW::FMPlanarCompute::GenerateParameterVectorVLJK()</a>, <a class="el" href="vector_8h_source.html#l00346">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::Normalize()</a>, and <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00190">VW::FMPlanarCompute::ReconstructTransformVLJK()</a>.</p>

</div>
</div>
<a class="anchor" id="aadf918aec5f7733369556f57c746301d"></a><!-- doxytag: member="VNL::Vector::OneNorm" ref="aadf918aec5f7733369556f57c746301d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html#a3c3820b75a4a85f62604a425ff8ec66b">abs_t</a> <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::OneNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return sum of absolute values of the elements. </p>

<p>Referenced by <a class="el" href="vector_8h_source.html#l00334">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::OneNorm()</a>.</p>

</div>
</div>
<a class="anchor" id="a2385267ab62f2ea35fdc575bc2073411"></a><!-- doxytag: member="VNL::Vector::operator!=" ref="a2385267ab62f2ea35fdc575bc2073411" args="(Vector&lt; T &gt; const &amp;that) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inequality test. </p>

</div>
</div>
<a class="anchor" id="accfd4a691b20d946910402bdddad5fd8"></a><!-- doxytag: member="VNL::Vector::operator()" ref="accfd4a691b20d946910402bdddad5fd8" args="(unsigned int i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T const&amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return reference to the element at specified index. No range checking. </p>
<p>There are assert style boundary checks - define NDEBUG to turn them off. </p>

</div>
</div>
<a class="anchor" id="a2bd26e49db56963cb790f6573fa9b364"></a><!-- doxytag: member="VNL::Vector::operator()" ref="a2bd26e49db56963cb790f6573fa9b364" args="(unsigned int i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return reference to the element at specified index. </p>
<p>There are assert style boundary checks - define NDEBUG to turn them off. </p>

</div>
</div>
<a class="anchor" id="a318befeea4a894bea88f3b594ac6cca2"></a><!-- doxytag: member="VNL::Vector::operator*" ref="a318befeea4a894bea88f3b594ac6cca2" args="(Matrix&lt; T &gt; const &amp;M) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt;T&gt; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adf1310959505ca86294203f9c4d7409f"></a><!-- doxytag: member="VNL::Vector::operator*" ref="adf1310959505ca86294203f9c4d7409f" args="(T v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt;T&gt; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classVNL_1_1VectorFixed.html#ae1dc80d792ea288958144e5a53308e51">VNL::VectorFixed&lt; n, T &gt;</a>, <a class="el" href="classVNL_1_1VectorFixed.html#ae1dc80d792ea288958144e5a53308e51">VNL::VectorFixed&lt; 1, double &gt;</a>, <a class="el" href="classVNL_1_1VectorFixed.html#ae1dc80d792ea288958144e5a53308e51">VNL::VectorFixed&lt; 2, double &gt;</a>, <a class="el" href="classVNL_1_1VectorFixed.html#ae1dc80d792ea288958144e5a53308e51">VNL::VectorFixed&lt; 3, double &gt;</a>, and <a class="el" href="classVNL_1_1VectorFixed.html#ae1dc80d792ea288958144e5a53308e51">VNL::VectorFixed&lt; 3, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3146b4419bb22f1d33022a6fd5c9350e"></a><!-- doxytag: member="VNL::Vector::operator*=" ref="a3146b4419bb22f1d33022a6fd5c9350e" args="(Matrix&lt; T &gt; const &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt;T&gt;&amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>*this = (*this)*M where M is a suitable matrix. </p>
<p>this is treated as a row vector </p>

<p>Reimplemented in <a class="el" href="classVNL_1_1VectorFixedRef.html#a6d9b3f57a8fbc210e7d465f277b6efd3">VNL::VectorFixedRef&lt; n, T &gt;</a>, and <a class="el" href="classVNL_1_1VectorFixedRef.html#a6d9b3f57a8fbc210e7d465f277b6efd3">VNL::VectorFixedRef&lt; n, double &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a182190a2529b4bcf19734c953f4ced6a"></a><!-- doxytag: member="VNL::Vector::operator*=" ref="a182190a2529b4bcf19734c953f4ced6a" args="(T)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply all elements by scalar. </p>
<p>Multiplies all elements of vector with value. O(n). </p>

<p>Reimplemented in <a class="el" href="classVNL_1_1VectorFixedRef.html#abb21dcfa4c92047a9836eeff173f0798">VNL::VectorFixedRef&lt; n, T &gt;</a>, and <a class="el" href="classVNL_1_1VectorFixedRef.html#abb21dcfa4c92047a9836eeff173f0798">VNL::VectorFixedRef&lt; n, double &gt;</a>.</p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>.</p>

</div>
</div>
<a class="anchor" id="a51f39381a19804bc225529dd18e1fd5a"></a><!-- doxytag: member="VNL::Vector::operator+" ref="a51f39381a19804bc225529dd18e1fd5a" args="(Vector&lt; T &gt; const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt;T&gt; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a14d96d3980cffdeb4782c569c09fc879"></a><!-- doxytag: member="VNL::Vector::operator+" ref="a14d96d3980cffdeb4782c569c09fc879" args="(T v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt;T&gt; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classVNL_1_1VectorFixed.html#ac9bb3e29c72611bb332c2bc3b517fe68">VNL::VectorFixed&lt; n, T &gt;</a>, <a class="el" href="classVNL_1_1VectorFixed.html#ac9bb3e29c72611bb332c2bc3b517fe68">VNL::VectorFixed&lt; 1, double &gt;</a>, <a class="el" href="classVNL_1_1VectorFixed.html#ac9bb3e29c72611bb332c2bc3b517fe68">VNL::VectorFixed&lt; 2, double &gt;</a>, <a class="el" href="classVNL_1_1VectorFixed.html#ac9bb3e29c72611bb332c2bc3b517fe68">VNL::VectorFixed&lt; 3, double &gt;</a>, and <a class="el" href="classVNL_1_1VectorFixed.html#ac9bb3e29c72611bb332c2bc3b517fe68">VNL::VectorFixed&lt; 3, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a97dc6d93e57af05c9daa67adf7812f0b"></a><!-- doxytag: member="VNL::Vector::operator+" ref="a97dc6d93e57af05c9daa67adf7812f0b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt;T&gt; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unary plus operator. </p>
<p>Return new vector = (*this) </p>

</div>
</div>
<a class="anchor" id="a45d4729a17c936138e1dfd3e7a882574"></a><!-- doxytag: member="VNL::Vector::operator+=" ref="a45d4729a17c936138e1dfd3e7a882574" args="(Vector&lt; T &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add rhs to this and return *this. </p>
<p>Mutates lhs vector with its addition with rhs vector. O(n). </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00036">VNL::ErrorVectorDimension()</a>, and <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>.</p>

</div>
</div>
<a class="anchor" id="abf9cbb88eb848b1847e3cdc77c0e9c3e"></a><!-- doxytag: member="VNL::Vector::operator+=" ref="abf9cbb88eb848b1847e3cdc77c0e9c3e" args="(T)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add scalar value to all elements. </p>
<p>Increments all elements of vector with value. O(n). </p>

<p>Reimplemented in <a class="el" href="classVNL_1_1VectorFixedRef.html#ad71613864d5e5cb06209d2b894049cdc">VNL::VectorFixedRef&lt; n, T &gt;</a>, and <a class="el" href="classVNL_1_1VectorFixedRef.html#ad71613864d5e5cb06209d2b894049cdc">VNL::VectorFixedRef&lt; n, double &gt;</a>.</p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>.</p>

</div>
</div>
<a class="anchor" id="aa32669fda74be65f77182818797896c8"></a><!-- doxytag: member="VNL::Vector::operator&#45;" ref="aa32669fda74be65f77182818797896c8" args="(Vector&lt; T &gt; const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt;T&gt; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8fdbd71b047565f5c318850027b112e1"></a><!-- doxytag: member="VNL::Vector::operator&#45;" ref="a8fdbd71b047565f5c318850027b112e1" args="(T v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt;T&gt; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classVNL_1_1VectorFixed.html#a8f5960396ab52ca1cd3b1575800b6533">VNL::VectorFixed&lt; n, T &gt;</a>, <a class="el" href="classVNL_1_1VectorFixed.html#a8f5960396ab52ca1cd3b1575800b6533">VNL::VectorFixed&lt; 1, double &gt;</a>, <a class="el" href="classVNL_1_1VectorFixed.html#a8f5960396ab52ca1cd3b1575800b6533">VNL::VectorFixed&lt; 2, double &gt;</a>, <a class="el" href="classVNL_1_1VectorFixed.html#a8f5960396ab52ca1cd3b1575800b6533">VNL::VectorFixed&lt; 3, double &gt;</a>, and <a class="el" href="classVNL_1_1VectorFixed.html#a8f5960396ab52ca1cd3b1575800b6533">VNL::VectorFixed&lt; 3, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a42afb531a77f5d662b852b883708c669"></a><!-- doxytag: member="VNL::Vector::operator&#45;" ref="a42afb531a77f5d662b852b883708c669" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unary minus operator. </p>
<p>Creates new vector containing the negation of THIS vector. O(n).</p>
<p>Return new vector = -1*(*this) </p>

<p>Reimplemented in <a class="el" href="classVNL_1_1VectorFixed.html#aa9d73e356f1a5d659826d87f3fcbdcba">VNL::VectorFixed&lt; n, T &gt;</a>, <a class="el" href="classVNL_1_1VectorFixed.html#aa9d73e356f1a5d659826d87f3fcbdcba">VNL::VectorFixed&lt; 1, double &gt;</a>, <a class="el" href="classVNL_1_1VectorFixed.html#aa9d73e356f1a5d659826d87f3fcbdcba">VNL::VectorFixed&lt; 2, double &gt;</a>, <a class="el" href="classVNL_1_1VectorFixed.html#aa9d73e356f1a5d659826d87f3fcbdcba">VNL::VectorFixed&lt; 3, double &gt;</a>, and <a class="el" href="classVNL_1_1VectorFixed.html#aa9d73e356f1a5d659826d87f3fcbdcba">VNL::VectorFixed&lt; 3, T &gt;</a>.</p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>.</p>

</div>
</div>
<a class="anchor" id="a1b70955ee67fd6bed2f98399c95d1092"></a><!-- doxytag: member="VNL::Vector::operator&#45;=" ref="a1b70955ee67fd6bed2f98399c95d1092" args="(Vector&lt; T &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract rhs from this and return *this. </p>
<p>Mutates lhs vector with its substraction with rhs vector. O(n). </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00036">VNL::ErrorVectorDimension()</a>, and <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>.</p>

</div>
</div>
<a class="anchor" id="af176a58ea5236f88a346730bdb363aca"></a><!-- doxytag: member="VNL::Vector::operator&#45;=" ref="af176a58ea5236f88a346730bdb363aca" args="(T)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract scalar value from all elements. </p>

<p>Reimplemented in <a class="el" href="classVNL_1_1VectorFixedRef.html#afe6d44bbfb3401e7b4c8b9cf8a79b6ca">VNL::VectorFixedRef&lt; n, T &gt;</a>, and <a class="el" href="classVNL_1_1VectorFixedRef.html#afe6d44bbfb3401e7b4c8b9cf8a79b6ca">VNL::VectorFixedRef&lt; n, double &gt;</a>.</p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>.</p>

</div>
</div>
<a class="anchor" id="a052cd95caaa8afa71f5b91ba92e95c3f"></a><!-- doxytag: member="VNL::Vector::operator/" ref="a052cd95caaa8afa71f5b91ba92e95c3f" args="(T v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt;T&gt; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classVNL_1_1VectorFixed.html#a1ac6131a53bb10a5e8086da07e0fa4f2">VNL::VectorFixed&lt; n, T &gt;</a>, <a class="el" href="classVNL_1_1VectorFixed.html#a1ac6131a53bb10a5e8086da07e0fa4f2">VNL::VectorFixed&lt; 1, double &gt;</a>, <a class="el" href="classVNL_1_1VectorFixed.html#a1ac6131a53bb10a5e8086da07e0fa4f2">VNL::VectorFixed&lt; 2, double &gt;</a>, <a class="el" href="classVNL_1_1VectorFixed.html#a1ac6131a53bb10a5e8086da07e0fa4f2">VNL::VectorFixed&lt; 3, double &gt;</a>, and <a class="el" href="classVNL_1_1VectorFixed.html#a1ac6131a53bb10a5e8086da07e0fa4f2">VNL::VectorFixed&lt; 3, T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab54a3ec94a59ecb76a5762225f140b72"></a><!-- doxytag: member="VNL::Vector::operator/=" ref="ab54a3ec94a59ecb76a5762225f140b72" args="(T)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Divide all elements by scalar. </p>
<p>Divides all elements of vector by value. O(n). </p>

<p>Reimplemented in <a class="el" href="classVNL_1_1VectorFixedRef.html#ad32d8006865d3358c6d00c90d0b35b99">VNL::VectorFixedRef&lt; n, T &gt;</a>, and <a class="el" href="classVNL_1_1VectorFixedRef.html#ad32d8006865d3358c6d00c90d0b35b99">VNL::VectorFixedRef&lt; n, double &gt;</a>.</p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>.</p>

</div>
</div>
<a class="anchor" id="a4b6a9d13e22959f46646c2ba1f3245e8"></a><!-- doxytag: member="VNL::Vector::operator=" ref="a4b6a9d13e22959f46646c2ba1f3245e8" args="(Vector&lt; T &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy operator. </p>
<p>Copies rhs vector into lhs vector. O(n).</p>
<p>Changes the dimension of lhs vector if necessary. </p>

<p>Reimplemented in <a class="el" href="classVNL_1_1VectorFixed.html#acab282a4099e1f2ede394e76d3bdd678">VNL::VectorFixed&lt; n, T &gt;</a>, and <a class="el" href="classVW_1_1Line2D.html#ad5da5c5d0d755022df55d174882f35a2">VW::Line2D</a>.</p>

<p>References <a class="el" href="vector_8tpp_source.html#l00276">VNL::Vector&lt; T &gt;::Clear()</a>, <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>, <a class="el" href="vector_8tpp_source.html#l00286">VNL::Vector&lt; T &gt;::Resize()</a>, and <a class="el" href="vector_8h_source.html#l00142">VNL::Vector&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="ae9171add4ccd20836bdeadf12704862f"></a><!-- doxytag: member="VNL::Vector::operator=" ref="ae9171add4ccd20836bdeadf12704862f" args="(T const &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt;T&gt;&amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set all elements to value v. </p>

<p>Reimplemented in <a class="el" href="classVNL_1_1VectorFixedRef.html#a858d03ffff9e3f215409a5524d8d2799">VNL::VectorFixedRef&lt; n, T &gt;</a>, and <a class="el" href="classVNL_1_1VectorFixedRef.html#a858d03ffff9e3f215409a5524d8d2799">VNL::VectorFixedRef&lt; n, double &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a41d2f96b37b639c5842ac68b2f3f6909"></a><!-- doxytag: member="VNL::Vector::operator==" ref="a41d2f96b37b639c5842ac68b2f3f6909" args="(Vector&lt; T &gt; const &amp;that) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equality test. </p>

</div>
</div>
<a class="anchor" id="a5ae76bbf564b3942ce14edaaaf4807df"></a><!-- doxytag: member="VNL::Vector::operator[]" ref="a5ae76bbf564b3942ce14edaaaf4807df" args="(unsigned int i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T const&amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return reference to the element at specified index. No range checking. </p>

</div>
</div>
<a class="anchor" id="ac715ac6865b17dcd83786ab0ac7e59ab"></a><!-- doxytag: member="VNL::Vector::operator[]" ref="ac715ac6865b17dcd83786ab0ac7e59ab" args="(unsigned int i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return reference to the element at specified index. No range checking. </p>

</div>
</div>
<a class="anchor" id="a22c75af57a7e97e8c8fa6c996083c5b7"></a><!-- doxytag: member="VNL::Vector::operator_eq" ref="a22c75af57a7e97e8c8fa6c996083c5b7" args="(Vector&lt; T &gt; const &amp;v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::operator_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if *this == v. </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8h_source.html#l00142">VNL::Vector&lt; T &gt;::size()</a>.</p>

<p>Referenced by <a class="el" href="vector_8h_source.html#l00448">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::operator!=()</a>, and <a class="el" href="vector_8h_source.html#l00444">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="a1b6d973a2c4b63e1338a369728874040"></a><!-- doxytag: member="VNL::Vector::PostMultiply" ref="a1b6d973a2c4b63e1338a369728874040" args="(Matrix&lt; T &gt; const &amp;M)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::PostMultiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>*this = (*this)*M where M is a suitable matrix. </p>
<p>Post-multiplies vector with matrix and stores result back in vector.</p>
<p>this is treated as a row vector</p>
<p>v = v * m. O(m*n). <a class="el" href="classVNL_1_1Vector.html" title="Mathematical vector class, templated by type of element.">Vector</a> is assumed a row matrix. </p>

<p>Reimplemented in <a class="el" href="classVNL_1_1VectorFixedRef.html#abe7284ec6211f6717c55d998f4d205c6">VNL::VectorFixedRef&lt; n, T &gt;</a>, and <a class="el" href="classVNL_1_1VectorFixedRef.html#abe7284ec6211f6717c55d998f4d205c6">VNL::VectorFixedRef&lt; n, double &gt;</a>.</p>

<p>References <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00036">VNL::ErrorVectorDimension()</a>, <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>, and <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>.</p>

<p>Referenced by <a class="el" href="vector_8h_source.html#l00249">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::operator*=()</a>.</p>

</div>
</div>
<a class="anchor" id="a35c9b0ff6dea8426a2ad8843b32bb802"></a><!-- doxytag: member="VNL::Vector::PreMultiply" ref="a35c9b0ff6dea8426a2ad8843b32bb802" args="(Matrix&lt; T &gt; const &amp;M)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::PreMultiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>*this = M*(*this) where M is a suitable matrix. </p>
<p>Pre-multiplies vector with matrix and stores result back in vector.</p>
<p>this is treated as a column vector</p>
<p>v = m * v. O(m*n). <a class="el" href="classVNL_1_1Vector.html" title="Mathematical vector class, templated by type of element.">Vector</a> is assumed a column matrix. </p>

<p>Reimplemented in <a class="el" href="classVNL_1_1VectorFixedRef.html#afae1ea53685ff74df179000611814eae">VNL::VectorFixedRef&lt; n, T &gt;</a>, and <a class="el" href="classVNL_1_1VectorFixedRef.html#afae1ea53685ff74df179000611814eae">VNL::VectorFixedRef&lt; n, double &gt;</a>.</p>

<p>References <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="error_8cpp_source.html#l00036">VNL::ErrorVectorDimension()</a>, <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>, and <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>.</p>

</div>
</div>
<a class="anchor" id="a317cf202a66ff5b25207db18443055a7"></a><!-- doxytag: member="VNL::Vector::Put" ref="a317cf202a66ff5b25207db18443055a7" args="(unsigned int i, T const &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Put </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Put value at given position in vector. </p>
<p>Puts the value at specified index. O(1).</p>
<p>Range check is performed. </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>.</p>

</div>
</div>
<a class="anchor" id="a83f80a7e43c1beece9924c034eee3924"></a><!-- doxytag: member="VNL::Vector::Read" ref="a83f80a7e43c1beece9924c034eee3924" args="(std::istream &amp;s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read from text stream. </p>

<p>References <a class="el" href="vector_8tpp_source.html#l00313">VNL::Vector&lt; T &gt;::ReadASCII()</a>.</p>

</div>
</div>
<a class="anchor" id="aa4d736dc3fcb2e0251fe77160c8582f0"></a><!-- doxytag: member="VNL::Vector::ReadASCII" ref="aa4d736dc3fcb2e0251fe77160c8582f0" args="(std::istream &amp;s)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::ReadASCII </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read from text stream. </p>
<p>Read a <a class="el" href="classVNL_1_1Vector.html" title="Mathematical vector class, templated by type of element.">VNL::Vector</a> from an ascii std::istream.</p>
<p>If the vector has nonzero size on input, read that many values. Otherwise, read to EOF. </p>

<p>Reimplemented in <a class="el" href="classVW_1_1Line2D.html#a9ff3060c6ca3410b2d0a014235bb42eb">VW::Line2D</a>.</p>

<p>References <a class="el" href="vector_8tpp_source.html#l00286">VNL::Vector&lt; T &gt;::Resize()</a>, and <a class="el" href="vector_8h_source.html#l00142">VNL::Vector&lt; T &gt;::size()</a>.</p>

<p>Referenced by <a class="el" href="filevector_8tpp_source.html#l00018">VNL::FileVector&lt; T &gt;::FileVector()</a>, <a class="el" href="vector_8tpp_source.html#l00865">VNL::operator&gt;&gt;()</a>, and <a class="el" href="vector_8tpp_source.html#l00341">VNL::Vector&lt; T &gt;::Read()</a>.</p>

</div>
</div>
<a class="anchor" id="ac03c16e02173ddc1d99b7c386b968112"></a><!-- doxytag: member="VNL::Vector::Resize" ref="ac03c16e02173ddc1d99b7c386b968112" args="(unsigned n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Resize </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>n</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize to n elements. </p>
<p>Checks early and does nothing if already size n, otherwise old data is discarded. Returns true if size change successful. </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>, <a class="el" href="vector_8tpp_source.html#l00052">vnl_vector_alloc_blah</a>, and <a class="el" href="vector_8tpp_source.html#l00059">vnl_vector_free_blah</a>.</p>

<p>Referenced by <a class="el" href="binary_8cpp_source.html#l00036">VNL::BinaryLoad()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00427">VNL::SparseMatrix&lt; T &gt;::diag_AtA()</a>, <a class="el" href="matlabread_8cpp_source.html#l00191">VNL::MatlabReadOrDie()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00238">VNL::SparseMatrix&lt; T &gt;::mult()</a>, <a class="el" href="vector_8tpp_source.html#l00380">VNL::Vector&lt; T &gt;::operator=()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00265">VNL::SparseMatrix&lt; T &gt;::pre_mult()</a>, and <a class="el" href="vector_8tpp_source.html#l00313">VNL::Vector&lt; T &gt;::ReadASCII()</a>.</p>

</div>
</div>
<a class="anchor" id="ac5f032f7fb83347f62747163137eace5"></a><!-- doxytag: member="VNL::Vector::RMS" ref="ac5f032f7fb83347f62747163137eace5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html#a3c3820b75a4a85f62604a425ff8ec66b">abs_t</a> <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::RMS </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Root Mean Squares of values. </p>

<p>Referenced by <a class="el" href="parametricflow_8cpp_source.html#l00409">VW::ParametricFlowFunc&lt; Type &gt;::F()</a>, <a class="el" href="linearsystem_8cpp_source.html#l00038">VNL::LinearSystem::GetRelativeResidual()</a>, <a class="el" href="linearsystem_8cpp_source.html#l00025">VNL::LinearSystem::GetRMSError()</a>, <a class="el" href="levenbergmarquardt_8cpp_source.html#l00234">VNL::LevenbergMarquardt::lmder_lsqfun()</a>, <a class="el" href="levenbergmarquardt_8cpp_source.html#l00093">VNL::LevenbergMarquardt::lmdif_lsqfun()</a>, <a class="el" href="levenbergmarquardt_8cpp_source.html#l00276">VNL::LevenbergMarquardt::MinimizeUsingGradient()</a>, <a class="el" href="levenbergmarquardt_8cpp_source.html#l00145">VNL::LevenbergMarquardt::MinimizeWithoutGradient()</a>, and <a class="el" href="leastsquaresfunction_8cpp_source.html#l00113">VNL::LeastSquaresFunction::RMS()</a>.</p>

</div>
</div>
<a class="anchor" id="aaaee517447bf89ddf1c60eea4fef1e17"></a><!-- doxytag: member="VNL::Vector::Set" ref="aaaee517447bf89ddf1c60eea4fef1e17" args="(T const *ptr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Set </td>
          <td>(</td>
          <td class="paramtype">T const *&nbsp;</td>
          <td class="paramname"> <em>ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets elements to ptr[i]. </p>
<p>Note: ptr[i] must be valid for i=0..<a class="el" href="classVNL_1_1Vector.html#a31c3303fc4a4c5776fdf26d55ddaf0aa" title="Return the length, number of elements, dimension of this vector.">size()</a>-1 </p>

</div>
</div>
<a class="anchor" id="a50587da2087e6693eac7791df2def5c1"></a><!-- doxytag: member="VNL::Vector::Size" ref="a50587da2087e6693eac7791df2def5c1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the length, number of elements, dimension of this vector. </p>

<p>Referenced by <a class="el" href="fastops_8cpp_source.html#l00130">vnl_fastops::AtB()</a>, <a class="el" href="matops_8cpp_source.html#l00034">vnl_matops::cat()</a>, <a class="el" href="fastops_8cpp_source.html#l00271">vnl_fastops::inc_X_by_AtB()</a>, <a class="el" href="vector_8h_source.html#l00590">VNL::Project()</a>, and <a class="el" href="vector_8h_source.html#l00604">VNL::Unproject()</a>.</p>

</div>
</div>
<a class="anchor" id="a31c3303fc4a4c5776fdf26d55ddaf0aa"></a><!-- doxytag: member="VNL::Vector::size" ref="a31c3303fc4a4c5776fdf26d55ddaf0aa" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the length, number of elements, dimension of this vector. </p>

<p>Referenced by <a class="el" href="vector_8tpp_source.html#l00642">VNL::Vector&lt; T &gt;::Apply()</a>, <a class="el" href="sparsematrixlinearsystem_8cpp_source.html#l00067">VNL::SparseMatrixLinearSystem&lt; T &gt;::ApplyPreconditioner()</a>, <a class="el" href="linearsystem_8cpp_source.html#l00018">VNL::LinearSystem::ApplyPreconditioner()</a>, <a class="el" href="vector_8tpp_source.html#l00826">VNL::Vector&lt; T &gt;::assert_size_internal()</a>, <a class="el" href="fastops_8cpp_source.html#l00130">vnl_fastops::AtB()</a>, <a class="el" href="binary_8cpp_source.html#l00036">VNL::BinaryLoad()</a>, <a class="el" href="binary_8cpp_source.html#l00024">VNL::BinarySave()</a>, <a class="el" href="rpolyroots_8cpp_source.html#l00078">VNL::RPolyRoots::Compute()</a>, <a class="el" href="computefuncs_8h_source.html#l00034">VW::ComputeFuncs::ConvertParamVectorToTransform()</a>, <a class="el" href="convolve_8tpp_source.html#l00096">VNL::Convolve()</a>, <a class="el" href="convolve_8tpp_source.html#l00041">VNL::ConvolveCyclic()</a>, <a class="el" href="convolve_8tpp_source.html#l00013">VNL::ConvolveCyclicUsingFFT()</a>, <a class="el" href="convolve_8tpp_source.html#l00078">VNL::ConvolveUsingFFT()</a>, <a class="el" href="cpolyroots_8cpp_source.html#l00033">VNL::CPolyRoots::CPolyRoots()</a>, <a class="el" href="realpolynomial_8h_source.html#l00100">VNL::RealPolynomial::Degree()</a>, <a class="el" href="realnpolynomial_8h_source.html#l00084">VNL::RealNPolynomial::Degree()</a>, <a class="el" href="amoeba_8cpp_source.html#l00289">VNL::AmoebaFit::DoAmoeba()</a>, <a class="el" href="realpolynomial_8cpp_source.html#l00073">VNL::RealPolynomial::Evaluate()</a>, <a class="el" href="realpolynomial_8cpp_source.html#l00115">VNL::RealPolynomial::EvaluateIntegral()</a>, <a class="el" href="leastsquaresfunction_8cpp_source.html#l00075">VNL::LeastSquaresFunction::FDGradF()</a>, <a class="el" href="generalizedschur_8h_source.html#l00047">VNL::GeneralizedSchur()</a>, <a class="el" href="vector_8h_source.html#l00342">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::InfNorm()</a>, <a class="el" href="powell_8cpp_source.html#l00037">VNL::Powell1DFun::Init()</a>, <a class="el" href="vector_8tpp_source.html#l00796">VNL::Vector&lt; T &gt;::IsFinite()</a>, <a class="el" href="vector_8tpp_source.html#l00805">VNL::Vector&lt; T &gt;::IsZero()</a>, <a class="el" href="line2d_8h_source.html#l00179">VW::Line2D::Line2D()</a>, <a class="el" href="matlabprint_8tpp_source.html#l00099">VNL::MatlabPrint()</a>, <a class="el" href="matlabread_8cpp_source.html#l00191">VNL::MatlabReadOrDie()</a>, <a class="el" href="vector_8h_source.html#l00361">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::MaxValue()</a>, <a class="el" href="vector_8h_source.html#l00365">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::Mean()</a>, <a class="el" href="powell_8cpp_source.html#l00065">VNL::Powell::Minimize()</a>, <a class="el" href="lbfgs_8cpp_source.html#l00083">VNL::LBFGS::Minimize()</a>, <a class="el" href="levenbergmarquardt_8cpp_source.html#l00276">VNL::LevenbergMarquardt::MinimizeUsingGradient()</a>, <a class="el" href="levenbergmarquardt_8cpp_source.html#l00145">VNL::LevenbergMarquardt::MinimizeWithoutGradient()</a>, <a class="el" href="vector_8h_source.html#l00357">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::MinValue()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00238">VNL::SparseMatrix&lt; T &gt;::mult()</a>, <a class="el" href="sparsematrixlinearsystem_8cpp_source.html#l00051">VNL::SparseMatrixLinearSystem&lt; T &gt;::Multiply()</a>, <a class="el" href="vector_8h_source.html#l00346">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::Normalize()</a>, <a class="el" href="vector_8h_source.html#l00334">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::OneNorm()</a>, <a class="el" href="vector_8h_source.html#l00179">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::operator()()</a>, <a class="el" href="vector_8tpp_source.html#l00853">VNL::operator&lt;&lt;()</a>, <a class="el" href="vectorfixed_8h_source.html#l00125">VNL::VectorFixed&lt; 3, T &gt;::operator=()</a>, <a class="el" href="vector_8tpp_source.html#l00380">VNL::Vector&lt; T &gt;::operator=()</a>, <a class="el" href="vector_8tpp_source.html#l00834">VNL::Vector&lt; T &gt;::operator_eq()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00265">VNL::SparseMatrix&lt; T &gt;::pre_mult()</a>, <a class="el" href="vector_8tpp_source.html#l00313">VNL::Vector&lt; T &gt;::ReadASCII()</a>, <a class="el" href="realnpolynomial_8cpp_source.html#l00036">VNL::RealNPolynomial::RealNPolynomial()</a>, <a class="el" href="fmatrixcomputenonlinear_8cpp_source.html#l00068">VW::FMatrixCompute::ReconstructTransform()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00094">VW::FMPlanarCompute::ReconstructTransformHZ()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00302">VW::FMPlanarCompute::ReconstructTransformHZJK()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00190">VW::FMPlanarCompute::ReconstructTransformVLJK()</a>, <a class="el" href="vector_8h_source.html#l00353">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::RMS()</a>, <a class="el" href="symmatrix_8tpp_source.html#l00067">VNL::SymMatrix&lt; T &gt;::SetHalfRow()</a>, <a class="el" href="amoeba_8cpp_source.html#l00242">VNL::AmoebaFit::SetUpSimplexAbsolute()</a>, <a class="el" href="amoeba_8cpp_source.html#l00214">VNL::AmoebaFit::SetUpSimplexRelative()</a>, <a class="el" href="symmetriceigensystem_8cpp_source.html#l00102">VNL::SymmetricEigensystem&lt; T &gt;::Solve()</a>, <a class="el" href="svd_8tpp_source.html#l00325">VNL::SVD&lt; T &gt;::Solve()</a>, <a class="el" href="cholesky_8tpp_source.html#l00084">VNL::Cholesky&lt; T &gt;::Solve()</a>, <a class="el" href="svd_8tpp_source.html#l00370">VNL::SVD&lt; T &gt;::SolvePreinverted()</a>, <a class="el" href="vector_8h_source.html#l00326">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::SquaredMagnitude()</a>, <a class="el" href="vector_8h_source.html#l00369">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::Sum()</a>, <a class="el" href="symmetriceigensystem_8cpp_source.html#l00020">VNL::SymmetricEigensystemCompute()</a>, <a class="el" href="sparsematrixlinearsystem_8cpp_source.html#l00030">VNL::SparseMatrixLinearSystem&lt; T &gt;::TransposeMultiply()</a>, <a class="el" href="vector_8h_source.html#l00338">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::TwoNorm()</a>, <a class="el" href="vector_8tpp_source.html#l00178">VNL::Vector&lt; T &gt;::Vector()</a>, <a class="el" href="vectorfixed_8h_source.html#l00077">VNL::VectorFixed&lt; 3, T &gt;::VectorFixed()</a>, <a class="el" href="vectorfixedref_8h_source.html#l00028">VNL::VectorFixedRef&lt; n, double &gt;::VectorFixedRef()</a>, <a class="el" href="vectorref_8h_source.html#l00050">VNL::VectorRef&lt; double &gt;::VectorRef()</a>, <a class="el" href="vector_8h_source.html#l00576">VNL::VectorSSD()</a>, <a class="el" href="complexops_8tpp_source.html#l00033">vnl_complexify()</a>, <a class="el" href="discretediff_8cpp_source.html#l00034">vnl_discrete_diff_fwd()</a>, <a class="el" href="discretediff_8cpp_source.html#l00072">vnl_discrete_diff_sym()</a>, <a class="el" href="discretediff_8cpp_source.html#l00108">vnl_discrete_diff_test_lsf()</a>, <a class="el" href="gaussiankernel1d_8cpp_source.html#l00030">vnl_gaussian_kernel_1d::vnl_gaussian_kernel_1d()</a>, <a class="el" href="orthogonalcomplement_8tpp_source.html#l00011">vnl_orthogonal_complement()</a>, <a class="el" href="gaussiankernel1d_8h_source.html#l00036">vnl_gaussian_kernel_1d::width()</a>, and <a class="el" href="matlabfilewrite_8cpp_source.html#l00050">VNL::MatlabFilewrite::Write()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ba286c6da411acd5593e01efe8f0ae6"></a><!-- doxytag: member="VNL::Vector::SquaredMagnitude" ref="a5ba286c6da411acd5593e01efe8f0ae6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html#a3c3820b75a4a85f62604a425ff8ec66b">abs_t</a> <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::SquaredMagnitude </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return sum of squares of elements. </p>

<p>Referenced by <a class="el" href="leastsquarescostfunction_8cpp_source.html#l00024">VNL::LeastSquaresCostFunction::F()</a>.</p>

</div>
</div>
<a class="anchor" id="a31efc659d2fac19c15fffd247eb5e742"></a><!-- doxytag: member="VNL::Vector::Sum" ref="a31efc659d2fac19c15fffd247eb5e742" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Sum </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sum of values in a vector. </p>

<p>Referenced by <a class="el" href="vector_8h_source.html#l00369">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::Sum()</a>.</p>

</div>
</div>
<a class="anchor" id="af04323fccad418242258b09a15190781"></a><!-- doxytag: member="VNL::Vector::Swap" ref="af04323fccad418242258b09a15190781" args="(Vector&lt; T &gt; &amp;that)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this to that and that to this. </p>

<p>References <a class="el" href="vector_8h_source.html#l00472">VNL::Vector&lt; T &gt;::data</a>, and <a class="el" href="vector_8h_source.html#l00471">VNL::Vector&lt; T &gt;::num_elmts</a>.</p>

</div>
</div>
<a class="anchor" id="ae84fadf45db6bc192fe0763f96dd031b"></a><!-- doxytag: member="VNL::Vector::t" ref="ae84fadf45db6bc192fe0763f96dd031b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::t </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return fourth element of vector. </p>

</div>
</div>
<a class="anchor" id="a9915007a118ebd20be88e36ab61de2b6"></a><!-- doxytag: member="VNL::Vector::TwoNorm" ref="a9915007a118ebd20be88e36ab61de2b6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html#a3c3820b75a4a85f62604a425ff8ec66b">abs_t</a> <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::TwoNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return sqrt of sum of squares of values of elements. </p>

<p>Referenced by <a class="el" href="vector_8h_source.html#l00330">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::Magnitude()</a>, and <a class="el" href="vector_8h_source.html#l00338">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::TwoNorm()</a>.</p>

</div>
</div>
<a class="anchor" id="a4c45bc78444fbabf8e5ddf82e2b64381"></a><!-- doxytag: member="VNL::Vector::Update" ref="a4c45bc78444fbabf8e5ddf82e2b64381" args="(Vector&lt; T &gt; const &amp;, unsigned int start=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt;T&gt;&amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::Update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>start</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces elements with index begining at start, by values of v. O(n). </p>

<p>Referenced by <a class="el" href="svd_8tpp_source.html#l00325">VNL::SVD&lt; T &gt;::Solve()</a>.</p>

</div>
</div>
<a class="anchor" id="a29d01653414a6c0f4c98d2a3d18ab910"></a><!-- doxytag: member="VNL::Vector::x" ref="a29d01653414a6c0f4c98d2a3d18ab910" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::x </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return first element of vector. </p>

</div>
</div>
<a class="anchor" id="acecd5172ceb9461c5d69013d667b91a5"></a><!-- doxytag: member="VNL::Vector::y" ref="acecd5172ceb9461c5d69013d667b91a5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::y </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return second element of vector. </p>

</div>
</div>
<a class="anchor" id="aa4cc062fb4afb06e122b6586be8d2bae"></a><!-- doxytag: member="VNL::Vector::z" ref="aa4cc062fb4afb06e122b6586be8d2bae" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::z </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return third element of vector. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a17fc06682c9f9c46f1e0e38b7af25b80"></a><!-- doxytag: member="VNL::Vector::Matrix&lt; T &gt;" ref="a17fc06682c9f9c46f1e0e38b7af25b80" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;<code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aac3e0552745ea3fdb6b84cf211578583"></a><!-- doxytag: member="VNL::Vector::data" ref="aac3e0552745ea3fdb6b84cf211578583" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html#aac3e0552745ea3fdb6b84cf211578583">data</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="vectorfixed_8h_source.html#l00134">VNL::VectorFixed&lt; 3, T &gt;::Apply()</a>, <a class="el" href="vector_8tpp_source.html#l00642">VNL::Vector&lt; T &gt;::Apply()</a>, <a class="el" href="vector_8h_source.html#l00290">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::begin()</a>, <a class="el" href="vector_8tpp_source.html#l00276">VNL::Vector&lt; T &gt;::Clear()</a>, <a class="el" href="vector_8tpp_source.html#l00361">VNL::Vector&lt; T &gt;::CopyIn()</a>, <a class="el" href="vector_8tpp_source.html#l00370">VNL::Vector&lt; T &gt;::CopyOut()</a>, <a class="el" href="vector_8h_source.html#l00275">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::DataBlock()</a>, <a class="el" href="vector_8h_source.html#l00294">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::end()</a>, <a class="el" href="vector_8tpp_source.html#l00352">VNL::Vector&lt; T &gt;::Fill()</a>, <a class="el" href="vector_8tpp_source.html#l00751">VNL::Vector&lt; T &gt;::Flip()</a>, <a class="el" href="vector_8h_source.html#l00513">VNL::Vector&lt; T &gt;::Get()</a>, <a class="el" href="vector_8h_source.html#l00436">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::IsEmpty()</a>, <a class="el" href="vector_8h_source.html#l00179">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::operator()()</a>, <a class="el" href="vector_8tpp_source.html#l00417">VNL::Vector&lt; T &gt;::operator*=()</a>, <a class="el" href="vector_8tpp_source.html#l00400">VNL::Vector&lt; T &gt;::operator+=()</a>, <a class="el" href="vector_8tpp_source.html#l00517">VNL::Vector&lt; T &gt;::operator-()</a>, <a class="el" href="vector_8tpp_source.html#l00407">VNL::Vector&lt; T &gt;::operator-=()</a>, <a class="el" href="vector_8tpp_source.html#l00427">VNL::Vector&lt; T &gt;::operator/=()</a>, <a class="el" href="vector_8tpp_source.html#l00380">VNL::Vector&lt; T &gt;::operator=()</a>, <a class="el" href="vector_8h_source.html#l00199">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::operator[]()</a>, <a class="el" href="vector_8tpp_source.html#l00834">VNL::Vector&lt; T &gt;::operator_eq()</a>, <a class="el" href="vector_8tpp_source.html#l00494">VNL::Vector&lt; T &gt;::PostMultiply()</a>, <a class="el" href="vector_8tpp_source.html#l00470">VNL::Vector&lt; T &gt;::PreMultiply()</a>, <a class="el" href="vector_8h_source.html#l00526">VNL::Vector&lt; T &gt;::Put()</a>, <a class="el" href="vector_8tpp_source.html#l00286">VNL::Vector&lt; T &gt;::Resize()</a>, <a class="el" href="vector_8tpp_source.html#l00760">VNL::Vector&lt; T &gt;::Swap()</a>, <a class="el" href="vector_8h_source.html#l00391">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::t()</a>, <a class="el" href="vector_8tpp_source.html#l00079">VNL::Vector&lt; T &gt;::Vector()</a>, <a class="el" href="vector_8h_source.html#l00130">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::Vector()</a>, <a class="el" href="vectorfixed_8h_source.html#l00094">VNL::VectorFixed&lt; 3, T &gt;::VectorFixed()</a>, <a class="el" href="vectorref_8h_source.html#l00041">VNL::VectorRef&lt; double &gt;::VectorRef()</a>, <a class="el" href="vector_8h_source.html#l00382">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::x()</a>, <a class="el" href="vector_8h_source.html#l00385">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::y()</a>, <a class="el" href="vector_8h_source.html#l00388">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::z()</a>, <a class="el" href="vector_8h_source.html#l00138">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::~Vector()</a>, and <a class="el" href="vectorref_8h_source.html#l00058">VNL::VectorRef&lt; double &gt;::~VectorRef()</a>.</p>

</div>
</div>
<a class="anchor" id="a36791cbcbbd3bcb8b0aab40b51724923"></a><!-- doxytag: member="VNL::Vector::num_elmts" ref="a36791cbcbbd3bcb8b0aab40b51724923" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;::<a class="el" href="classVNL_1_1Vector.html#a36791cbcbbd3bcb8b0aab40b51724923">num_elmts</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="vectorfixed_8h_source.html#l00134">VNL::VectorFixed&lt; 3, T &gt;::Apply()</a>, <a class="el" href="vector_8tpp_source.html#l00642">VNL::Vector&lt; T &gt;::Apply()</a>, <a class="el" href="vector_8tpp_source.html#l00276">VNL::Vector&lt; T &gt;::Clear()</a>, <a class="el" href="vector_8tpp_source.html#l00361">VNL::Vector&lt; T &gt;::CopyIn()</a>, <a class="el" href="vector_8tpp_source.html#l00370">VNL::Vector&lt; T &gt;::CopyOut()</a>, <a class="el" href="vector_8h_source.html#l00294">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::end()</a>, <a class="el" href="vector_8tpp_source.html#l00352">VNL::Vector&lt; T &gt;::Fill()</a>, <a class="el" href="vector_8tpp_source.html#l00751">VNL::Vector&lt; T &gt;::Flip()</a>, <a class="el" href="vector_8h_source.html#l00513">VNL::Vector&lt; T &gt;::Get()</a>, <a class="el" href="vector_8h_source.html#l00436">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::IsEmpty()</a>, <a class="el" href="vector_8tpp_source.html#l00417">VNL::Vector&lt; T &gt;::operator*=()</a>, <a class="el" href="vector_8tpp_source.html#l00400">VNL::Vector&lt; T &gt;::operator+=()</a>, <a class="el" href="vector_8tpp_source.html#l00517">VNL::Vector&lt; T &gt;::operator-()</a>, <a class="el" href="vector_8tpp_source.html#l00407">VNL::Vector&lt; T &gt;::operator-=()</a>, <a class="el" href="vector_8tpp_source.html#l00427">VNL::Vector&lt; T &gt;::operator/=()</a>, <a class="el" href="vector_8tpp_source.html#l00380">VNL::Vector&lt; T &gt;::operator=()</a>, <a class="el" href="vector_8tpp_source.html#l00494">VNL::Vector&lt; T &gt;::PostMultiply()</a>, <a class="el" href="vector_8tpp_source.html#l00470">VNL::Vector&lt; T &gt;::PreMultiply()</a>, <a class="el" href="vector_8h_source.html#l00526">VNL::Vector&lt; T &gt;::Put()</a>, <a class="el" href="vector_8tpp_source.html#l00286">VNL::Vector&lt; T &gt;::Resize()</a>, <a class="el" href="vector_8h_source.html#l00146">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::Size()</a>, <a class="el" href="vector_8h_source.html#l00142">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::size()</a>, <a class="el" href="vector_8tpp_source.html#l00760">VNL::Vector&lt; T &gt;::Swap()</a>, <a class="el" href="vector_8tpp_source.html#l00156">VNL::Vector&lt; T &gt;::Vector()</a>, <a class="el" href="vector_8h_source.html#l00130">VNL::Vector&lt; std::complex&lt; double &gt; &gt;::Vector()</a>, and <a class="el" href="vectorref_8h_source.html#l00041">VNL::VectorRef&lt; double &gt;::VectorRef()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="vector_8h_source.html">vector.h</a></li>
<li><a class="el" href="vector_8tpp.html">vector.tpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Mar 21 09:55:52 2010 for VW by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VW: VNL::SparseMatrix&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen_vw.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
  <div class="navpath"><a class="el" href="namespaceVNL.html">VNL</a>::<a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a>
  </div>
<div class="contents">
<h1>VNL::SparseMatrix&lt; T &gt; Class Template Reference</h1><!-- doxytag: class="VNL::SparseMatrix" -->
<p>Simple sparse matrix.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sparsematrix_8h_source.html">sparsematrix.h</a>&gt;</code></p>

<p><a href="classVNL_1_1SparseMatrix-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classVNL_1_1SparseMatrixPair.html">SparseMatrixPair</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#ae69f4c76b669ee08dcd9decf3a65582f">pair_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classVNL_1_1SparseMatrixPair.html">pair_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#af073ad395079f4e9200958f0f9d2ff27">row</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classVNL_1_1SparseMatrix.html#af073ad395079f4e9200958f0f9d2ff27">row</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a529997e154a1c32b0c611da0e1d88133">SparseMatrixElements</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#adaad27b86dfae95ee3c0751d75cd501e">SparseMatrix</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an empty matrix.  <a href="#adaad27b86dfae95ee3c0751d75cd501e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a0b8b961409eb30dad716ea951c273432">SparseMatrix</a> (unsigned int m, unsigned int n)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an empty m*n matrix.  <a href="#a0b8b961409eb30dad716ea951c273432"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a0422eeff206ea41c5a896f0d625e638d">SparseMatrix</a> (const <a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an m*n <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> and copy rhs into it.  <a href="#a0422eeff206ea41c5a896f0d625e638d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a4c32949cc911e7e848907913234fcdf2">operator=</a> (const <a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy another SparseMatrix&lt;T&gt; into this.  <a href="#a4c32949cc911e7e848907913234fcdf2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a4f3dd62e877222778c4b42256edf359c">mult</a> (<a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; const &amp;rhs, <a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; &amp;result) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply this*rhs, another sparse matrix.  <a href="#a4f3dd62e877222778c4b42256edf359c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a905d75ee16a924514a4177b9b76b4856">mult</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;rhs, <a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;result) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply this*rhs, where rhs is a vector.  <a href="#a905d75ee16a924514a4177b9b76b4856"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#ad18c1fc7b658354f0ff44175c621c659">mult</a> (unsigned int n, unsigned int m, T const *p, T *q) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply this*p, a fortran order matrix.  <a href="#ad18c1fc7b658354f0ff44175c621c659"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a1e28e8d9617d31b3583094f09477896e">pre_mult</a> (const <a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;lhs, <a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;result) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiplies lhs*this, where lhs is a vector.  <a href="#a1e28e8d9617d31b3583094f09477896e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a64df225e38ea496d30d639dd83027834">add</a> (const <a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; &amp;rhs, <a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; &amp;result) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add rhs to this.  <a href="#a64df225e38ea496d30d639dd83027834"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#ae71fc7cc72460fb60b711285415cd184">subtract</a> (const <a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; &amp;rhs, <a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; &amp;result) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract rhs from this.  <a href="#ae71fc7cc72460fb60b711285415cd184"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#ae697db78c70a50bb957f8fbfdf5bbd1b">operator()</a> (unsigned int <a class="el" href="classVNL_1_1SparseMatrix.html#af073ad395079f4e9200958f0f9d2ff27">row</a>, unsigned int column)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a reference to an entry in the matrix.  <a href="#ae697db78c70a50bb957f8fbfdf5bbd1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a92cda1841ce404af3c42015d0eeeb60b">diag_AtA</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;result) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get diag(A_tranpose * A).  <a href="#a92cda1841ce404af3c42015d0eeeb60b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#abe959d5a335c36fa529381c1bc8a9710">set_row</a> (unsigned int r, std::vector&lt; int &gt; const &amp;cols, std::vector&lt; T &gt; const &amp;vals)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a whole row at once. Much faster.  <a href="#abe959d5a335c36fa529381c1bc8a9710"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1SparseMatrix.html#af073ad395079f4e9200958f0f9d2ff27">row</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a5a3b1c6a597c2b17aef9f6b0520db089">get_row</a> (unsigned int r)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return row as vector of pairs.  <a href="#a5a3b1c6a597c2b17aef9f6b0520db089"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#aaa82352c66b7f599a44ca6b143d5131d">vcat</a> (<a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; const &amp;A)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Laminate matrix A onto the bottom of this one.  <a href="#aaa82352c66b7f599a44ca6b143d5131d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#afde720ae0439b585e54a55c435ffdcfb">rows</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of rows in the matrix.  <a href="#afde720ae0439b585e54a55c435ffdcfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a0e479803263a4e0d570a18f39db31c3e">columns</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of columns in the matrix.  <a href="#a0e479803263a4e0d570a18f39db31c3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#ab80287da9fc798fd98cbb7c2b1e88881">cols</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of columns in the matrix.  <a href="#ab80287da9fc798fd98cbb7c2b1e88881"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#aa9ae8ef37641f7d9a4dcf53136548a29">empty_row</a> (unsigned int r) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return whether a given row is empty.  <a href="#aa9ae8ef37641f7d9a4dcf53136548a29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a55613aa5459b152e1e8d3e2b328254b6">sum_row</a> (unsigned int r)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is occasionally useful.  <a href="#a55613aa5459b152e1e8d3e2b328254b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a2213ec5676471d8dc8e3c6b91976b33e">scale_row</a> (unsigned int r, T scale)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Useful for normalizing row sums in convolution operators.  <a href="#a2213ec5676471d8dc8e3c6b91976b33e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a7116d90be7b7bafd8c6a8542f989a644">resize</a> (int r, int c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resizes the array to have r rows and c cols.  <a href="#a7116d90be7b7bafd8c6a8542f989a644"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#aaa27fff601e433cbe970c2638dda8564">reset</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the internal iterator.  <a href="#aaa27fff601e433cbe970c2638dda8564"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a82dac03337af6ec7649b8ce2c1e36834">next</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Moves the internal iterator to next non-zero entry in matrix.  <a href="#a82dac03337af6ec7649b8ce2c1e36834"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#ae7620f63bbd8815b628d2a27f512e2c3">getrow</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the row of the entry pointed to by internal iterator.  <a href="#ae7620f63bbd8815b628d2a27f512e2c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a090a137d254ab4856dc424b6100ba8fb">getcolumn</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the column of the entry pointed to by internal iterator.  <a href="#a090a137d254ab4856dc424b6100ba8fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#aedba52d53920eca8593c12dc63e3119a">value</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value pointed to by the internal iterator.  <a href="#aedba52d53920eca8593c12dc63e3119a"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1SparseMatrix.html#a529997e154a1c32b0c611da0e1d88133">SparseMatrixElements</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a508a21b1d4a4d76b305729a1584f03d3">elements</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#abc9ad536f45d381f2bbab8bb84e53e1d">rs_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a282982989994fbdf6ff7667648bd5680">cs_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#aec27853b37d80b356cc905a12652485e">itr_row</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">row::iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#af03c7f481d4a41a20d1a983da286fea9">itr_cur</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SparseMatrix.html#a3fc0bfccdf55147d561a189aa739df61">itr_isreset</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br/>
 class VNL::SparseMatrix&lt; T &gt;</h3>

<p>Simple sparse matrix. </p>
<p>Stores non-zero elements as a sparse_matrix_pair </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ae69f4c76b669ee08dcd9decf3a65582f"></a><!-- doxytag: member="VNL::SparseMatrix::pair_t" ref="ae69f4c76b669ee08dcd9decf3a65582f" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classVNL_1_1SparseMatrixPair.html">SparseMatrixPair</a>&lt;T&gt; <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1SparseMatrixPair.html">pair_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af073ad395079f4e9200958f0f9d2ff27"></a><!-- doxytag: member="VNL::SparseMatrix::row" ref="af073ad395079f4e9200958f0f9d2ff27" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="classVNL_1_1SparseMatrixPair.html">pair_t</a> &gt; <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1SparseMatrix.html#af073ad395079f4e9200958f0f9d2ff27">row</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a529997e154a1c32b0c611da0e1d88133"></a><!-- doxytag: member="VNL::SparseMatrix::SparseMatrixElements" ref="a529997e154a1c32b0c611da0e1d88133" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="classVNL_1_1SparseMatrix.html#af073ad395079f4e9200958f0f9d2ff27">row</a> &gt; <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1SparseMatrix.html#a529997e154a1c32b0c611da0e1d88133">SparseMatrixElements</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adaad27b86dfae95ee3c0751d75cd501e"></a><!-- doxytag: member="VNL::SparseMatrix::SparseMatrix" ref="adaad27b86dfae95ee3c0751d75cd501e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct an empty matrix. </p>

</div>
</div>
<a class="anchor" id="a0b8b961409eb30dad716ea951c273432"></a><!-- doxytag: member="VNL::SparseMatrix::SparseMatrix" ref="a0b8b961409eb30dad716ea951c273432" args="(unsigned int m, unsigned int n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct an empty m*n matrix. </p>
<p>Construct an empty m*n matrix. There are m rows and n columns. </p>

</div>
</div>
<a class="anchor" id="a0422eeff206ea41c5a896f0d625e638d"></a><!-- doxytag: member="VNL::SparseMatrix::SparseMatrix" ref="a0422eeff206ea41c5a896f0d625e638d" args="(const SparseMatrix&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct an m*n <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> and copy rhs into it. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a64df225e38ea496d30d639dd83027834"></a><!-- doxytag: member="VNL::SparseMatrix::add" ref="a64df225e38ea496d30d639dd83027834" args="(const SparseMatrix&lt; T &gt; &amp;rhs, SparseMatrix&lt; T &gt; &amp;result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add rhs to this. </p>

<p>References <a class="el" href="sparsematrix_8h_source.html#l00180">VNL::SparseMatrix&lt; T &gt;::columns()</a>, <a class="el" href="sparsematrix_8h_source.html#l00228">VNL::SparseMatrix&lt; T &gt;::cs_</a>, <a class="el" href="sparsematrix_8h_source.html#l00227">VNL::SparseMatrix&lt; T &gt;::elements</a>, <a class="el" href="sparsematrix_8h_source.html#l00188">VNL::SparseMatrix&lt; T &gt;::empty_row()</a>, <a class="el" href="sparsematrix_8h_source.html#l00061">VNL::SparseMatrixPair&lt; T &gt;::first</a>, <a class="el" href="sparsematrix_8h_source.html#l00176">VNL::SparseMatrix&lt; T &gt;::rows()</a>, <a class="el" href="sparsematrix_8h_source.html#l00228">VNL::SparseMatrix&lt; T &gt;::rs_</a>, and <a class="el" href="sparsematrix_8h_source.html#l00062">VNL::SparseMatrixPair&lt; T &gt;::second</a>.</p>

</div>
</div>
<a class="anchor" id="ab80287da9fc798fd98cbb7c2b1e88881"></a><!-- doxytag: member="VNL::SparseMatrix::cols" ref="ab80287da9fc798fd98cbb7c2b1e88881" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::cols </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of columns in the matrix. </p>

</div>
</div>
<a class="anchor" id="a0e479803263a4e0d570a18f39db31c3e"></a><!-- doxytag: member="VNL::SparseMatrix::columns" ref="a0e479803263a4e0d570a18f39db31c3e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::columns </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of columns in the matrix. </p>

<p>Referenced by <a class="el" href="sparsematrix_8tpp_source.html#l00303">VNL::SparseMatrix&lt; T &gt;::add()</a>, <a class="el" href="sparsesymmetriceigensystem_8cpp_source.html#l00076">VNL::SparseSymmetricEigensystem::CalculateNPairs()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00427">VNL::SparseMatrix&lt; T &gt;::diag_AtA()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00070">VNL::SparseMatrix&lt; T &gt;::mult()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00411">VNL::SparseMatrix&lt; T &gt;::operator()()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00265">VNL::SparseMatrix&lt; T &gt;::pre_mult()</a>, and <a class="el" href="sparsematrix_8tpp_source.html#l00357">VNL::SparseMatrix&lt; T &gt;::subtract()</a>.</p>

</div>
</div>
<a class="anchor" id="a92cda1841ce404af3c42015d0eeeb60b"></a><!-- doxytag: member="VNL::SparseMatrix::diag_AtA" ref="a92cda1841ce404af3c42015d0eeeb60b" args="(Vector&lt; T &gt; &amp;result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::diag_AtA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get diag(A_tranpose * A). </p>
<p>Useful for forming Jacobi preconditioners for linear solvers. </p>

<p>References <a class="el" href="sparsematrix_8h_source.html#l00180">VNL::SparseMatrix&lt; T &gt;::columns()</a>, <a class="el" href="sparsematrix_8h_source.html#l00227">VNL::SparseMatrix&lt; T &gt;::elements</a>, <a class="el" href="vector_8tpp_source.html#l00352">VNL::Vector&lt; T &gt;::Fill()</a>, <a class="el" href="sparsematrix_8h_source.html#l00061">VNL::SparseMatrixPair&lt; T &gt;::first</a>, <a class="el" href="vector_8tpp_source.html#l00286">VNL::Vector&lt; T &gt;::Resize()</a>, and <a class="el" href="sparsematrix_8h_source.html#l00062">VNL::SparseMatrixPair&lt; T &gt;::second</a>.</p>

</div>
</div>
<a class="anchor" id="aa9ae8ef37641f7d9a4dcf53136548a29"></a><!-- doxytag: member="VNL::SparseMatrix::empty_row" ref="aa9ae8ef37641f7d9a4dcf53136548a29" args="(unsigned int r) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::empty_row </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>r</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return whether a given row is empty. </p>

<p>Referenced by <a class="el" href="sparsematrix_8tpp_source.html#l00303">VNL::SparseMatrix&lt; T &gt;::add()</a>, and <a class="el" href="sparsematrix_8tpp_source.html#l00357">VNL::SparseMatrix&lt; T &gt;::subtract()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a3b1c6a597c2b17aef9f6b0520db089"></a><!-- doxytag: member="VNL::SparseMatrix::get_row" ref="a5a3b1c6a597c2b17aef9f6b0520db089" args="(unsigned int r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SparseMatrix.html#af073ad395079f4e9200958f0f9d2ff27">row</a>&amp; <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::get_row </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>r</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return row as vector of pairs. </p>
<p>Added to aid binary I/O </p>

</div>
</div>
<a class="anchor" id="a090a137d254ab4856dc424b6100ba8fb"></a><!-- doxytag: member="VNL::SparseMatrix::getcolumn" ref="a090a137d254ab4856dc424b6100ba8fb" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::getcolumn </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the column of the entry pointed to by internal iterator. </p>

</div>
</div>
<a class="anchor" id="ae7620f63bbd8815b628d2a27f512e2c3"></a><!-- doxytag: member="VNL::SparseMatrix::getrow" ref="ae7620f63bbd8815b628d2a27f512e2c3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::getrow </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the row of the entry pointed to by internal iterator. </p>

<p>References <a class="el" href="sparsematrix_8h_source.html#l00231">VNL::SparseMatrix&lt; T &gt;::itr_row</a>.</p>

</div>
</div>
<a class="anchor" id="ad18c1fc7b658354f0ff44175c621c659"></a><!-- doxytag: member="VNL::SparseMatrix::mult" ref="ad18c1fc7b658354f0ff44175c621c659" args="(unsigned int n, unsigned int m, T const *p, T *q) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::mult </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>prows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pcols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>q</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply this*p, a fortran order matrix. </p>
<p>The matrix p has n rows and m columns, and is in fortran order, ie. columns first. </p>

<p>References <a class="el" href="sparsematrix_8h_source.html#l00180">VNL::SparseMatrix&lt; T &gt;::columns()</a>, <a class="el" href="sparsematrix_8h_source.html#l00227">VNL::SparseMatrix&lt; T &gt;::elements</a>, <a class="el" href="sparsematrix_8h_source.html#l00061">VNL::SparseMatrixPair&lt; T &gt;::first</a>, <a class="el" href="sparsematrix_8h_source.html#l00176">VNL::SparseMatrix&lt; T &gt;::rows()</a>, and <a class="el" href="sparsematrix_8h_source.html#l00062">VNL::SparseMatrixPair&lt; T &gt;::second</a>.</p>

</div>
</div>
<a class="anchor" id="a905d75ee16a924514a4177b9b76b4856"></a><!-- doxytag: member="VNL::SparseMatrix::mult" ref="a905d75ee16a924514a4177b9b76b4856" args="(Vector&lt; T &gt; const &amp;rhs, Vector&lt; T &gt; &amp;result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::mult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply this*rhs, where rhs is a vector. </p>
<p>Multiply this*rhs, a vector. </p>

<p>References <a class="el" href="sparsematrix_8h_source.html#l00180">VNL::SparseMatrix&lt; T &gt;::columns()</a>, <a class="el" href="sparsematrix_8h_source.html#l00227">VNL::SparseMatrix&lt; T &gt;::elements</a>, <a class="el" href="vector_8tpp_source.html#l00352">VNL::Vector&lt; T &gt;::Fill()</a>, <a class="el" href="sparsematrix_8h_source.html#l00061">VNL::SparseMatrixPair&lt; T &gt;::first</a>, <a class="el" href="vector_8tpp_source.html#l00286">VNL::Vector&lt; T &gt;::Resize()</a>, <a class="el" href="sparsematrix_8h_source.html#l00176">VNL::SparseMatrix&lt; T &gt;::rows()</a>, <a class="el" href="sparsematrix_8h_source.html#l00062">VNL::SparseMatrixPair&lt; T &gt;::second</a>, and <a class="el" href="vector_8h_source.html#l00142">VNL::Vector&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a4f3dd62e877222778c4b42256edf359c"></a><!-- doxytag: member="VNL::SparseMatrix::mult" ref="a4f3dd62e877222778c4b42256edf359c" args="(SparseMatrix&lt; T &gt; const &amp;rhs, SparseMatrix&lt; T &gt; &amp;result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::mult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply this*rhs, another sparse matrix. </p>

<p>References <a class="el" href="sparsematrix_8h_source.html#l00180">VNL::SparseMatrix&lt; T &gt;::columns()</a>, <a class="el" href="sparsematrix_8h_source.html#l00228">VNL::SparseMatrix&lt; T &gt;::cs_</a>, <a class="el" href="sparsematrix_8h_source.html#l00227">VNL::SparseMatrix&lt; T &gt;::elements</a>, <a class="el" href="sparsematrix_8h_source.html#l00061">VNL::SparseMatrixPair&lt; T &gt;::first</a>, <a class="el" href="sparsematrix_8h_source.html#l00176">VNL::SparseMatrix&lt; T &gt;::rows()</a>, <a class="el" href="sparsematrix_8h_source.html#l00228">VNL::SparseMatrix&lt; T &gt;::rs_</a>, and <a class="el" href="sparsematrix_8h_source.html#l00062">VNL::SparseMatrixPair&lt; T &gt;::second</a>.</p>

<p>Referenced by <a class="el" href="sparsesymmetriceigensystem_8cpp_source.html#l00214">VNL::SparseSymmetricEigensystem::CalculateProduct()</a>.</p>

</div>
</div>
<a class="anchor" id="a82dac03337af6ec7649b8ce2c1e36834"></a><!-- doxytag: member="VNL::SparseMatrix::next" ref="a82dac03337af6ec7649b8ce2c1e36834" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::next </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the internal iterator to next non-zero entry in matrix. </p>
<p>Returns true if there is another value, false otherwise. Use in combination with methods reset, getrow, getcolumn, and value. </p>

<p>References <a class="el" href="sparsematrix_8h_source.html#l00227">VNL::SparseMatrix&lt; T &gt;::elements</a>, <a class="el" href="sparsematrix_8h_source.html#l00232">VNL::SparseMatrix&lt; T &gt;::itr_cur</a>, <a class="el" href="sparsematrix_8h_source.html#l00233">VNL::SparseMatrix&lt; T &gt;::itr_isreset</a>, <a class="el" href="sparsematrix_8h_source.html#l00231">VNL::SparseMatrix&lt; T &gt;::itr_row</a>, and <a class="el" href="sparsematrix_8h_source.html#l00176">VNL::SparseMatrix&lt; T &gt;::rows()</a>.</p>

</div>
</div>
<a class="anchor" id="ae697db78c70a50bb957f8fbfdf5bbd1b"></a><!-- doxytag: member="VNL::SparseMatrix::operator()" ref="ae697db78c70a50bb957f8fbfdf5bbd1b" args="(unsigned int row, unsigned int column)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>column</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a reference to an entry in the matrix. </p>

<p>References <a class="el" href="sparsematrix_8h_source.html#l00180">VNL::SparseMatrix&lt; T &gt;::columns()</a>, <a class="el" href="sparsematrix_8h_source.html#l00227">VNL::SparseMatrix&lt; T &gt;::elements</a>, and <a class="el" href="sparsematrix_8h_source.html#l00176">VNL::SparseMatrix&lt; T &gt;::rows()</a>.</p>

</div>
</div>
<a class="anchor" id="a4c32949cc911e7e848907913234fcdf2"></a><!-- doxytag: member="VNL::SparseMatrix::operator=" ref="a4c32949cc911e7e848907913234fcdf2" args="(const SparseMatrix&lt; T &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy another SparseMatrix&lt;T&gt; into this. </p>
<p>Copy another VNL::SparseMatrix&lt;T&gt; into this. </p>

<p>References <a class="el" href="sparsematrix_8h_source.html#l00228">VNL::SparseMatrix&lt; T &gt;::cs_</a>, <a class="el" href="sparsematrix_8h_source.html#l00227">VNL::SparseMatrix&lt; T &gt;::elements</a>, and <a class="el" href="sparsematrix_8h_source.html#l00228">VNL::SparseMatrix&lt; T &gt;::rs_</a>.</p>

</div>
</div>
<a class="anchor" id="a1e28e8d9617d31b3583094f09477896e"></a><!-- doxytag: member="VNL::SparseMatrix::pre_mult" ref="a1e28e8d9617d31b3583094f09477896e" args="(const Vector&lt; T &gt; &amp;lhs, Vector&lt; T &gt; &amp;result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::pre_mult </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiplies lhs*this, where lhs is a vector. </p>
<p>Multiply lhs*this, where lhs is a vector. </p>

<p>References <a class="el" href="sparsematrix_8h_source.html#l00180">VNL::SparseMatrix&lt; T &gt;::columns()</a>, <a class="el" href="sparsematrix_8h_source.html#l00227">VNL::SparseMatrix&lt; T &gt;::elements</a>, <a class="el" href="vector_8tpp_source.html#l00352">VNL::Vector&lt; T &gt;::Fill()</a>, <a class="el" href="sparsematrix_8h_source.html#l00061">VNL::SparseMatrixPair&lt; T &gt;::first</a>, <a class="el" href="vector_8tpp_source.html#l00286">VNL::Vector&lt; T &gt;::Resize()</a>, <a class="el" href="sparsematrix_8h_source.html#l00176">VNL::SparseMatrix&lt; T &gt;::rows()</a>, <a class="el" href="sparsematrix_8h_source.html#l00062">VNL::SparseMatrixPair&lt; T &gt;::second</a>, and <a class="el" href="vector_8h_source.html#l00142">VNL::Vector&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa27fff601e433cbe970c2638dda8564"></a><!-- doxytag: member="VNL::SparseMatrix::reset" ref="aaa27fff601e433cbe970c2638dda8564" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the internal iterator. </p>

<p>References <a class="el" href="sparsematrix_8h_source.html#l00233">VNL::SparseMatrix&lt; T &gt;::itr_isreset</a>, and <a class="el" href="sparsematrix_8h_source.html#l00231">VNL::SparseMatrix&lt; T &gt;::itr_row</a>.</p>

</div>
</div>
<a class="anchor" id="a7116d90be7b7bafd8c6a8542f989a644"></a><!-- doxytag: member="VNL::SparseMatrix::resize" ref="a7116d90be7b7bafd8c6a8542f989a644" args="(int r, int c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resizes the array to have r rows and c cols. </p>
<p>Resizes the matrix so that it has r rows and c columns.</p>
<p>Currently not implemented. </p>

</div>
</div>
<a class="anchor" id="afde720ae0439b585e54a55c435ffdcfb"></a><!-- doxytag: member="VNL::SparseMatrix::rows" ref="afde720ae0439b585e54a55c435ffdcfb" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of rows in the matrix. </p>

<p>Referenced by <a class="el" href="sparsematrix_8tpp_source.html#l00303">VNL::SparseMatrix&lt; T &gt;::add()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00070">VNL::SparseMatrix&lt; T &gt;::mult()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00533">VNL::SparseMatrix&lt; T &gt;::next()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00411">VNL::SparseMatrix&lt; T &gt;::operator()()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00265">VNL::SparseMatrix&lt; T &gt;::pre_mult()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00496">VNL::SparseMatrix&lt; T &gt;::scale_row()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00449">VNL::SparseMatrix&lt; T &gt;::set_row()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00357">VNL::SparseMatrix&lt; T &gt;::subtract()</a>, and <a class="el" href="sparsematrix_8tpp_source.html#l00484">VNL::SparseMatrix&lt; T &gt;::sum_row()</a>.</p>

</div>
</div>
<a class="anchor" id="a2213ec5676471d8dc8e3c6b91976b33e"></a><!-- doxytag: member="VNL::SparseMatrix::scale_row" ref="a2213ec5676471d8dc8e3c6b91976b33e" args="(unsigned int r, T scale)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::scale_row </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>scale</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Useful for normalizing row sums in convolution operators. </p>

<p>References <a class="el" href="sparsematrix_8h_source.html#l00227">VNL::SparseMatrix&lt; T &gt;::elements</a>, and <a class="el" href="sparsematrix_8h_source.html#l00176">VNL::SparseMatrix&lt; T &gt;::rows()</a>.</p>

</div>
</div>
<a class="anchor" id="abe959d5a335c36fa529381c1bc8a9710"></a><!-- doxytag: member="VNL::SparseMatrix::set_row" ref="abe959d5a335c36fa529381c1bc8a9710" args="(unsigned int r, std::vector&lt; int &gt; const &amp;cols, std::vector&lt; T &gt; const &amp;vals)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::set_row </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>vals</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a whole row at once. Much faster. </p>
<p>Set row in the matrix. </p>

<p>References <a class="el" href="sparsematrix_8h_source.html#l00227">VNL::SparseMatrix&lt; T &gt;::elements</a>, and <a class="el" href="sparsematrix_8h_source.html#l00176">VNL::SparseMatrix&lt; T &gt;::rows()</a>.</p>

</div>
</div>
<a class="anchor" id="ae71fc7cc72460fb60b711285415cd184"></a><!-- doxytag: member="VNL::SparseMatrix::subtract" ref="ae71fc7cc72460fb60b711285415cd184" args="(const SparseMatrix&lt; T &gt; &amp;rhs, SparseMatrix&lt; T &gt; &amp;result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVNL_1_1SparseMatrix.html">SparseMatrix</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract rhs from this. </p>

<p>References <a class="el" href="sparsematrix_8h_source.html#l00180">VNL::SparseMatrix&lt; T &gt;::columns()</a>, <a class="el" href="sparsematrix_8h_source.html#l00228">VNL::SparseMatrix&lt; T &gt;::cs_</a>, <a class="el" href="sparsematrix_8h_source.html#l00227">VNL::SparseMatrix&lt; T &gt;::elements</a>, <a class="el" href="sparsematrix_8h_source.html#l00188">VNL::SparseMatrix&lt; T &gt;::empty_row()</a>, <a class="el" href="sparsematrix_8h_source.html#l00061">VNL::SparseMatrixPair&lt; T &gt;::first</a>, <a class="el" href="sparsematrix_8h_source.html#l00176">VNL::SparseMatrix&lt; T &gt;::rows()</a>, <a class="el" href="sparsematrix_8h_source.html#l00228">VNL::SparseMatrix&lt; T &gt;::rs_</a>, and <a class="el" href="sparsematrix_8h_source.html#l00062">VNL::SparseMatrixPair&lt; T &gt;::second</a>.</p>

</div>
</div>
<a class="anchor" id="a55613aa5459b152e1e8d3e2b328254b6"></a><!-- doxytag: member="VNL::SparseMatrix::sum_row" ref="a55613aa5459b152e1e8d3e2b328254b6" args="(unsigned int r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::sum_row </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>r</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is occasionally useful. </p>
<p>This is occasionally useful. Sums a row of the matrix efficiently. </p>

<p>References <a class="el" href="sparsematrix_8h_source.html#l00227">VNL::SparseMatrix&lt; T &gt;::elements</a>, and <a class="el" href="sparsematrix_8h_source.html#l00176">VNL::SparseMatrix&lt; T &gt;::rows()</a>.</p>

</div>
</div>
<a class="anchor" id="aedba52d53920eca8593c12dc63e3119a"></a><!-- doxytag: member="VNL::SparseMatrix::value" ref="aedba52d53920eca8593c12dc63e3119a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the value pointed to by the internal iterator. </p>

</div>
</div>
<a class="anchor" id="aaa82352c66b7f599a44ca6b143d5131d"></a><!-- doxytag: member="VNL::SparseMatrix::vcat" ref="aaa82352c66b7f599a44ca6b143d5131d" args="(SparseMatrix&lt; T &gt; const &amp;A)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt; &amp; <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::vcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Laminate matrix A onto the bottom of this one. </p>

<p>References <a class="el" href="sparsematrix_8h_source.html#l00228">VNL::SparseMatrix&lt; T &gt;::cs_</a>, <a class="el" href="sparsematrix_8h_source.html#l00227">VNL::SparseMatrix&lt; T &gt;::elements</a>, and <a class="el" href="sparsematrix_8h_source.html#l00228">VNL::SparseMatrix&lt; T &gt;::rs_</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a282982989994fbdf6ff7667648bd5680"></a><!-- doxytag: member="VNL::SparseMatrix::cs_" ref="a282982989994fbdf6ff7667648bd5680" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1SparseMatrix.html#a282982989994fbdf6ff7667648bd5680">cs_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="sparsematrix_8tpp_source.html#l00303">VNL::SparseMatrix&lt; T &gt;::add()</a>, <a class="el" href="sparsematrix_8h_source.html#l00184">VNL::SparseMatrix&lt; double &gt;::cols()</a>, <a class="el" href="sparsematrix_8h_source.html#l00180">VNL::SparseMatrix&lt; double &gt;::columns()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00070">VNL::SparseMatrix&lt; T &gt;::mult()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00054">VNL::SparseMatrix&lt; T &gt;::operator=()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00357">VNL::SparseMatrix&lt; T &gt;::subtract()</a>, and <a class="el" href="sparsematrix_8tpp_source.html#l00464">VNL::SparseMatrix&lt; T &gt;::vcat()</a>.</p>

</div>
</div>
<a class="anchor" id="a508a21b1d4a4d76b305729a1584f03d3"></a><!-- doxytag: member="VNL::SparseMatrix::elements" ref="a508a21b1d4a4d76b305729a1584f03d3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SparseMatrix.html#a529997e154a1c32b0c611da0e1d88133">SparseMatrixElements</a> <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1SparseMatrix.html#a508a21b1d4a4d76b305729a1584f03d3">elements</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="sparsematrix_8tpp_source.html#l00303">VNL::SparseMatrix&lt; T &gt;::add()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00427">VNL::SparseMatrix&lt; T &gt;::diag_AtA()</a>, <a class="el" href="sparsematrix_8h_source.html#l00188">VNL::SparseMatrix&lt; double &gt;::empty_row()</a>, <a class="el" href="sparsematrix_8h_source.html#l00168">VNL::SparseMatrix&lt; double &gt;::get_row()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00070">VNL::SparseMatrix&lt; T &gt;::mult()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00533">VNL::SparseMatrix&lt; T &gt;::next()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00411">VNL::SparseMatrix&lt; T &gt;::operator()()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00054">VNL::SparseMatrix&lt; T &gt;::operator=()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00265">VNL::SparseMatrix&lt; T &gt;::pre_mult()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00496">VNL::SparseMatrix&lt; T &gt;::scale_row()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00449">VNL::SparseMatrix&lt; T &gt;::set_row()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00357">VNL::SparseMatrix&lt; T &gt;::subtract()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00484">VNL::SparseMatrix&lt; T &gt;::sum_row()</a>, and <a class="el" href="sparsematrix_8tpp_source.html#l00464">VNL::SparseMatrix&lt; T &gt;::vcat()</a>.</p>

</div>
</div>
<a class="anchor" id="af03c7f481d4a41a20d1a983da286fea9"></a><!-- doxytag: member="VNL::SparseMatrix::itr_cur" ref="af03c7f481d4a41a20d1a983da286fea9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">row::iterator <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1SparseMatrix.html#af03c7f481d4a41a20d1a983da286fea9">itr_cur</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="sparsematrix_8tpp_source.html#l00533">VNL::SparseMatrix&lt; T &gt;::next()</a>.</p>

</div>
</div>
<a class="anchor" id="a3fc0bfccdf55147d561a189aa739df61"></a><!-- doxytag: member="VNL::SparseMatrix::itr_isreset" ref="a3fc0bfccdf55147d561a189aa739df61" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1SparseMatrix.html#a3fc0bfccdf55147d561a189aa739df61">itr_isreset</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="sparsematrix_8tpp_source.html#l00533">VNL::SparseMatrix&lt; T &gt;::next()</a>, and <a class="el" href="sparsematrix_8tpp_source.html#l00520">VNL::SparseMatrix&lt; T &gt;::reset()</a>.</p>

</div>
</div>
<a class="anchor" id="aec27853b37d80b356cc905a12652485e"></a><!-- doxytag: member="VNL::SparseMatrix::itr_row" ref="aec27853b37d80b356cc905a12652485e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1SparseMatrix.html#aec27853b37d80b356cc905a12652485e">itr_row</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="sparsematrix_8tpp_source.html#l00569">VNL::SparseMatrix&lt; T &gt;::getrow()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00533">VNL::SparseMatrix&lt; T &gt;::next()</a>, and <a class="el" href="sparsematrix_8tpp_source.html#l00520">VNL::SparseMatrix&lt; T &gt;::reset()</a>.</p>

</div>
</div>
<a class="anchor" id="abc9ad536f45d381f2bbab8bb84e53e1d"></a><!-- doxytag: member="VNL::SparseMatrix::rs_" ref="abc9ad536f45d381f2bbab8bb84e53e1d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classVNL_1_1SparseMatrix.html">VNL::SparseMatrix</a>&lt; T &gt;::<a class="el" href="classVNL_1_1SparseMatrix.html#abc9ad536f45d381f2bbab8bb84e53e1d">rs_</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="sparsematrix_8tpp_source.html#l00303">VNL::SparseMatrix&lt; T &gt;::add()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00070">VNL::SparseMatrix&lt; T &gt;::mult()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00054">VNL::SparseMatrix&lt; T &gt;::operator=()</a>, <a class="el" href="sparsematrix_8h_source.html#l00176">VNL::SparseMatrix&lt; double &gt;::rows()</a>, <a class="el" href="sparsematrix_8tpp_source.html#l00357">VNL::SparseMatrix&lt; T &gt;::subtract()</a>, and <a class="el" href="sparsematrix_8tpp_source.html#l00464">VNL::SparseMatrix&lt; T &gt;::vcat()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="sparsematrix_8h_source.html">sparsematrix.h</a></li>
<li><a class="el" href="sparsematrix_8tpp.html">sparsematrix.tpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Mar 21 09:55:52 2010 for VW by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

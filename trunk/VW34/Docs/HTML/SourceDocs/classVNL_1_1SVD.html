<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VW: VNL::SVD&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen_vw.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
  <div class="navpath"><a class="el" href="namespaceVNL.html">VNL</a>::<a class="el" href="classVNL_1_1SVD.html">SVD</a>
  </div>
<div class="contents">
<h1>VNL::SVD&lt; T &gt; Class Template Reference</h1><!-- doxytag: class="VNL::SVD" -->
<p>Holds the singular value decomposition of a <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">VNL::Matrix</a>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="svd_8h_source.html">svd.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for VNL::SVD&lt; T &gt;:</div>
<div class="dynsection">
 <div class="center">
  <img src="classVNL_1_1SVD.gif" usemap="#VNL::SVD&lt; T &gt;_map" alt=""/>
  <map id="VNL::SVD&lt; T &gt;_map" name="VNL::SVD&lt; T &gt;_map">
<area href="structVNL_1_1MatrixInverse.html" alt="VNL::MatrixInverse&lt; T &gt;" shape="rect" coords="0,56,151,80"/>
</map>
 </div>
</div>

<p><a href="classVNL_1_1SVD-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VNL::NumericTraits&lt; T &gt;<br class="typebreak"/>
::abs_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The singular values of a matrix of complex&lt;T&gt; are of type T, not complex&lt;T&gt;.  <a href="#a373ab360ec1ded8fb7f26db4b69350a9"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a9d9c05f29d9dc80ece0338ea360e2784">SVD</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;M, double zero_out_tol=0.0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an vnl_svd&lt;T&gt; object from <img class="formulaInl" alt="$m \times n$" src="form_20.png"/> matrix <img class="formulaInl" alt="$M$" src="form_21.png"/>.  <a href="#a9d9c05f29d9dc80ece0338ea360e2784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a39da3bc478745ca32048ae8523c56431">~SVD</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#ad562a0661eba348720d78ed09bb0410d">ZeroOutAbsolute</a> (double tol=1e-8)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find weights below threshold tol, zero them out, and update W_ and Winverse_.  <a href="#ad562a0661eba348720d78ed09bb0410d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a9cc8502c0e3cdc831ef4b310a4341941">ZeroOutRelative</a> (double tol=1e-8)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">find weights below tol*max(w) and zero them out.  <a href="#a9cc8502c0e3cdc831ef4b310a4341941"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a4c00282148f477fcae7d3fe47b3318a5">Singularities</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#af2bf9e3ff4e81b49cde196649a4ccb16">Rank</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a664c4a9046a560a1be618cdb6a920075">WellCondition</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a439e32b9a8d408dcb9e4e4ecd1deb925">DeterminantMagnitude</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate determinant as product of diagonals in W.  <a href="#a439e32b9a8d408dcb9e4e4ecd1deb925"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#ada5c7cee296922f41551f7f3e171caca">Norm</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a0f4f19356f15cbf95ba1820df008bdf8">U</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the matrix U.  <a href="#a0f4f19356f15cbf95ba1820df008bdf8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#ac60d88ddf7c76101378065a73347e353">U</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the matrix U.  <a href="#ac60d88ddf7c76101378065a73347e353"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#ae5251f26a737960d5f1acf218a9608fd">U</a> (int i, int j)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the matrix U's (i,j)th entry (to avoid svd.U()(i,j); ).  <a href="#ae5251f26a737960d5f1acf218a9608fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1DiagMatrix.html">DiagMatrix</a>&lt; <a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a519593095e3e1baa735c0589e1b0dc98">W</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get at <a class="el" href="classVNL_1_1DiagMatrix.html" title="stores a diagonal matrix as a single vector.">DiagMatrix</a> (<a class="el" href="vector_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">q.v</a>.  <a href="#a519593095e3e1baa735c0589e1b0dc98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1DiagMatrix.html">DiagMatrix</a>&lt; <a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a> &gt; const &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a7528f27ee5be76797caac1d6523f0c95">W</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get at <a class="el" href="classVNL_1_1DiagMatrix.html" title="stores a diagonal matrix as a single vector.">DiagMatrix</a> (<a class="el" href="vector_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">q.v</a>.  <a href="#a7528f27ee5be76797caac1d6523f0c95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1DiagMatrix.html">DiagMatrix</a>&lt; <a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a665f75bca4e3ef57ea68417dabda635e">WInverse</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1DiagMatrix.html">VNL::DiagMatrix</a>&lt; <a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a> &gt;<br class="typebreak"/>
 const &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#ae0cb2e2980b3971490d0e7486abebe0b">Winverse</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a20741ab76a9723dd30dcf7cb113bb480">W</a> (int i, int j)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a642d4e53cb3d2bbe66d6dd8c82815ba5">W</a> (int i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a3246aeffbc8ca183d101cf1aa60e6cd8">SigmaMax</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a0a12b5660676d929b9fbb62c36f6e709">SigmaMin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a0c690460d64e2b187ea2e9c1cde8b19b">V</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the matrix V.  <a href="#a0c690460d64e2b187ea2e9c1cde8b19b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a3846dd100fd8edcec4e34e63022da383">V</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the matrix V.  <a href="#a3846dd100fd8edcec4e34e63022da383"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#aaa333283ff240f5ec65e7f3e360c4398">V</a> (int i, int j)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the matrix V's (i,j)th entry (to avoid svd.V()(i,j); ).  <a href="#aaa333283ff240f5ec65e7f3e360c4398"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#acb98ee0d2705fc1dae5d86b5f10197bc">Inverse</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a77c65efed68c114f19f3c9f59042511a">PseudoInverse</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pseudo-inverse (for non-square matrix).  <a href="#a77c65efed68c114f19f3c9f59042511a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a779c23e1795cdc892ff96d175cea04ae">PseudoInverse</a> (int rank) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pseudo-inverse (for non-square matrix) of desired rank.  <a href="#a779c23e1795cdc892ff96d175cea04ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a79e0ff65486ba97b7230af5572f7d9d2">TransposeInverse</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate inverse of transpose.  <a href="#a79e0ff65486ba97b7230af5572f7d9d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a1f693c3ebff90a145c3bd3c4aa7173ac">Recompose</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recompose <a class="el" href="classVNL_1_1SVD.html" title="Holds the singular value decomposition of a VNL::Matrix.">SVD</a> to U*W*V'.  <a href="#a1f693c3ebff90a145c3bd3c4aa7173ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a3a552b589a31c0f0cba9ac11f4354ac6">Solve</a> (<a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; T &gt; const &amp;B) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve the matrix equation M <a class="el" href="structX.html">X</a> = B, returning <a class="el" href="structX.html">X</a>.  <a href="#a3a552b589a31c0f0cba9ac11f4354ac6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#aed0a9d2c54425e58e471ff2a3c64ff3b">Solve</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;y) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve the matrix-vector system M x = y, returning x.  <a href="#aed0a9d2c54425e58e471ff2a3c64ff3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a1f1e1f1b700fb541c298b0ee582b6129">Solve</a> (T const *rhs, T *lhs) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a26d4fd17157dd50d599babb4fa6eeaf1">SolvePreinverted</a> (<a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; const &amp;rhs, <a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; T &gt; *out) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Solve the matrix-vector system M x = y.  <a href="#a26d4fd17157dd50d599babb4fa6eeaf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a057160190f47f970bb5656419b537a91">Nullspace</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return N such that M * N = 0.  <a href="#a057160190f47f970bb5656419b537a91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a5fe73ba45aeb11d5a88f1f432cbf6364">LeftNullspace</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return N such that M' * N = 0.  <a href="#a5fe73ba45aeb11d5a88f1f432cbf6364"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a0d3450e60af14a57680dc9089798382b">Nullspace</a> (int required_nullspace_dimension) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return N such that M * N = 0.  <a href="#a0d3450e60af14a57680dc9089798382b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#afd3932c87d447250efc20dacb8cc75c5">LeftNullspace</a> (int required_nullspace_dimension) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation to be done yet; currently returns left_nullspace(). - PVR.  <a href="#afd3932c87d447250efc20dacb8cc75c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#ae02d9d2337103b363f5a5f3e26343e5a">Nullvector</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the rightmost column of V.  <a href="#ae02d9d2337103b363f5a5f3e26343e5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a31c0c15ca7704b03f06d4767377069f3">LeftNullvector</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the rightmost column of U.  <a href="#a31c0c15ca7704b03f06d4767377069f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a6e24342cce83089c33e83c384f4f9106">Valid</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVNL_1_1SVD.html#a5f70cdbf14925a8868eb6e914cffa2ca">SVD</a> (<a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; long double &gt; const &amp;M, double)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br/>
 class VNL::SVD&lt; T &gt;</h3>

<p>Holds the singular value decomposition of a <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">VNL::Matrix</a>. </p>
<p>The class holds three matrices U, W, V such that the original matrix <img class="formulaInl" alt="$M = U W V^\top$" src="form_19.png"/>. The <a class="el" href="classVNL_1_1DiagMatrix.html" title="stores a diagonal matrix as a single vector.">DiagMatrix</a> W stores the singular values in decreasing order. The columns of U which correspond to the nonzero singular values form a basis for range of M, while the columns of V corresponding to the zero singular values are the nullspace.</p>
<p>The <a class="el" href="classVNL_1_1SVD.html" title="Holds the singular value decomposition of a VNL::Matrix.">SVD</a> is computed at construction time, and enquiries may then be made of the <a class="el" href="classVNL_1_1SVD.html" title="Holds the singular value decomposition of a VNL::Matrix.">SVD</a>. In particular, this allows easy access to multiple right-hand-side solves without the bother of putting all the RHS's into a <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a>.</p>
<p>This class is supplied even though there is an existing <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">VNL::Matrix</a> method for several reasons:</p>
<p>It is more convenient to use as it manages all the storage for the U,S,V matrices, allowing repeated queries of the same <a class="el" href="classVNL_1_1SVD.html" title="Holds the singular value decomposition of a VNL::Matrix.">SVD</a> results.</p>
<p>It avoids namespace clutter in the <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> class. While svd() is a perfectly reasonable method for a <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a>, there are many other decompositions that might be of interest, and adding them all would make for a very large <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> class.</p>
<p>It demonstrates the holder model of compute class, implementing an algorithm on an object without adding a member that may not be of general interest. A similar pattern can be used for other decompositions which are not defined as members of the library <a class="el" href="classVNL_1_1Matrix.html" title="An ordinary mathematical matrix.">Matrix</a> class.</p>
<p>It extends readily to n-ary operations, such as generalized eigensystems, which cannot be members of just one matrix. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a373ab360ec1ded8fb7f26db4b69350a9"></a><!-- doxytag: member="VNL::SVD::singval_t" ref="a373ab360ec1ded8fb7f26db4b69350a9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VNL::NumericTraits&lt;T&gt;::abs_t <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::<a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The singular values of a matrix of complex&lt;T&gt; are of type T, not complex&lt;T&gt;. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9d9c05f29d9dc80ece0338ea360e2784"></a><!-- doxytag: member="VNL::SVD::SVD" ref="a9d9c05f29d9dc80ece0338ea360e2784" args="(Matrix&lt; T &gt; const &amp;M, double zero_out_tol=0.0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::<a class="el" href="classVNL_1_1SVD.html">SVD</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>zero_out_tol</em> = <code>0.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct an vnl_svd&lt;T&gt; object from <img class="formulaInl" alt="$m \times n$" src="form_20.png"/> matrix <img class="formulaInl" alt="$M$" src="form_21.png"/>. </p>
<p>The vnl_svd&lt;T&gt; object contains matrices <img class="formulaInl" alt="$U$" src="form_22.png"/>, <img class="formulaInl" alt="$W$" src="form_23.png"/>, <img class="formulaInl" alt="$V$" src="form_24.png"/> such that <img class="formulaInl" alt="$U W V^\top = M$" src="form_25.png"/>.</p>
<p>Uses linpack routine DSVDC to calculate an ``economy-size'' <a class="el" href="classVNL_1_1SVD.html" title="Holds the singular value decomposition of a VNL::Matrix.">SVD</a> where the returned <img class="formulaInl" alt="$U$" src="form_22.png"/> is the same size as <img class="formulaInl" alt="$M$" src="form_21.png"/>, while <img class="formulaInl" alt="$W$" src="form_23.png"/> and <img class="formulaInl" alt="$V$" src="form_24.png"/> are both <img class="formulaInl" alt="$n \times n$" src="form_26.png"/>. This is efficient for large rectangular solves where <img class="formulaInl" alt="$m > n$" src="form_27.png"/>, typical in least squares.</p>
<p>The optional argument zero_out_tol is used to mark the zero singular values: If nonnegative, any <a class="el" href="vector_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">s.v</a>. smaller than zero_out_tol in absolute value is set to zero. If zero_out_tol is negative, the zeroing is relative to |zero_out_tol| * sigma_max(); </p>

<p>References <a class="el" href="f2c_8h_source.html#l00154">abs</a>, <a class="el" href="matrix_8h_source.html#l00543">VNL::Matrix&lt; T &gt;::assert_finite()</a>, <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, <a class="el" href="vector_8h_source.html#l00275">VNL::Vector&lt; T &gt;::DataBlock()</a>, <a class="el" href="vnlmath_8h_source.html#l00103">VNL::Math::eps</a>, <a class="el" href="matrix_8h_source.html#l00469">VNL::Matrix&lt; T &gt;::FrobeniusNorm()</a>, <a class="el" href="matlabprintformat_8h_source.html#l00018">VNL::matlab_print_format_long</a>, <a class="el" href="matlabprint_8tpp_source.html#l00028">VNL::MatlabPrint()</a>, <a class="el" href="f2c_8h_source.html#l00156">min</a>, <a class="el" href="svd_8tpp_source.html#l00239">VNL::SVD&lt; T &gt;::Recompose()</a>, <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>, <a class="el" href="svd_8tpp_source.html#l00187">VNL::SVD&lt; T &gt;::ZeroOutAbsolute()</a>, and <a class="el" href="svd_8tpp_source.html#l00205">VNL::SVD&lt; T &gt;::ZeroOutRelative()</a>.</p>

</div>
</div>
<a class="anchor" id="a39da3bc478745ca32048ae8523c56431"></a><!-- doxytag: member="VNL::SVD::~SVD" ref="a39da3bc478745ca32048ae8523c56431" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::~<a class="el" href="classVNL_1_1SVD.html">SVD</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f70cdbf14925a8868eb6e914cffa2ca"></a><!-- doxytag: member="VNL::SVD::SVD" ref="a5f70cdbf14925a8868eb6e914cffa2ca" args="(VNL::Matrix&lt; long double &gt; const &amp;M, double)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; long double &gt;::<a class="el" href="classVNL_1_1SVD.html">SVD</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; long double &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="copy_8cpp_source.html#l00020">VNL::Copy()</a>, <a class="el" href="svd_8h_source.html#l00118">VNL::SVD&lt; T &gt;::U()</a>, <a class="el" href="svd_8h_source.html#l00144">VNL::SVD&lt; T &gt;::V()</a>, and <a class="el" href="svd_8h_source.html#l00130">VNL::SVD&lt; T &gt;::W()</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a439e32b9a8d408dcb9e4e4ecd1deb925"></a><!-- doxytag: member="VNL::SVD::DeterminantMagnitude" ref="a439e32b9a8d408dcb9e4e4ecd1deb925" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::<a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a> <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::DeterminantMagnitude </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate determinant as product of diagonals in W. </p>

<p>References <a class="el" href="diagmatrix_8h_source.html#l00105">VNL::DiagMatrix&lt; T &gt;::Columns()</a>.</p>

</div>
</div>
<a class="anchor" id="acb98ee0d2705fc1dae5d86b5f10197bc"></a><!-- doxytag: member="VNL::SVD::Inverse" ref="acb98ee0d2705fc1dae5d86b5f10197bc" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::Inverse </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="svd_8tpp_source.html#l00260">VNL::SVD&lt; T &gt;::PseudoInverse()</a>.</p>

<p>Referenced by <a class="el" href="homography2d_8cpp_source.html#l00031">VW::Homography2D::Inverse()</a>, and <a class="el" href="matrixinverse_8h_source.html#l00042">VNL::MatrixInverse&lt; T &gt;::operator VNL::Matrix&lt; T &gt;()</a>.</p>

</div>
</div>
<a class="anchor" id="afd3932c87d447250efc20dacb8cc75c5"></a><!-- doxytag: member="VNL::SVD::LeftNullspace" ref="afd3932c87d447250efc20dacb8cc75c5" args="(int required_nullspace_dimension) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::LeftNullspace </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>required_nullspace_dimension</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implementation to be done yet; currently returns left_nullspace(). - PVR. </p>

<p>References <a class="el" href="svd_8tpp_source.html#l00411">VNL::SVD&lt; T &gt;::LeftNullspace()</a>.</p>

</div>
</div>
<a class="anchor" id="a5fe73ba45aeb11d5a88f1f432cbf6364"></a><!-- doxytag: member="VNL::SVD::LeftNullspace" ref="a5fe73ba45aeb11d5a88f1f432cbf6364" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::LeftNullspace </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return N such that M' * N = 0. </p>
<p>Return N s.t. M' * N = 0. </p>

<p>References <a class="el" href="svd_8h_source.html#l00108">VNL::SVD&lt; T &gt;::Rank()</a>.</p>

<p>Referenced by <a class="el" href="svd_8tpp_source.html#l00422">VNL::SVD&lt; T &gt;::LeftNullspace()</a>.</p>

</div>
</div>
<a class="anchor" id="a31c0c15ca7704b03f06d4767377069f3"></a><!-- doxytag: member="VNL::SVD::LeftNullvector" ref="a31c0c15ca7704b03f06d4767377069f3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::LeftNullvector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the rightmost column of U. </p>
<p>Does not check to see whether or not the matrix actually was rank-deficient. </p>

<p>References <a class="el" href="f2c_8h_source.html#l00156">min</a>.</p>

</div>
</div>
<a class="anchor" id="ada5c7cee296922f41551f7f3e171caca"></a><!-- doxytag: member="VNL::SVD::Norm" ref="ada5c7cee296922f41551f7f3e171caca" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::<a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a> <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::Norm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="f2c_8h_source.html#l00154">abs</a>, and <a class="el" href="svd_8h_source.html#l00139">VNL::SVD&lt; T &gt;::SigmaMax()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d3450e60af14a57680dc9089798382b"></a><!-- doxytag: member="VNL::SVD::Nullspace" ref="a0d3450e60af14a57680dc9089798382b" args="(int required_nullspace_dimension) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::Nullspace </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>required_nullspace_dimension</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return N such that M * N = 0. </p>
<p>Return N s.t. M * N = 0. </p>

</div>
</div>
<a class="anchor" id="a057160190f47f970bb5656419b537a91"></a><!-- doxytag: member="VNL::SVD::Nullspace" ref="a057160190f47f970bb5656419b537a91" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::Nullspace </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return N such that M * N = 0. </p>
<p>Return N s.t. M * N = 0. </p>

<p>References <a class="el" href="svd_8h_source.html#l00108">VNL::SVD&lt; T &gt;::Rank()</a>.</p>

</div>
</div>
<a class="anchor" id="ae02d9d2337103b363f5a5f3e26343e5a"></a><!-- doxytag: member="VNL::SVD::Nullvector" ref="ae02d9d2337103b363f5a5f3e26343e5a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::Nullvector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the rightmost column of V. </p>
<p>Does not check to see whether or not the matrix actually was rank-deficient - the caller is assumed to have examined W and decided that to his or her satisfaction. </p>

<p>Referenced by <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00224">VW::FMPlanarCompute::GenerateParameterVectorHZJK()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00118">VW::FMPlanarCompute::GenerateParameterVectorVLJK()</a>, and <a class="el" href="pmatrixcomputelinear_8cpp_source.html#l00132">VW::PMatrixCompute::LinearFromPoints()</a>.</p>

</div>
</div>
<a class="anchor" id="a779c23e1795cdc892ff96d175cea04ae"></a><!-- doxytag: member="VNL::SVD::PseudoInverse" ref="a779c23e1795cdc892ff96d175cea04ae" args="(int rank) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::PseudoInverse </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rank</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>pseudo-inverse (for non-square matrix) of desired rank. </p>
<p>Calculate pseudo-inverse. </p>

<p>References <a class="el" href="diagmatrix_8h_source.html#l00105">VNL::DiagMatrix&lt; T &gt;::Columns()</a>, <a class="el" href="diagmatrix_8h_source.html#l00112">VNL::DiagMatrix&lt; T &gt;::Fill()</a>, <a class="el" href="diagmatrix_8h_source.html#l00103">VNL::DiagMatrix&lt; T &gt;::Rows()</a>, and <a class="el" href="svd_8h_source.html#l00136">VNL::SVD&lt; T &gt;::Winverse()</a>.</p>

</div>
</div>
<a class="anchor" id="a77c65efed68c114f19f3c9f59042511a"></a><!-- doxytag: member="VNL::SVD::PseudoInverse" ref="a77c65efed68c114f19f3c9f59042511a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::PseudoInverse </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>pseudo-inverse (for non-square matrix). </p>
<p>Calculate pseudo-inverse. </p>

<p>References <a class="el" href="diagmatrix_8h_source.html#l00105">VNL::DiagMatrix&lt; T &gt;::Columns()</a>, <a class="el" href="diagmatrix_8h_source.html#l00112">VNL::DiagMatrix&lt; T &gt;::Fill()</a>, <a class="el" href="diagmatrix_8h_source.html#l00103">VNL::DiagMatrix&lt; T &gt;::Rows()</a>, and <a class="el" href="svd_8h_source.html#l00136">VNL::SVD&lt; T &gt;::Winverse()</a>.</p>

<p>Referenced by <a class="el" href="svd_8tpp_source.html#l00251">VNL::SVD&lt; T &gt;::Inverse()</a>.</p>

</div>
</div>
<a class="anchor" id="af2bf9e3ff4e81b49cde196649a4ccb16"></a><!-- doxytag: member="VNL::SVD::Rank" ref="af2bf9e3ff4e81b49cde196649a4ccb16" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::Rank </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="svd_8tpp_source.html#l00411">VNL::SVD&lt; T &gt;::LeftNullspace()</a>, <a class="el" href="svd_8tpp_source.html#l00390">VNL::SVD&lt; T &gt;::Nullspace()</a>, and <a class="el" href="svd_8h_source.html#l00107">VNL::SVD&lt; T &gt;::Singularities()</a>.</p>

</div>
</div>
<a class="anchor" id="a1f693c3ebff90a145c3bd3c4aa7173ac"></a><!-- doxytag: member="VNL::SVD::Recompose" ref="a1f693c3ebff90a145c3bd3c4aa7173ac" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::Recompose </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recompose <a class="el" href="classVNL_1_1SVD.html" title="Holds the singular value decomposition of a VNL::Matrix.">SVD</a> to U*W*V'. </p>

<p>References <a class="el" href="diagmatrix_8h_source.html#l00105">VNL::DiagMatrix&lt; T &gt;::Columns()</a>, <a class="el" href="diagmatrix_8h_source.html#l00112">VNL::DiagMatrix&lt; T &gt;::Fill()</a>, <a class="el" href="diagmatrix_8h_source.html#l00103">VNL::DiagMatrix&lt; T &gt;::Rows()</a>, and <a class="el" href="svd_8h_source.html#l00130">VNL::SVD&lt; T &gt;::W()</a>.</p>

<p>Referenced by <a class="el" href="fmatrix_8cpp_source.html#l00069">VW::FMatrix::Constrain()</a>, and <a class="el" href="svd_8tpp_source.html#l00042">VNL::SVD&lt; T &gt;::SVD()</a>.</p>

</div>
</div>
<a class="anchor" id="a3246aeffbc8ca183d101cf1aa60e6cd8"></a><!-- doxytag: member="VNL::SVD::SigmaMax" ref="a3246aeffbc8ca183d101cf1aa60e6cd8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a> <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::SigmaMax </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="svd_8tpp_source.html#l00231">VNL::SVD&lt; T &gt;::Norm()</a>, <a class="el" href="svd_8h_source.html#l00109">VNL::SVD&lt; T &gt;::WellCondition()</a>, and <a class="el" href="svd_8tpp_source.html#l00205">VNL::SVD&lt; T &gt;::ZeroOutRelative()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a12b5660676d929b9fbb62c36f6e709"></a><!-- doxytag: member="VNL::SVD::SigmaMin" ref="a0a12b5660676d929b9fbb62c36f6e709" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a> <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::SigmaMin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="svd_8h_source.html#l00109">VNL::SVD&lt; T &gt;::WellCondition()</a>.</p>

</div>
</div>
<a class="anchor" id="a4c00282148f477fcae7d3fe47b3318a5"></a><!-- doxytag: member="VNL::SVD::Singularities" ref="a4c00282148f477fcae7d3fe47b3318a5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::Singularities </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="svd_8h_source.html#l00108">VNL::SVD&lt; T &gt;::Rank()</a>, and <a class="el" href="diagmatrix_8h_source.html#l00103">VNL::DiagMatrix&lt; T &gt;::Rows()</a>.</p>

</div>
</div>
<a class="anchor" id="a1f1e1f1b700fb541c298b0ee582b6129"></a><!-- doxytag: member="VNL::SVD::Solve" ref="a1f1e1f1b700fb541c298b0ee582b6129" args="(T const *rhs, T *lhs) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::Solve </td>
          <td>(</td>
          <td class="paramtype">T const *&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>lhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="svd_8tpp_source.html#l00301">VNL::SVD&lt; T &gt;::Solve()</a>.</p>

</div>
</div>
<a class="anchor" id="aed0a9d2c54425e58e471ff2a3c64ff3b"></a><!-- doxytag: member="VNL::SVD::Solve" ref="aed0a9d2c54425e58e471ff2a3c64ff3b" args="(Vector&lt; T &gt; const &amp;y) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::Solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solve the matrix-vector system M x = y, returning x. </p>

<p>References <a class="el" href="vector_8h_source.html#l00142">VNL::Vector&lt; T &gt;::size()</a>, and <a class="el" href="classVNL_1_1Vector.html#a4c45bc78444fbabf8e5ddf82e2b64381">VNL::Vector&lt; T &gt;::Update()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a552b589a31c0f0cba9ac11f4354ac6"></a><!-- doxytag: member="VNL::SVD::Solve" ref="a3a552b589a31c0f0cba9ac11f4354ac6" args="(Matrix&lt; T &gt; const &amp;B) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::Solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solve the matrix equation M <a class="el" href="structX.html">X</a> = B, returning <a class="el" href="structX.html">X</a>. </p>

<p>References <a class="el" href="matrix_8h_source.html#l00162">VNL::Matrix&lt; T &gt;::Columns()</a>, and <a class="el" href="matrix_8h_source.html#l00157">VNL::Matrix&lt; T &gt;::Rows()</a>.</p>

<p>Referenced by <a class="el" href="matrixinverse_8h_source.html#l00050">operator*()</a>, and <a class="el" href="svd_8tpp_source.html#l00362">VNL::SVD&lt; T &gt;::Solve()</a>.</p>

</div>
</div>
<a class="anchor" id="a26d4fd17157dd50d599babb4fa6eeaf1"></a><!-- doxytag: member="VNL::SVD::SolvePreinverted" ref="a26d4fd17157dd50d599babb4fa6eeaf1" args="(Vector&lt; T &gt; const &amp;rhs, Vector&lt; T &gt; *out) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::SolvePreinverted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">VNL::Vector</a>&lt; T &gt; *&nbsp;</td>
          <td class="paramname"> <em>x_out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solve the matrix-vector system M x = y. </p>
<p>Assuming that the singular values W have been preinverted by the caller.</p>
<p>Assume that the singular values W have been preinverted by the caller. </p>

<p>References <a class="el" href="vector_8h_source.html#l00142">VNL::Vector&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a79e0ff65486ba97b7230af5572f7d9d2"></a><!-- doxytag: member="VNL::SVD::TransposeInverse" ref="a79e0ff65486ba97b7230af5572f7d9d2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; T &gt; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::TransposeInverse </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate inverse of transpose. </p>

<p>References <a class="el" href="diagmatrix_8h_source.html#l00105">VNL::DiagMatrix&lt; T &gt;::Columns()</a>, <a class="el" href="diagmatrix_8h_source.html#l00112">VNL::DiagMatrix&lt; T &gt;::Fill()</a>, <a class="el" href="diagmatrix_8h_source.html#l00103">VNL::DiagMatrix&lt; T &gt;::Rows()</a>, and <a class="el" href="svd_8h_source.html#l00136">VNL::SVD&lt; T &gt;::Winverse()</a>.</p>

</div>
</div>
<a class="anchor" id="ae5251f26a737960d5f1acf218a9608fd"></a><!-- doxytag: member="VNL::SVD::U" ref="ae5251f26a737960d5f1acf218a9608fd" args="(int i, int j)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::U </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the matrix U's (i,j)th entry (to avoid svd.U()(i,j); ). </p>

</div>
</div>
<a class="anchor" id="ac60d88ddf7c76101378065a73347e353"></a><!-- doxytag: member="VNL::SVD::U" ref="ac60d88ddf7c76101378065a73347e353" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt;T&gt; const&amp; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::U </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the matrix U. </p>

</div>
</div>
<a class="anchor" id="a0f4f19356f15cbf95ba1820df008bdf8"></a><!-- doxytag: member="VNL::SVD::U" ref="a0f4f19356f15cbf95ba1820df008bdf8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt;T&gt;&amp; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::U </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the matrix U. </p>

<p>Referenced by <a class="el" href="essentialmatrix_8cpp_source.html#l00066">VW::EssentialMatrix::Constrain()</a>, <a class="el" href="essentialmatrix_8cpp_source.html#l00157">VW::EssentialMatrix::Decompose()</a>, <a class="el" href="fmatrix_8cpp_source.html#l00046">VW::FMatrix::GetEpipoles()</a>, <a class="el" href="essentialmatrix_8cpp_source.html#l00043">VW::EssentialMatrix::GetEpipoles()</a>, <a class="el" href="rotationmatrix_8cpp_source.html#l00233">VW::RotationMatrix::Normalise()</a>, <a class="el" href="rotationmatrix_8cpp_source.html#l00097">VW::RotationMatrix::Set()</a>, and <a class="el" href="svd__inst_8cpp_source.html#l00024">VNL::SVD&lt; T &gt;::SVD()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa333283ff240f5ec65e7f3e360c4398"></a><!-- doxytag: member="VNL::SVD::V" ref="aaa333283ff240f5ec65e7f3e360c4398" args="(int i, int j)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::V </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the matrix V's (i,j)th entry (to avoid svd.V()(i,j); ). </p>

</div>
</div>
<a class="anchor" id="a3846dd100fd8edcec4e34e63022da383"></a><!-- doxytag: member="VNL::SVD::V" ref="a3846dd100fd8edcec4e34e63022da383" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt;T&gt; const&amp; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::V </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the matrix V. </p>

</div>
</div>
<a class="anchor" id="a0c690460d64e2b187ea2e9c1cde8b19b"></a><!-- doxytag: member="VNL::SVD::V" ref="a0c690460d64e2b187ea2e9c1cde8b19b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt;T&gt;&amp; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::V </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the matrix V. </p>

<p>Referenced by <a class="el" href="essentialmatrix_8cpp_source.html#l00066">VW::EssentialMatrix::Constrain()</a>, <a class="el" href="essentialmatrix_8cpp_source.html#l00157">VW::EssentialMatrix::Decompose()</a>, <a class="el" href="fmatrix_8cpp_source.html#l00046">VW::FMatrix::GetEpipoles()</a>, <a class="el" href="essentialmatrix_8cpp_source.html#l00043">VW::EssentialMatrix::GetEpipoles()</a>, <a class="el" href="rotationmatrix_8cpp_source.html#l00233">VW::RotationMatrix::Normalise()</a>, <a class="el" href="rotationmatrix_8cpp_source.html#l00097">VW::RotationMatrix::Set()</a>, and <a class="el" href="svd__inst_8cpp_source.html#l00024">VNL::SVD&lt; T &gt;::SVD()</a>.</p>

</div>
</div>
<a class="anchor" id="a6e24342cce83089c33e83c384f4f9106"></a><!-- doxytag: member="VNL::SVD::Valid" ref="a6e24342cce83089c33e83c384f4f9106" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::Valid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="rotationmatrix_8cpp_source.html#l00233">VW::RotationMatrix::Normalise()</a>.</p>

</div>
</div>
<a class="anchor" id="a642d4e53cb3d2bbe66d6dd8c82815ba5"></a><!-- doxytag: member="VNL::SVD::W" ref="a642d4e53cb3d2bbe66d6dd8c82815ba5" args="(int i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a>&amp; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::W </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a20741ab76a9723dd30dcf7cb113bb480"></a><!-- doxytag: member="VNL::SVD::W" ref="a20741ab76a9723dd30dcf7cb113bb480" args="(int i, int j)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a>&amp; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::W </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>j</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7528f27ee5be76797caac1d6523f0c95"></a><!-- doxytag: member="VNL::SVD::W" ref="a7528f27ee5be76797caac1d6523f0c95" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1DiagMatrix.html">DiagMatrix</a>&lt;<a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a>&gt; const&amp; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::W </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get at <a class="el" href="classVNL_1_1DiagMatrix.html" title="stores a diagonal matrix as a single vector.">DiagMatrix</a> (<a class="el" href="vector_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">q.v</a>. </p>
<p>) of singular values, sorted from largest to smallest. </p>

</div>
</div>
<a class="anchor" id="a519593095e3e1baa735c0589e1b0dc98"></a><!-- doxytag: member="VNL::SVD::W" ref="a519593095e3e1baa735c0589e1b0dc98" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1DiagMatrix.html">DiagMatrix</a>&lt;<a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a>&gt;&amp; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::W </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get at <a class="el" href="classVNL_1_1DiagMatrix.html" title="stores a diagonal matrix as a single vector.">DiagMatrix</a> (<a class="el" href="vector_8h.html#a38bf1e5e0427bdeba2b469eea9befc23">q.v</a>. </p>
<p>) of singular values, sorted from largest to smallest. </p>

<p>Referenced by <a class="el" href="fmatrix_8cpp_source.html#l00069">VW::FMatrix::Constrain()</a>, <a class="el" href="essentialmatrix_8cpp_source.html#l00157">VW::EssentialMatrix::Decompose()</a>, <a class="el" href="svd_8tpp_source.html#l00239">VNL::SVD&lt; T &gt;::Recompose()</a>, and <a class="el" href="svd__inst_8cpp_source.html#l00024">VNL::SVD&lt; T &gt;::SVD()</a>.</p>

</div>
</div>
<a class="anchor" id="a664c4a9046a560a1be618cdb6a920075"></a><!-- doxytag: member="VNL::SVD::WellCondition" ref="a664c4a9046a560a1be618cdb6a920075" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a> <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::WellCondition </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="svd_8h_source.html#l00139">VNL::SVD&lt; T &gt;::SigmaMax()</a>, and <a class="el" href="svd_8h_source.html#l00140">VNL::SVD&lt; T &gt;::SigmaMin()</a>.</p>

</div>
</div>
<a class="anchor" id="ae0cb2e2980b3971490d0e7486abebe0b"></a><!-- doxytag: member="VNL::SVD::Winverse" ref="ae0cb2e2980b3971490d0e7486abebe0b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1DiagMatrix.html">VNL::DiagMatrix</a>&lt;<a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a>&gt; const&amp; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::Winverse </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="svd_8tpp_source.html#l00260">VNL::SVD&lt; T &gt;::PseudoInverse()</a>, and <a class="el" href="svd_8tpp_source.html#l00287">VNL::SVD&lt; T &gt;::TransposeInverse()</a>.</p>

</div>
</div>
<a class="anchor" id="a665f75bca4e3ef57ea68417dabda635e"></a><!-- doxytag: member="VNL::SVD::WInverse" ref="a665f75bca4e3ef57ea68417dabda635e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1DiagMatrix.html">DiagMatrix</a>&lt;<a class="el" href="classVNL_1_1SVD.html#a373ab360ec1ded8fb7f26db4b69350a9">singval_t</a>&gt;&amp; <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::WInverse </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad562a0661eba348720d78ed09bb0410d"></a><!-- doxytag: member="VNL::SVD::ZeroOutAbsolute" ref="ad562a0661eba348720d78ed09bb0410d" args="(double tol=1e&#45;8)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::ZeroOutAbsolute </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em> = <code>1e-8</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>find weights below threshold tol, zero them out, and update W_ and Winverse_. </p>

<p>References <a class="el" href="bignum_8h_source.html#l00387">std::abs()</a>, and <a class="el" href="diagmatrix_8h_source.html#l00103">VNL::DiagMatrix&lt; T &gt;::Rows()</a>.</p>

<p>Referenced by <a class="el" href="svd_8tpp_source.html#l00042">VNL::SVD&lt; T &gt;::SVD()</a>, and <a class="el" href="svd_8tpp_source.html#l00205">VNL::SVD&lt; T &gt;::ZeroOutRelative()</a>.</p>

</div>
</div>
<a class="anchor" id="a9cc8502c0e3cdc831ef4b310a4341941"></a><!-- doxytag: member="VNL::SVD::ZeroOutRelative" ref="a9cc8502c0e3cdc831ef4b310a4341941" args="(double tol=1e&#45;8)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1SVD.html">VNL::SVD</a>&lt; T &gt;::ZeroOutRelative </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em> = <code>1e-8</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>find weights below tol*max(w) and zero them out. </p>

<p>References <a class="el" href="bignum_8h_source.html#l00387">std::abs()</a>, <a class="el" href="svd_8h_source.html#l00139">VNL::SVD&lt; T &gt;::SigmaMax()</a>, and <a class="el" href="svd_8tpp_source.html#l00187">VNL::SVD&lt; T &gt;::ZeroOutAbsolute()</a>.</p>

<p>Referenced by <a class="el" href="svd_8tpp_source.html#l00042">VNL::SVD&lt; T &gt;::SVD()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="svd_8h_source.html">svd.h</a></li>
<li><a class="el" href="svd_8tpp.html">svd.tpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Mar 21 09:55:51 2010 for VW by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>

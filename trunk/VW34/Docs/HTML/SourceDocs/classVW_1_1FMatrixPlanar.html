<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VW: VW::FMatrixPlanar Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen_vw.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
  <div class="navpath"><a class="el" href="namespaceVW.html">VW</a>::<a class="el" href="classVW_1_1FMatrixPlanar.html">FMatrixPlanar</a>
  </div>
<div class="contents">
<h1>VW::FMatrixPlanar Class Reference<br/>
<small>
[<a class="el" href="group__GeometricObjects.html">GeometricObjects</a>]</small>
</h1><!-- doxytag: class="VW::FMatrixPlanar" --><!-- doxytag: inherits="VW::FMatrix" -->
<p>A class to represent the specialisation of the fundamental matrix due to camera motion in a plane.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="fmatrixplanar_8h_source.html">fmatrixplanar.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for VW::FMatrixPlanar:</div>
<div class="dynsection">
 <div class="center">
  <img src="classVW_1_1FMatrixPlanar.gif" usemap="#VW::FMatrixPlanar_map" alt=""/>
  <map id="VW::FMatrixPlanar_map" name="VW::FMatrixPlanar_map">
<area href="classVW_1_1FMatrix.html" alt="VW::FMatrix" shape="rect" coords="117,168,341,192"/>
<area href="classVW_1_1Transform.html" alt="VW::Transform" shape="rect" coords="0,112,224,136"/>
<area href="classVNL_1_1MatrixFixed.html" alt="VNL::MatrixFixed&lt; 3, 3, double &gt;" shape="rect" coords="234,112,458,136"/>
<area href="classVNL_1_1MatrixFixedRef.html" alt="VNL::MatrixFixedRef&lt; m, n, double &gt;" shape="rect" coords="234,56,458,80"/>
<area href="classVNL_1_1Matrix.html" alt="VNL::Matrix&lt; double &gt;" shape="rect" coords="234,0,458,24"/>
</map>
 </div>
</div>

<p><a href="classVW_1_1FMatrixPlanar-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CVector&lt; double &gt;::<a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type def for norms.  <a href="#a34d7b88b6e43815aa9ba7b9ba833ba77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#acafd662b2adb865bf437c9db33cbfb26">element_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a06cbb6154eff4ab9a4aa104e14c88431">iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterators.  <a href="#a06cbb6154eff4ab9a4aa104e14c88431"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef doubleconst *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a6235d47d391413ca573e3a93b6f35d59">const_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Const iterators.  <a href="#a6235d47d391413ca573e3a93b6f35d59"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrixPlanar.html#af7d2373853e47c106ff0a6fc1ceb7a8d">FMatrixPlanar</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrixPlanar.html#a80e1d9515184af08421c515ce73dde38">FMatrixPlanar</a> (const <a class="el" href="classVW_1_1FMatrix.html">FMatrix</a> &amp;F)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrixPlanar.html#a93af275babd46334f492362ace364e96">FMatrixPlanar</a> (const <a class="el" href="classVNL_1_1MatrixFixed.html">VNL::MatrixFixed</a>&lt; 3, 3, double &gt; &amp;M)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVW_1_1FMatrixPlanar.html">FMatrixPlanar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrixPlanar.html#a05a137f7e460445c3531bee431aa7da5">operator=</a> (const <a class="el" href="classVW_1_1FMatrix.html">FMatrix</a> &amp;F)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVW_1_1FMatrixPlanar.html">FMatrixPlanar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrixPlanar.html#a86a63d168735339875022c8355ef16d6">operator=</a> (const <a class="el" href="classVNL_1_1MatrixFixed.html">VNL::MatrixFixed</a>&lt; 3, 3, double &gt; m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVW_1_1FMatrixPlanar.html">FMatrixPlanar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrixPlanar.html#af9164c0e31ee897a1b44b2524edcad20">operator=</a> (const <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double &gt; m)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrixPlanar.html#aa21a7f4b3e312facce63b4e5ee38baa6">Constrain</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classVW_1_1FMatrixPlanar.html#aa21a7f4b3e312facce63b4e5ee38baa6" title="FMatrixPlanar::Constrain () -- Constrain to rank 2 (singularity condition).">FMatrixPlanar::Constrain</a> () -- Constrain to rank 2 (singularity condition).  <a href="#aa21a7f4b3e312facce63b4e5ee38baa6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVW_1_1Line2D.html">VW::Line2D</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrix.html#aae8edfae1154aa3f820bd5bf8d8dc87d">Transfer</a> (const <a class="el" href="classVW_1_1Point2D.html">VW::Point2D</a> &amp;point) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVW_1_1Line2D.html">VW::Line2D</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrix.html#a4ef128e2b04c38f9fc79429cea5f7081">ReverseTransfer</a> (const <a class="el" href="classVW_1_1Point2D.html">VW::Point2D</a> &amp;point) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ElementType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrix.html#a60457e945b5b983b3a4e9fbfa0653a06">TransferPoint</a> (const ElementType &amp;point, <a class="el" href="classVW_1_1Line2D.html">VW::Line2D</a> &amp;eline) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ElementType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrix.html#af45a131fc2029cfba95673e2455e16e6">ReverseTransferPoint</a> (const ElementType &amp;point, <a class="el" href="classVW_1_1Line2D.html">VW::Line2D</a> &amp;eline) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrix.html#a0980ec1f870f7e0930f28f9f7dbcf394">GetEpipoles</a> (<a class="el" href="classVW_1_1Point2D.html">VW::Point2D</a> &amp;e1, <a class="el" href="classVW_1_1Point2D.html">VW::Point2D</a> &amp;e2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1MatrixFixed.html">VNL::MatrixFixed</a>&lt; 3, 3, double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrix.html#ab8c2b1174d46e86630d2393bcbb4d9a6">AsMatrix</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrix.html#a9dbad2a14390164261b1a0141b5b0e50">GetMinFeatures</a> (const F &amp;f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrix.html#a427df299ada8419d28d7e6d81ed865de">GetNumViews</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrix.html#aafff6b75cc433617cd00576ad184e475">operator&lt;&lt;</a> (std::ostream &amp;stream) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1MatrixFixedRef.html#af080a0023d9f6630e4585d8b383b8710">resize</a> (unsigned int, unsigned int)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resizing a vnl_matrix_ref fails.  <a href="#af080a0023d9f6630e4585d8b383b8710"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aff5c94adfdf10c50c421097ae55c055e">Rows</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of rows.  <a href="#aff5c94adfdf10c50c421097ae55c055e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#add52389f027d9a631813400db620f162">Columns</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of columns.  <a href="#add52389f027d9a631813400db620f162"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ad63ed64557a003f336a5ff0dca39ee72">Cols</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of columns.  <a href="#ad63ed64557a003f336a5ff0dca39ee72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#acc663489b8784632af9b648a67d7740b">Size</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of elements.  <a href="#acc663489b8784632af9b648a67d7740b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a38883927f7b47ec3f8c7e88e41f6ebdd">size</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return number of elements.  <a href="#a38883927f7b47ec3f8c7e88e41f6ebdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a4b3228f51e4a445a651a529f49aaeb9d">Put</a> (unsigned r, unsigned c, doubleconst &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set element with boundary checks if error checking is on.  <a href="#a4b3228f51e4a445a651a529f49aaeb9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a3af3fc536ac0f6b7bbc6ce05010b29d7">Get</a> (unsigned r, unsigned c) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get element with boundary checks if error checking is on.  <a href="#a3af3fc536ac0f6b7bbc6ce05010b29d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#acfbe7f98f9bd824ff8d642ace7395f6e">operator[]</a> (unsigned r)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return pointer to given row.  <a href="#acfbe7f98f9bd824ff8d642ace7395f6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">doubleconst *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#adf099168a9c6309e99f1ae786990def8">operator[]</a> (unsigned r) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return pointer to given row.  <a href="#adf099168a9c6309e99f1ae786990def8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aa0d12208d46190033757830a17aa0046">operator()</a> (unsigned r, unsigned c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access an element for reading or writing.  <a href="#aa0d12208d46190033757830a17aa0046"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">doubleconst &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a51ae5629bc2b2d798d794df622e74b39">operator()</a> (unsigned r, unsigned c) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access an element for reading.  <a href="#a51ae5629bc2b2d798d794df622e74b39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#abebe72526015607ee129e2d4687bc7e2">Fill</a> (doubleconst &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set all elements of matrix to specified value.  <a href="#abebe72526015607ee129e2d4687bc7e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a8d451a78fc2585574896abac68e4c008">FillDiagonal</a> (doubleconst &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set all diagonal elements of matrix to specified value.  <a href="#a8d451a78fc2585574896abac68e4c008"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#afeb71efdf105aed29b5d726eb0a2f915">CopyIn</a> (doubleconst *)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill (laminate) this matrix with the given data.  <a href="#afeb71efdf105aed29b5d726eb0a2f915"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aa211aa5409bc801d0fed44d65c25dd20">Set</a> (doubleconst *d)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill (laminate) this matrix with the given data.  <a href="#aa211aa5409bc801d0fed44d65c25dd20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aac98f4f0c40b2bb0899d2eea24565054">CopyOut</a> (double *) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fill the given array with this matrix.  <a href="#aac98f4f0c40b2bb0899d2eea24565054"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a0911f03689d46fa04ea2d39732fbb279">operator+=</a> (doublevalue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add rhs to each element of lhs matrix in situ.  <a href="#a0911f03689d46fa04ea2d39732fbb279"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a1477b046be621c17db6ab42ff3d352b3">operator+=</a> (Matrix&lt; double &gt; const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add rhs to lhs matrix in situ.  <a href="#a1477b046be621c17db6ab42ff3d352b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aa3cbbc42d832538eba3923c822270a37">operator-=</a> (doublevalue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract rhs from each element of lhs matrix in situ.  <a href="#aa3cbbc42d832538eba3923c822270a37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a08d9aa32756c09656774d0e1524d96e2">operator-=</a> (Matrix&lt; double &gt; const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract rhs from lhs matrix in situ.  <a href="#a08d9aa32756c09656774d0e1524d96e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aa25de30c7bec38b9e7d4d68897a16c9f">operator*=</a> (doublevalue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scalar multiplication in situ of lhs matrix by rhs.  <a href="#aa25de30c7bec38b9e7d4d68897a16c9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ab72f951f10015a1c640473f453b81a8f">operator*=</a> (Matrix&lt; double &gt; const &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiply lhs matrix in situ by rhs.  <a href="#ab72f951f10015a1c640473f453b81a8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a829bdb4502e89901e406ec8d9f2c3575">operator/=</a> (doublevalue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scalar division of lhs matrix in situ by rhs.  <a href="#a829bdb4502e89901e406ec8d9f2c3575"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ab871cf6a47e22652615c6f48461df4e8">operator-</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negate all elements of matrix.  <a href="#ab871cf6a47e22652615c6f48461df4e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a8b4d5a955e42f3fb3c54c499006ba9b8">operator-</a> (doubleconst &amp;v) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subtract rhs from each element of lhs matrix and return result in new matrix.  <a href="#a8b4d5a955e42f3fb3c54c499006ba9b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a8abcfc4fbc2c1e740f33205fee765d0f">operator-</a> (Matrix&lt; double &gt; const &amp;rhs) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matrix subtract rhs from lhs and return result in new matrix.  <a href="#a8abcfc4fbc2c1e740f33205fee765d0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ac61fc52d0ff23284bc7cf80e92ed745c">operator+</a> (doubleconst &amp;v) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add rhs to each element of lhs matrix and return result in new matrix.  <a href="#ac61fc52d0ff23284bc7cf80e92ed745c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a6d7e026a1d1ffa09b127931b1ba61fd7">operator+</a> (Matrix&lt; double &gt; const &amp;rhs) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matrix add rhs to lhs matrix and return result in new matrix.  <a href="#a6d7e026a1d1ffa09b127931b1ba61fd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a609fc3a2ffb60df4c1128df41c5ea101">operator*</a> (doubleconst &amp;v) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scalar multiplication of lhs matrix by rhs and return result in new matrix.  <a href="#a609fc3a2ffb60df4c1128df41c5ea101"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ac3f61ef87d7084a78510d8c2aedf78d3">operator*</a> (Matrix&lt; double &gt; const &amp;rhs) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matrix multiply lhs by rhs matrix and return result in new matrix.  <a href="#ac3f61ef87d7084a78510d8c2aedf78d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a97bdea276efcc84a7556429f07061d9b">operator/</a> (doubleconst &amp;v) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scalar division of lhs matrix by rhs and return result in new matrix.  <a href="#a97bdea276efcc84a7556429f07061d9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a7c95a6fc9f329a9f8bb0197243219a5e">Apply</a> (double(*f)(double)) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a new matrix by applying function to each element.  <a href="#a7c95a6fc9f329a9f8bb0197243219a5e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a217e6df8c3e79ffad8c8ef50256a660b">Apply</a> (double(*f)(doubleconst &amp;)) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a new matrix by applying function to each element.  <a href="#a217e6df8c3e79ffad8c8ef50256a660b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a7c5d1b0934192972fa6c77c8aa0f4c04">Transpose</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return transpose.  <a href="#a7c5d1b0934192972fa6c77c8aa0f4c04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ac0fecc5000343427236e3bbe55c9caf0">ConjugateTranspose</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return conjugate transpose.  <a href="#ac0fecc5000343427236e3bbe55c9caf0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a16b330765547529c3dffe01a9d3220a6">Update</a> (Matrix&lt; double &gt; const &amp;, unsigned top=0, unsigned left=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set values of this matrix to those of M, starting at [top,left].  <a href="#a16b330765547529c3dffe01a9d3220a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#af37d6c7e5f69eeb882d0485d2a1fff7c">SetColumn</a> (unsigned i, doubleconst *v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the elements of the i'th column to v[j] (No bounds checking).  <a href="#af37d6c7e5f69eeb882d0485d2a1fff7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ac8b884756ccd26369f114543b2f9e066">SetColumn</a> (unsigned i, doublevalue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the elements of the i'th column to value.  <a href="#ac8b884756ccd26369f114543b2f9e066"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a3709e2eaea0b9eb4197c2f3b72167ba3">SetColumn</a> (unsigned j, Vector&lt; double &gt; const &amp;v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set j-th colum to v.  <a href="#a3709e2eaea0b9eb4197c2f3b72167ba3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aa008e53c4cff6449118e28d8308959f7">SetColumns</a> (unsigned starting_column, Matrix&lt; double &gt; const &amp;M)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set columns to those in M, starting at starting_column.  <a href="#aa008e53c4cff6449118e28d8308959f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#af707998ccb85f8d61b95480a28176de5">SetRow</a> (unsigned i, doubleconst *v)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the elements of the i'th row to v[j] (No bounds checking).  <a href="#af707998ccb85f8d61b95480a28176de5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ac8b55c00bcb24d7fcf2d68de80c0214e">SetRow</a> (unsigned i, doublevalue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the elements of the i'th row to value.  <a href="#ac8b55c00bcb24d7fcf2d68de80c0214e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a0cea699795ff2ee5ecf6aa633c49422f">SetRow</a> (unsigned i, Vector&lt; double &gt; const &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the i-th row.  <a href="#a0cea699795ff2ee5ecf6aa633c49422f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a2c98629ea08b40937333f8748f0a6302">Extract</a> (unsigned rows, unsigned cols, unsigned top=0, unsigned left=0) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract a sub-matrix of size rows x cols, starting at (top,left).  <a href="#a2c98629ea08b40937333f8748f0a6302"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#afb919d16fb23272d7eab455f354850b7">GetRow</a> (unsigned row) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a vector equal to the given row.  <a href="#afb919d16fb23272d7eab455f354850b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#af375829bf73f5fa22f9850f5baf506f7">GetColumn</a> (unsigned col) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a vector equal to the given column.  <a href="#af375829bf73f5fa22f9850f5baf506f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a58a59fd9cf8b6d0ba980dafc417e1919">GetNRows</a> (unsigned rowstart, unsigned n) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get n rows beginning at rowstart.  <a href="#a58a59fd9cf8b6d0ba980dafc417e1919"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Matrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#af9c364e71f7fb25698a68e6b9eea119d">GetNColumns</a> (unsigned colstart, unsigned n) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get n columns beginning at colstart.  <a href="#af9c364e71f7fb25698a68e6b9eea119d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a75233a9e40259eac0bb7e1f0cf849cf9">SetIdentity</a> (doubleval=double(1))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set this matrix to an identity (or diagonal) matrix.  <a href="#a75233a9e40259eac0bb7e1f0cf849cf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a4cd44931db0fb741dfdf85801eaa88df">InplaceTranspose</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transpose this matrix efficiently.  <a href="#a4cd44931db0fb741dfdf85801eaa88df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ae48802566d7d5996c3de908a03884b13">FlipUD</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverse order of rows.  <a href="#ae48802566d7d5996c3de908a03884b13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a3e86c8f6fb3958ff7d536be32a5b065c">FlipLR</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverse order of columns.  <a href="#a3e86c8f6fb3958ff7d536be32a5b065c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aa9d7c8321f1342c39e804de6656c5204">NormalizeRows</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize each row so it is a unit vector.  <a href="#aa9d7c8321f1342c39e804de6656c5204"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#acdb264e08aaa86e5ad6a992299510700">NormalizeColumns</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize each column so it is a unit vector.  <a href="#acdb264e08aaa86e5ad6a992299510700"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a4e9f7b2c295c2b992efc0a94bf4808f2">ScaleRow</a> (unsigned row, doublevalue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scale elements in given row by a factor of T.  <a href="#a4e9f7b2c295c2b992efc0a94bf4808f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ae87be7fafd426f9ee5f7567663c79078">ScaleColumn</a> (unsigned col, doublevalue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scale elements in given column by a factor of T.  <a href="#ae87be7fafd426f9ee5f7567663c79078"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a2f3c40b3a1e7f2b09cc567f820f36849">Swap</a> (Matrix&lt; double &gt; &amp;that)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap this matrix with that matrix.  <a href="#a2f3c40b3a1e7f2b09cc567f820f36849"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a634092e42eeae1e814146b0009afa914">ArrayOneNorm</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sum of absolute values of elements.  <a href="#a634092e42eeae1e814146b0009afa914"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a1f7dcc0e2369c2c0964e9562d4631bb2">ArrayTwoNorm</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return square root of sum of squared absolute element values.  <a href="#a1f7dcc0e2369c2c0964e9562d4631bb2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ad0fbeb1d59ac1458409904aca44b2396">ArrayInfNorm</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return largest absolute element value.  <a href="#ad0fbeb1d59ac1458409904aca44b2396"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a0df05e3904c3c920f04a5f8afdbbff47">AbsoluteValueSum</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return sum of absolute values of elements.  <a href="#a0df05e3904c3c920f04a5f8afdbbff47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aabe9d927a5fb1ab62ade531476657411">AbsoluteValueMax</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return largest absolute value.  <a href="#aabe9d927a5fb1ab62ade531476657411"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a3307db07670668e0e713d1ae139a9cae">operatorOneNorm</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a0eae6d0de0a9e4b15f33905325f7df52">operatorInfNorm</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a73d64afb4bcb316f06e023b2b1935565">FrobeniusNorm</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return frobenius norm of matrix (sqrt of sum of squares of its elements).  <a href="#a73d64afb4bcb316f06e023b2b1935565"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aa2722f239eb9b210314d40f4b7c77d1c">FroNorm</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return frobenius norm of matrix (sqrt of sum of squares of its elements).  <a href="#aa2722f239eb9b210314d40f4b7c77d1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a35ae0df75f8e397bd6a9100fcf677c26">RMS</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return RMS of all elements.  <a href="#a35ae0df75f8e397bd6a9100fcf677c26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ac5ab77cee1837ed306d744934c5d13df">MinValue</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return minimum value of elements.  <a href="#ac5ab77cee1837ed306d744934c5d13df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a1493fd44296bcfbc4773f538283245af">MaxValue</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return maximum value of elements.  <a href="#a1493fd44296bcfbc4773f538283245af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a9f33a276b125d6cfa7d9fd8e4a1e6d8a">Mean</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return mean of all matrix elements.  <a href="#a9f33a276b125d6cfa7d9fd8e4a1e6d8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a3ac85e6520d6ff3ef4606e0907e9bfac">IsEmpty</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true iff the size is zero.  <a href="#a3ac85e6520d6ff3ef4606e0907e9bfac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#af41eb3b97b367b64bbba36bab9ec2c74">IsIdentity</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if all elements equal to identity.  <a href="#af41eb3b97b367b64bbba36bab9ec2c74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ac4eceaf3f07acc5b986eae5b2b45d33f">IsIdentity</a> (double tol) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if all elements equal to identity, within given tolerance.  <a href="#ac4eceaf3f07acc5b986eae5b2b45d33f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a18897a2283edbe81f212be1e436956c0">IsZero</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if all elements equal to zero.  <a href="#a18897a2283edbe81f212be1e436956c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a56aa9ceb181a20c7f039dece5007d72a">IsZero</a> (double tol) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if all elements equal to zero, within given tolerance.  <a href="#a56aa9ceb181a20c7f039dece5007d72a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a11aec14aa996623f274d4707b2d6be32">IsFinite</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if finite.  <a href="#a11aec14aa996623f274d4707b2d6be32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a99a10121cdbbf6d034897a7de4fe2c26">HasNaNs</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if matrix contains NaNs.  <a href="#a99a10121cdbbf6d034897a7de4fe2c26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a6969051a9c0f635d6f428993bfaa9f4b">assert_size</a> (unsigned rows, unsigned cols) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">abort if size is not as expected.  <a href="#a6969051a9c0f635d6f428993bfaa9f4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a2864a8e27dd897ad1edb41c3439a54e3">assert_finite</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">abort if matrix containins any INFs or NANs.  <a href="#a2864a8e27dd897ad1edb41c3439a54e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a7a6980b7a9f7dc98cff9989874a315d9">ReadASCII</a> (std::istream &amp;s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">doubleconst *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a998b3369c5b384b2a6ecb7711d1908d5">DataBlock</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the contiguous block storing the elements in the matrix row-wise. O(1).  <a href="#a998b3369c5b384b2a6ecb7711d1908d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ab3965a2cb2da2bd6000880cb57ced592">DataBlock</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the contiguous block storing the elements in the matrix row-wise. O(1).  <a href="#ab3965a2cb2da2bd6000880cb57ced592"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">doubleconst *const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a6fd65e9be20311a7eb6cd6d41aee165c">DataArray</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the 2D array, so that elements can be accessed with array[row][col] directly.  <a href="#a6fd65e9be20311a7eb6cd6d41aee165c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a85e69ba573321510ec08c639d13a404e">DataArray</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the 2D array, so that elements can be accessed with array[row][col] directly.  <a href="#a85e69ba573321510ec08c639d13a404e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a06cbb6154eff4ab9a4aa104e14c88431">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a219c6230062678233916d5c5d4d53757">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator pointing to start of data.  <a href="#a219c6230062678233916d5c5d4d53757"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a6235d47d391413ca573e3a93b6f35d59">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a9a588e20ba3d6db3a00ea8059c0a5c3d">begin</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator pointing to start of data.  <a href="#a9a588e20ba3d6db3a00ea8059c0a5c3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a06cbb6154eff4ab9a4aa104e14c88431">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a35920c1f1f6487229aeb25015b982a9c">end</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator pointing to element beyond end of data.  <a href="#a35920c1f1f6487229aeb25015b982a9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVNL_1_1Matrix.html#a6235d47d391413ca573e3a93b6f35d59">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ad32ecc9db9edf97c6212228352b85f7a">end</a> () const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator pointing to element beyond end of data.  <a href="#ad32ecc9db9edf97c6212228352b85f7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a3bd270c6cbcfb5fe7e1ea9cb28672dc6">operator_eq</a> (Matrix&lt; double &gt; const &amp;rhs) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return true if *this == rhs.  <a href="#a3bd270c6cbcfb5fe7e1ea9cb28672dc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a0cdbeca4b99a73ba13e618e352c58493">operator==</a> (Matrix&lt; double &gt; const &amp;that) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality operator.  <a href="#a0cdbeca4b99a73ba13e618e352c58493"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a78669d703385e313e0ad6a501028477d">operator!=</a> (Matrix&lt; double &gt; const &amp;that) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality operator.  <a href="#a78669d703385e313e0ad6a501028477d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aebbe2d0d79a10b0732d1ad7261cb10bb">print</a> (std::ostream &amp;os) const</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print matrix to os in some hopefully sensible format.  <a href="#aebbe2d0d79a10b0732d1ad7261cb10bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a976dea052cf6a822270d1b1f1962d2f8">Clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make the matrix as if it had been default-constructed.  <a href="#a976dea052cf6a822270d1b1f1962d2f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ad3221c841512da857742c2cdc8cb53f0">Resize</a> (unsigned r, unsigned c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resize to r rows by c columns. Old data lost.  <a href="#ad3221c841512da857742c2cdc8cb53f0"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Matrix&lt; double &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a1dc673309070ddaffc84a8985ee939f0">Read</a> (std::istream &amp;s)</td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrix.html#a9e2c90d6bb01a12921c74fe39dd7440d">MIN_POINTSET_SIZE</a> = 7</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrix.html#a5c190b4e2f78d4d0ba046c19730b7bad">MIN_LINESET_SIZE</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrix.html#ac59691ac1bce954bf0d136023b20edac">NUM_VIEWS</a> = 2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const char *const&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1FMatrix.html#aafcfc0276d08bc9d6017277c37d13ca0">NAME</a> = &quot;FMatrix&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVW_1_1Transform.html#a27de974eac35a79aa41281fc3c3b8a92">MIN_SET_SIZE</a> = 4</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ad4ca59ce3f2bbec2c0111b1a4c35cfc2">assert_size_internal</a> (unsigned rows, unsigned cols) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#ab482094e4fb6dc6d6dcf134d1e39253e">assert_finite_internal</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#aafd89e336f8e0b9ff934de98825fff1b">destroy</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete data.  <a href="#aafd89e336f8e0b9ff934de98825fff1b"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a3caa4ee02f27a6e3790fa9b7bc9ead0f">inline_function_tickler</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a3127ff55911a8a63e45247949a7692d3">num_rows</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#af91a774473dbda01863adad84753302f">num_cols</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVNL_1_1Matrix.html#a394794c6c1f9a966c3b222c7ea7e177a">data</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A class to represent the specialisation of the fundamental matrix due to camera motion in a plane. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>JGH Knight </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>02/08/02 When the camera only moves in a plane (translates in the plane and rotates about an axis perpendicular to it), as is typical for ground vehicles, the fundamental matrix has only 6 degrees of freedom. This is done by forcing the both F, and (F + F') (its symmetric part) to be rank 2. </dd></dl>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a34d7b88b6e43815aa9ba7b9ba833ba77"></a><!-- doxytag: member="VW::FMatrixPlanar::abs_t" ref="a34d7b88b6e43815aa9ba7b9ba833ba77" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef CVector&lt;double &gt;::<a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::<a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type def for norms. </p>

</div>
</div>
<a class="anchor" id="a6235d47d391413ca573e3a93b6f35d59"></a><!-- doxytag: member="VW::FMatrixPlanar::const_iterator" ref="a6235d47d391413ca573e3a93b6f35d59" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double  const* <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::<a class="el" href="classVNL_1_1Matrix.html#a6235d47d391413ca573e3a93b6f35d59">const_iterator</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Const iterators. </p>

</div>
</div>
<a class="anchor" id="acafd662b2adb865bf437c9db33cbfb26"></a><!-- doxytag: member="VW::FMatrixPlanar::element_type" ref="acafd662b2adb865bf437c9db33cbfb26" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double  <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::<a class="el" href="classVNL_1_1Matrix.html#acafd662b2adb865bf437c9db33cbfb26">element_type</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a06cbb6154eff4ab9a4aa104e14c88431"></a><!-- doxytag: member="VW::FMatrixPlanar::iterator" ref="a06cbb6154eff4ab9a4aa104e14c88431" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double * <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::<a class="el" href="classVNL_1_1Matrix.html#a06cbb6154eff4ab9a4aa104e14c88431">iterator</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterators. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af7d2373853e47c106ff0a6fc1ceb7a8d"></a><!-- doxytag: member="VW::FMatrixPlanar::FMatrixPlanar" ref="af7d2373853e47c106ff0a6fc1ceb7a8d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VW::FMatrixPlanar::FMatrixPlanar </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="fmatrixplanar_8cpp_source.html#l00051">Constrain()</a>.</p>

</div>
</div>
<a class="anchor" id="a80e1d9515184af08421c515ce73dde38"></a><!-- doxytag: member="VW::FMatrixPlanar::FMatrixPlanar" ref="a80e1d9515184af08421c515ce73dde38" args="(const FMatrix &amp;F)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VW::FMatrixPlanar::FMatrixPlanar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVW_1_1FMatrix.html">FMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>F</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="fmatrixplanar_8cpp_source.html#l00051">Constrain()</a>.</p>

</div>
</div>
<a class="anchor" id="a93af275babd46334f492362ace364e96"></a><!-- doxytag: member="VW::FMatrixPlanar::FMatrixPlanar" ref="a93af275babd46334f492362ace364e96" args="(const VNL::MatrixFixed&lt; 3, 3, double &gt; &amp;M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VW::FMatrixPlanar::FMatrixPlanar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVNL_1_1MatrixFixed.html">VNL::MatrixFixed</a>&lt; 3, 3, double &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="fmatrixplanar_8cpp_source.html#l00051">Constrain()</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aabe9d927a5fb1ab62ade531476657411"></a><!-- doxytag: member="VW::FMatrixPlanar::AbsoluteValueMax" ref="aabe9d927a5fb1ab62ade531476657411" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::AbsoluteValueMax </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return largest absolute value. </p>

</div>
</div>
<a class="anchor" id="a0df05e3904c3c920f04a5f8afdbbff47"></a><!-- doxytag: member="VW::FMatrixPlanar::AbsoluteValueSum" ref="a0df05e3904c3c920f04a5f8afdbbff47" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::AbsoluteValueSum </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return sum of absolute values of elements. </p>

</div>
</div>
<a class="anchor" id="a217e6df8c3e79ffad8c8ef50256a660b"></a><!-- doxytag: member="VW::FMatrixPlanar::Apply" ref="a217e6df8c3e79ffad8c8ef50256a660b" args="(double(*f)(doubleconst &amp;)) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Apply </td>
          <td>(</td>
          <td class="paramtype">double (*)(double  const &amp;)&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a new matrix by applying function to each element. </p>
<p>Return the matrix made by applying "f" to each element. </p>

</div>
</div>
<a class="anchor" id="a7c95a6fc9f329a9f8bb0197243219a5e"></a><!-- doxytag: member="VW::FMatrixPlanar::Apply" ref="a7c95a6fc9f329a9f8bb0197243219a5e" args="(double(*f)(double)) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Apply </td>
          <td>(</td>
          <td class="paramtype">double (*)(double )&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a new matrix by applying function to each element. </p>
<p>Return the matrix made by applying "f" to each element. </p>

</div>
</div>
<a class="anchor" id="ad0fbeb1d59ac1458409904aca44b2396"></a><!-- doxytag: member="VW::FMatrixPlanar::ArrayInfNorm" ref="ad0fbeb1d59ac1458409904aca44b2396" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::ArrayInfNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return largest absolute element value. </p>

</div>
</div>
<a class="anchor" id="a634092e42eeae1e814146b0009afa914"></a><!-- doxytag: member="VW::FMatrixPlanar::ArrayOneNorm" ref="a634092e42eeae1e814146b0009afa914" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::ArrayOneNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return sum of absolute values of elements. </p>

</div>
</div>
<a class="anchor" id="a1f7dcc0e2369c2c0964e9562d4631bb2"></a><!-- doxytag: member="VW::FMatrixPlanar::ArrayTwoNorm" ref="a1f7dcc0e2369c2c0964e9562d4631bb2" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::ArrayTwoNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return square root of sum of squared absolute element values. </p>

</div>
</div>
<a class="anchor" id="ab8c2b1174d46e86630d2393bcbb4d9a6"></a><!-- doxytag: member="VW::FMatrixPlanar::AsMatrix" ref="ab8c2b1174d46e86630d2393bcbb4d9a6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1MatrixFixed.html">VNL::MatrixFixed</a>&lt;3,3,double&gt; VW::FMatrix::AsMatrix </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="fmatrixplanar_8cpp_source.html#l00051">Constrain()</a>, <a class="el" href="fmatrixcomputenonlinear_8cpp_source.html#l00043">VW::FMatrixCompute::GenerateParameterVector()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00032">VW::FMPlanarCompute::GenerateParameterVectorHZ()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00224">VW::FMPlanarCompute::GenerateParameterVectorHZJK()</a>, <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00118">VW::FMPlanarCompute::GenerateParameterVectorVLJK()</a>, <a class="el" href="fmatrix_8h_source.html#l00215">VW::FMatrix::ReverseTransferPoint()</a>, and <a class="el" href="fmatrix_8h_source.html#l00199">VW::FMatrix::TransferPoint()</a>.</p>

</div>
</div>
<a class="anchor" id="a2864a8e27dd897ad1edb41c3439a54e3"></a><!-- doxytag: member="VW::FMatrixPlanar::assert_finite" ref="a2864a8e27dd897ad1edb41c3439a54e3" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::assert_finite </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>abort if matrix containins any INFs or NANs. </p>
<p>This function does or tests nothing if NDEBUG is defined </p>

</div>
</div>
<a class="anchor" id="ab482094e4fb6dc6d6dcf134d1e39253e"></a><!-- doxytag: member="VW::FMatrixPlanar::assert_finite_internal" ref="ab482094e4fb6dc6d6dcf134d1e39253e" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::assert_finite_internal </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abort if any element of M is inf or nan. </p>

</div>
</div>
<a class="anchor" id="a6969051a9c0f635d6f428993bfaa9f4b"></a><!-- doxytag: member="VW::FMatrixPlanar::assert_size" ref="a6969051a9c0f635d6f428993bfaa9f4b" args="(unsigned rows, unsigned cols) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::assert_size </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>cols</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>abort if size is not as expected. </p>
<p>This function does or tests nothing if NDEBUG is defined </p>

</div>
</div>
<a class="anchor" id="ad4ca59ce3f2bbec2c0111b1a4c35cfc2"></a><!-- doxytag: member="VW::FMatrixPlanar::assert_size_internal" ref="ad4ca59ce3f2bbec2c0111b1a4c35cfc2" args="(unsigned rows, unsigned cols) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::assert_size_internal </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>cols</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abort unless M has the given size. </p>

</div>
</div>
<a class="anchor" id="a9a588e20ba3d6db3a00ea8059c0a5c3d"></a><!-- doxytag: member="VW::FMatrixPlanar::begin" ref="a9a588e20ba3d6db3a00ea8059c0a5c3d" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a6235d47d391413ca573e3a93b6f35d59">const_iterator</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator pointing to start of data. </p>

</div>
</div>
<a class="anchor" id="a219c6230062678233916d5c5d4d53757"></a><!-- doxytag: member="VW::FMatrixPlanar::begin" ref="a219c6230062678233916d5c5d4d53757" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a06cbb6154eff4ab9a4aa104e14c88431">iterator</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator pointing to start of data. </p>

</div>
</div>
<a class="anchor" id="a976dea052cf6a822270d1b1f1962d2f8"></a><!-- doxytag: member="VW::FMatrixPlanar::Clear" ref="a976dea052cf6a822270d1b1f1962d2f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make the matrix as if it had been default-constructed. </p>

</div>
</div>
<a class="anchor" id="ad63ed64557a003f336a5ff0dca39ee72"></a><!-- doxytag: member="VW::FMatrixPlanar::Cols" ref="ad63ed64557a003f336a5ff0dca39ee72" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Cols </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return number of columns. </p>
<p>A synonym for columns() </p>

</div>
</div>
<a class="anchor" id="add52389f027d9a631813400db620f162"></a><!-- doxytag: member="VW::FMatrixPlanar::Columns" ref="add52389f027d9a631813400db620f162" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Columns </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return number of columns. </p>
<p>A synonym for cols() </p>

</div>
</div>
<a class="anchor" id="ac0fecc5000343427236e3bbe55c9caf0"></a><!-- doxytag: member="VW::FMatrixPlanar::ConjugateTranspose" ref="ac0fecc5000343427236e3bbe55c9caf0" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::ConjugateTranspose </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return conjugate transpose. </p>

</div>
</div>
<a class="anchor" id="aa21a7f4b3e312facce63b4e5ee38baa6"></a><!-- doxytag: member="VW::FMatrixPlanar::Constrain" ref="aa21a7f4b3e312facce63b4e5ee38baa6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VW::FMatrixPlanar::Constrain </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classVW_1_1FMatrixPlanar.html#aa21a7f4b3e312facce63b4e5ee38baa6" title="FMatrixPlanar::Constrain () -- Constrain to rank 2 (singularity condition).">FMatrixPlanar::Constrain</a> () -- Constrain to rank 2 (singularity condition). </p>
<p>Enforces the singularity conditions on the fundamental matrix using the SVD. </p>

<p>Reimplemented from <a class="el" href="classVW_1_1FMatrix.html#adb1504fb64c4479026e838c248825987">VW::FMatrix</a>.</p>

<p>References <a class="el" href="fmatrix_8h_source.html#l00087">VW::FMatrix::AsMatrix()</a>.</p>

<p>Referenced by <a class="el" href="fmatrixplanar_8h_source.html#l00051">FMatrixPlanar()</a>.</p>

</div>
</div>
<a class="anchor" id="afeb71efdf105aed29b5d726eb0a2f915"></a><!-- doxytag: member="VW::FMatrixPlanar::CopyIn" ref="afeb71efdf105aed29b5d726eb0a2f915" args="(doubleconst *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::CopyIn </td>
          <td>(</td>
          <td class="paramtype">double  const *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill (laminate) this matrix with the given data. </p>
<p>Fill this matrix with the given data.</p>
<p>We assume that p points to a contiguous rows*cols array, stored rowwise. </p>

</div>
</div>
<a class="anchor" id="aac98f4f0c40b2bb0899d2eea24565054"></a><!-- doxytag: member="VW::FMatrixPlanar::CopyOut" ref="aac98f4f0c40b2bb0899d2eea24565054" args="(double *) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::CopyOut </td>
          <td>(</td>
          <td class="paramtype">double  *&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill the given array with this matrix. </p>
<p>We assume that p points to a contiguous rows*cols array, stored rowwise. No bounds checking on the array</p>
<p>We assume that p points to a contiguous rows*cols array, stored rowwise. </p>

</div>
</div>
<a class="anchor" id="a85e69ba573321510ec08c639d13a404e"></a><!-- doxytag: member="VW::FMatrixPlanar::DataArray" ref="a85e69ba573321510ec08c639d13a404e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * * <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::DataArray </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the 2D array, so that elements can be accessed with array[row][col] directly. </p>
<p>2d array, [row][column]. </p>

</div>
</div>
<a class="anchor" id="a6fd65e9be20311a7eb6cd6d41aee165c"></a><!-- doxytag: member="VW::FMatrixPlanar::DataArray" ref="a6fd65e9be20311a7eb6cd6d41aee165c" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double  const* const* <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::DataArray </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the 2D array, so that elements can be accessed with array[row][col] directly. </p>
<p>2d array, [row][column]. </p>

</div>
</div>
<a class="anchor" id="ab3965a2cb2da2bd6000880cb57ced592"></a><!-- doxytag: member="VW::FMatrixPlanar::DataBlock" ref="ab3965a2cb2da2bd6000880cb57ced592" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::DataBlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the contiguous block storing the elements in the matrix row-wise. O(1). </p>
<p>1d array, row-major order. </p>

</div>
</div>
<a class="anchor" id="a998b3369c5b384b2a6ecb7711d1908d5"></a><!-- doxytag: member="VW::FMatrixPlanar::DataBlock" ref="a998b3369c5b384b2a6ecb7711d1908d5" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double  const* <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::DataBlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the contiguous block storing the elements in the matrix row-wise. O(1). </p>
<p>1d array, row-major order. </p>

<p>Referenced by <a class="el" href="homography2d_8h_source.html#l00299">VW::Homography2DCovariance::operator=()</a>, <a class="el" href="fmatrixaffine_8h_source.html#l00305">VW::FMatrixAffineCovariance::operator=()</a>, and <a class="el" href="fmatrix_8h_source.html#l00257">VW::FMatrixCovariance::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="aafd89e336f8e0b9ff934de98825fff1b"></a><!-- doxytag: member="VW::FMatrixPlanar::destroy" ref="aafd89e336f8e0b9ff934de98825fff1b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::destroy </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete data. </p>
<p>Frees up the dynamic storage used by matrix.</p>
<p>O(m*n). </p>

</div>
</div>
<a class="anchor" id="ad32ecc9db9edf97c6212228352b85f7a"></a><!-- doxytag: member="VW::FMatrixPlanar::end" ref="ad32ecc9db9edf97c6212228352b85f7a" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a6235d47d391413ca573e3a93b6f35d59">const_iterator</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator pointing to element beyond end of data. </p>

</div>
</div>
<a class="anchor" id="a35920c1f1f6487229aeb25015b982a9c"></a><!-- doxytag: member="VW::FMatrixPlanar::end" ref="a35920c1f1f6487229aeb25015b982a9c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a06cbb6154eff4ab9a4aa104e14c88431">iterator</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator pointing to element beyond end of data. </p>

</div>
</div>
<a class="anchor" id="a2c98629ea08b40937333f8748f0a6302"></a><!-- doxytag: member="VW::FMatrixPlanar::Extract" ref="a2c98629ea08b40937333f8748f0a6302" args="(unsigned rows, unsigned cols, unsigned top=0, unsigned left=0) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Extract </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>top</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>left</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract a sub-matrix of size rows x cols, starting at (top,left). </p>
<p>Returns a copy of submatrix of THIS matrix, specified by the top-left corner and size in rows, cols. O(m*n).</p>
<p>Thus it contains elements [top,top+rows-1][left,left+cols-1]</p>
<p>Use update() to copy new values of this submatrix back into THIS matrix. </p>

<p>Referenced by <a class="el" href="projectionmatrix_8cpp_source.html#l00059">VW::ProjectionMatrix::Decompose()</a>.</p>

</div>
</div>
<a class="anchor" id="abebe72526015607ee129e2d4687bc7e2"></a><!-- doxytag: member="VW::FMatrixPlanar::Fill" ref="abebe72526015607ee129e2d4687bc7e2" args="(doubleconst &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Fill </td>
          <td>(</td>
          <td class="paramtype">double  const &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set all elements of matrix to specified value. </p>
<p>Sets all elements of matrix to specified value. O(m*n).</p>
<p>Complexity <img class="formulaInl" alt="$O(r.c)$" src="form_31.png"/> </p>

</div>
</div>
<a class="anchor" id="a8d451a78fc2585574896abac68e4c008"></a><!-- doxytag: member="VW::FMatrixPlanar::FillDiagonal" ref="a8d451a78fc2585574896abac68e4c008" args="(doubleconst &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::FillDiagonal </td>
          <td>(</td>
          <td class="paramtype">double  const &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set all diagonal elements of matrix to specified value. </p>
<p>Sets all diagonal elements of matrix to specified value. O(n).</p>
<p>Complexity <img class="formulaInl" alt="$O(\min(r,c))$" src="form_33.png"/> </p>

</div>
</div>
<a class="anchor" id="a3e86c8f6fb3958ff7d536be32a5b065c"></a><!-- doxytag: member="VW::FMatrixPlanar::FlipLR" ref="a3e86c8f6fb3958ff7d536be32a5b065c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::FlipLR </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverse order of columns. </p>

</div>
</div>
<a class="anchor" id="ae48802566d7d5996c3de908a03884b13"></a><!-- doxytag: member="VW::FMatrixPlanar::FlipUD" ref="ae48802566d7d5996c3de908a03884b13" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::FlipUD </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverse order of rows. </p>
<p>Reverse order of rows. Name is from Matlab, meaning "flip upside down". </p>

</div>
</div>
<a class="anchor" id="a73d64afb4bcb316f06e023b2b1935565"></a><!-- doxytag: member="VW::FMatrixPlanar::FrobeniusNorm" ref="a73d64afb4bcb316f06e023b2b1935565" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::FrobeniusNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return frobenius norm of matrix (sqrt of sum of squares of its elements). </p>

</div>
</div>
<a class="anchor" id="aa2722f239eb9b210314d40f4b7c77d1c"></a><!-- doxytag: member="VW::FMatrixPlanar::FroNorm" ref="aa2722f239eb9b210314d40f4b7c77d1c" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::FroNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return frobenius norm of matrix (sqrt of sum of squares of its elements). </p>

</div>
</div>
<a class="anchor" id="a3af3fc536ac0f6b7bbc6ce05010b29d7"></a><!-- doxytag: member="VW::FMatrixPlanar::Get" ref="a3af3fc536ac0f6b7bbc6ce05010b29d7" args="(unsigned r, unsigned c) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double  <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Get </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get element with boundary checks if error checking is on. </p>
<p>get -- Returns the value of the element at specified row and column. O(1).</p>
<p>Checks for valid range of indices. </p>

</div>
</div>
<a class="anchor" id="af375829bf73f5fa22f9850f5baf506f7"></a><!-- doxytag: member="VW::FMatrixPlanar::GetColumn" ref="af375829bf73f5fa22f9850f5baf506f7" args="(unsigned col) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::GetColumn </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a vector equal to the given column. </p>
<p>Create a vector out of column[column_index]. </p>

<p>Referenced by <a class="el" href="projectionmatrix_8cpp_source.html#l00059">VW::ProjectionMatrix::Decompose()</a>.</p>

</div>
</div>
<a class="anchor" id="a0980ec1f870f7e0930f28f9f7dbcf394"></a><!-- doxytag: member="VW::FMatrixPlanar::GetEpipoles" ref="a0980ec1f870f7e0930f28f9f7dbcf394" args="(VW::Point2D &amp;e1, VW::Point2D &amp;e2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VW::FMatrix::GetEpipoles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVW_1_1Point2D.html">VW::Point2D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVW_1_1Point2D.html">VW::Point2D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="point2d_8h_source.html#l00178">VW::Point2D::Set()</a>, <a class="el" href="svd_8h_source.html#l00118">VNL::SVD&lt; T &gt;::U()</a>, and <a class="el" href="svd_8h_source.html#l00144">VNL::SVD&lt; T &gt;::V()</a>.</p>

<p>Referenced by <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00032">VW::FMPlanarCompute::GenerateParameterVectorHZ()</a>, and <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00118">VW::FMPlanarCompute::GenerateParameterVectorVLJK()</a>.</p>

</div>
</div>
<a class="anchor" id="a9dbad2a14390164261b1a0141b5b0e50"></a><!-- doxytag: member="VW::FMatrixPlanar::GetMinFeatures" ref="a9dbad2a14390164261b1a0141b5b0e50" args="(const F &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int VW::FMatrix::GetMinFeatures </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classVW_1_1Transform.html#a4b331b4a1096ce664a51cd6b6fa360fd">VW::Transform</a>.</p>

</div>
</div>
<a class="anchor" id="af9c364e71f7fb25698a68e6b9eea119d"></a><!-- doxytag: member="VW::FMatrixPlanar::GetNColumns" ref="af9c364e71f7fb25698a68e6b9eea119d" args="(unsigned colstart, unsigned n) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::GetNColumns </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>colstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get n columns beginning at colstart. </p>
<p>Returns a copy of n columns, starting from "column". </p>

</div>
</div>
<a class="anchor" id="a58a59fd9cf8b6d0ba980dafc417e1919"></a><!-- doxytag: member="VW::FMatrixPlanar::GetNRows" ref="a58a59fd9cf8b6d0ba980dafc417e1919" args="(unsigned rowstart, unsigned n) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::GetNRows </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>rowstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get n rows beginning at rowstart. </p>
<p>Returns a copy of n rows, starting from "row". </p>

</div>
</div>
<a class="anchor" id="a427df299ada8419d28d7e6d81ed865de"></a><!-- doxytag: member="VW::FMatrixPlanar::GetNumViews" ref="a427df299ada8419d28d7e6d81ed865de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int VW::FMatrix::GetNumViews </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classVW_1_1Transform.html#a6901685c046e6e70a9a010cdf260b6a4">VW::Transform</a>.</p>

<p>References <a class="el" href="fmatrix_8h_source.html#l00057">VW::FMatrix::NUM_VIEWS</a>.</p>

</div>
</div>
<a class="anchor" id="afb919d16fb23272d7eab455f354850b7"></a><!-- doxytag: member="VW::FMatrixPlanar::GetRow" ref="afb919d16fb23272d7eab455f354850b7" args="(unsigned row) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::GetRow </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a vector equal to the given row. </p>
<p>Create a vector out of row[row_index]. </p>

</div>
</div>
<a class="anchor" id="a99a10121cdbbf6d034897a7de4fe2c26"></a><!-- doxytag: member="VW::FMatrixPlanar::HasNaNs" ref="a99a10121cdbbf6d034897a7de4fe2c26" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::HasNaNs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if matrix contains NaNs. </p>
<p>Return true if any element of (*this) is nan. </p>

</div>
</div>
<a class="anchor" id="a3caa4ee02f27a6e3790fa9b7bc9ead0f"></a><!-- doxytag: member="VW::FMatrixPlanar::inline_function_tickler" ref="a3caa4ee02f27a6e3790fa9b7bc9ead0f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::inline_function_tickler </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4cd44931db0fb741dfdf85801eaa88df"></a><!-- doxytag: member="VW::FMatrixPlanar::InplaceTranspose" ref="a4cd44931db0fb741dfdf85801eaa88df" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::InplaceTranspose </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transpose this matrix efficiently. </p>
<p>Transpose matrix M in place.</p>
<p>Works for rectangular matrices using an enormously clever algorithm from ACM TOMS. </p>

</div>
</div>
<a class="anchor" id="a3ac85e6520d6ff3ef4606e0907e9bfac"></a><!-- doxytag: member="VW::FMatrixPlanar::IsEmpty" ref="a3ac85e6520d6ff3ef4606e0907e9bfac" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true iff the size is zero. </p>

</div>
</div>
<a class="anchor" id="a11aec14aa996623f274d4707b2d6be32"></a><!-- doxytag: member="VW::FMatrixPlanar::IsFinite" ref="a11aec14aa996623f274d4707b2d6be32" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::IsFinite </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if finite. </p>
<p>Return false if any element of (*this) is inf or nan. </p>

</div>
</div>
<a class="anchor" id="ac4eceaf3f07acc5b986eae5b2b45d33f"></a><!-- doxytag: member="VW::FMatrixPlanar::IsIdentity" ref="ac4eceaf3f07acc5b986eae5b2b45d33f" args="(double tol) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::IsIdentity </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if all elements equal to identity, within given tolerance. </p>
<p>Return true if maximum absolute deviation of M from identity is &lt;= tol. </p>

</div>
</div>
<a class="anchor" id="af41eb3b97b367b64bbba36bab9ec2c74"></a><!-- doxytag: member="VW::FMatrixPlanar::IsIdentity" ref="af41eb3b97b367b64bbba36bab9ec2c74" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::IsIdentity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if all elements equal to identity. </p>

</div>
</div>
<a class="anchor" id="a56aa9ceb181a20c7f039dece5007d72a"></a><!-- doxytag: member="VW::FMatrixPlanar::IsZero" ref="a56aa9ceb181a20c7f039dece5007d72a" args="(double tol) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::IsZero </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if all elements equal to zero, within given tolerance. </p>
<p>Return true if max(abs((*this))) &lt;= tol. </p>

</div>
</div>
<a class="anchor" id="a18897a2283edbe81f212be1e436956c0"></a><!-- doxytag: member="VW::FMatrixPlanar::IsZero" ref="a18897a2283edbe81f212be1e436956c0" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::IsZero </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if all elements equal to zero. </p>

</div>
</div>
<a class="anchor" id="a1493fd44296bcfbc4773f538283245af"></a><!-- doxytag: member="VW::FMatrixPlanar::MaxValue" ref="a1493fd44296bcfbc4773f538283245af" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double  <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::MaxValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return maximum value of elements. </p>

</div>
</div>
<a class="anchor" id="a9f33a276b125d6cfa7d9fd8e4a1e6d8a"></a><!-- doxytag: member="VW::FMatrixPlanar::Mean" ref="a9f33a276b125d6cfa7d9fd8e4a1e6d8a" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double  <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Mean </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return mean of all matrix elements. </p>

</div>
</div>
<a class="anchor" id="ac5ab77cee1837ed306d744934c5d13df"></a><!-- doxytag: member="VW::FMatrixPlanar::MinValue" ref="ac5ab77cee1837ed306d744934c5d13df" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double  <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::MinValue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return minimum value of elements. </p>

</div>
</div>
<a class="anchor" id="acdb264e08aaa86e5ad6a992299510700"></a><!-- doxytag: member="VW::FMatrixPlanar::NormalizeColumns" ref="acdb264e08aaa86e5ad6a992299510700" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::NormalizeColumns </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize each column so it is a unit vector. </p>
<p>Make each column of the matrix have unit norm.</p>
<p>Zero columns are ignored</p>
<p>All-zero columns are ignored. </p>

</div>
</div>
<a class="anchor" id="aa9d7c8321f1342c39e804de6656c5204"></a><!-- doxytag: member="VW::FMatrixPlanar::NormalizeRows" ref="aa9d7c8321f1342c39e804de6656c5204" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::NormalizeRows </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Normalize each row so it is a unit vector. </p>
<p>Make each row of the matrix have unit norm.</p>
<p>Zero rows are ignored</p>
<p>All-zero rows are ignored. </p>

</div>
</div>
<a class="anchor" id="a78669d703385e313e0ad6a501028477d"></a><!-- doxytag: member="VW::FMatrixPlanar::operator!=" ref="a78669d703385e313e0ad6a501028477d" args="(Matrix&lt; double &gt; const &amp;that) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; double  &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inequality operator. </p>

</div>
</div>
<a class="anchor" id="a51ae5629bc2b2d798d794df622e74b39"></a><!-- doxytag: member="VW::FMatrixPlanar::operator()" ref="a51ae5629bc2b2d798d794df622e74b39" args="(unsigned r, unsigned c) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double  const&amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access an element for reading. </p>
<p>There are assert style boundary checks - define NDEBUG to turn them off. </p>

</div>
</div>
<a class="anchor" id="aa0d12208d46190033757830a17aa0046"></a><!-- doxytag: member="VW::FMatrixPlanar::operator()" ref="aa0d12208d46190033757830a17aa0046" args="(unsigned r, unsigned c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double &amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access an element for reading or writing. </p>
<p>There are assert style boundary checks - define NDEBUG to turn them off. </p>

</div>
</div>
<a class="anchor" id="ac3f61ef87d7084a78510d8c2aedf78d3"></a><!-- doxytag: member="VW::FMatrixPlanar::operator*" ref="ac3f61ef87d7084a78510d8c2aedf78d3" args="(Matrix&lt; double &gt; const &amp;rhs) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; double  &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Matrix multiply lhs by rhs matrix and return result in new matrix. </p>

</div>
</div>
<a class="anchor" id="a609fc3a2ffb60df4c1128df41c5ea101"></a><!-- doxytag: member="VW::FMatrixPlanar::operator*" ref="a609fc3a2ffb60df4c1128df41c5ea101" args="(doubleconst &amp;v) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">double  const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar multiplication of lhs matrix by rhs and return result in new matrix. </p>

</div>
</div>
<a class="anchor" id="ab72f951f10015a1c640473f453b81a8f"></a><!-- doxytag: member="VW::FMatrixPlanar::operator*=" ref="ab72f951f10015a1c640473f453b81a8f" args="(Matrix&lt; double &gt; const &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt;&amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; double  &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiply lhs matrix in situ by rhs. </p>

</div>
</div>
<a class="anchor" id="aa25de30c7bec38b9e7d4d68897a16c9f"></a><!-- doxytag: member="VW::FMatrixPlanar::operator*=" ref="aa25de30c7bec38b9e7d4d68897a16c9f" args="(doublevalue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt;&amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar multiplication in situ of lhs matrix by rhs. </p>

</div>
</div>
<a class="anchor" id="a6d7e026a1d1ffa09b127931b1ba61fd7"></a><!-- doxytag: member="VW::FMatrixPlanar::operator+" ref="a6d7e026a1d1ffa09b127931b1ba61fd7" args="(Matrix&lt; double &gt; const &amp;rhs) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; double  &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Matrix add rhs to lhs matrix and return result in new matrix. </p>

</div>
</div>
<a class="anchor" id="ac61fc52d0ff23284bc7cf80e92ed745c"></a><!-- doxytag: member="VW::FMatrixPlanar::operator+" ref="ac61fc52d0ff23284bc7cf80e92ed745c" args="(doubleconst &amp;v) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">double  const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add rhs to each element of lhs matrix and return result in new matrix. </p>

</div>
</div>
<a class="anchor" id="a1477b046be621c17db6ab42ff3d352b3"></a><!-- doxytag: member="VW::FMatrixPlanar::operator+=" ref="a1477b046be621c17db6ab42ff3d352b3" args="(Matrix&lt; double &gt; const &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt;&amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; double  &gt; const &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add rhs to lhs matrix in situ. </p>
<p>Adds lhs matrix with rhs matrix, and stores in place in lhs matrix.</p>
<p>O(m*n). The dimensions of the two matrices must be identical. </p>

</div>
</div>
<a class="anchor" id="a0911f03689d46fa04ea2d39732fbb279"></a><!-- doxytag: member="VW::FMatrixPlanar::operator+=" ref="a0911f03689d46fa04ea2d39732fbb279" args="(doublevalue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt;&amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add rhs to each element of lhs matrix in situ. </p>

</div>
</div>
<a class="anchor" id="a8abcfc4fbc2c1e740f33205fee765d0f"></a><!-- doxytag: member="VW::FMatrixPlanar::operator&#45;" ref="a8abcfc4fbc2c1e740f33205fee765d0f" args="(Matrix&lt; double &gt; const &amp;rhs) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; double  &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Matrix subtract rhs from lhs and return result in new matrix. </p>

</div>
</div>
<a class="anchor" id="a8b4d5a955e42f3fb3c54c499006ba9b8"></a><!-- doxytag: member="VW::FMatrixPlanar::operator&#45;" ref="a8b4d5a955e42f3fb3c54c499006ba9b8" args="(doubleconst &amp;v) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">double  const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract rhs from each element of lhs matrix and return result in new matrix. </p>

</div>
</div>
<a class="anchor" id="ab871cf6a47e22652615c6f48461df4e8"></a><!-- doxytag: member="VW::FMatrixPlanar::operator&#45;" ref="ab871cf6a47e22652615c6f48461df4e8" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Negate all elements of matrix. </p>
<p>Returns new matrix which is the negation of THIS matrix.</p>
<p>O(m*n). </p>

</div>
</div>
<a class="anchor" id="a08d9aa32756c09656774d0e1524d96e2"></a><!-- doxytag: member="VW::FMatrixPlanar::operator&#45;=" ref="a08d9aa32756c09656774d0e1524d96e2" args="(Matrix&lt; double &gt; const &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt;&amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; double  &gt; const &amp;&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract rhs from lhs matrix in situ. </p>
<p>Substract lhs matrix with rhs matrix and store in place in lhs matrix.</p>
<p>O(m*n). The dimensions of the two matrices must be identical. </p>

</div>
</div>
<a class="anchor" id="aa3cbbc42d832538eba3923c822270a37"></a><!-- doxytag: member="VW::FMatrixPlanar::operator&#45;=" ref="aa3cbbc42d832538eba3923c822270a37" args="(doublevalue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt;&amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subtract rhs from each element of lhs matrix in situ. </p>

</div>
</div>
<a class="anchor" id="a97bdea276efcc84a7556429f07061d9b"></a><!-- doxytag: member="VW::FMatrixPlanar::operator/" ref="a97bdea276efcc84a7556429f07061d9b" args="(doubleconst &amp;v) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">double  const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar division of lhs matrix by rhs and return result in new matrix. </p>

</div>
</div>
<a class="anchor" id="a829bdb4502e89901e406ec8d9f2c3575"></a><!-- doxytag: member="VW::FMatrixPlanar::operator/=" ref="a829bdb4502e89901e406ec8d9f2c3575" args="(doublevalue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt;&amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scalar division of lhs matrix in situ by rhs. </p>

</div>
</div>
<a class="anchor" id="aafff6b75cc433617cd00576ad184e475"></a><!-- doxytag: member="VW::FMatrixPlanar::operator&lt;&lt;" ref="aafff6b75cc433617cd00576ad184e475" args="(std::ostream &amp;stream) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; VW::FMatrix::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af9164c0e31ee897a1b44b2524edcad20"></a><!-- doxytag: member="VW::FMatrixPlanar::operator=" ref="af9164c0e31ee897a1b44b2524edcad20" args="(const VNL::Matrix&lt; double &gt; m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVW_1_1FMatrixPlanar.html">VW::FMatrixPlanar</a> &amp; VW::FMatrixPlanar::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double &gt;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a86a63d168735339875022c8355ef16d6"></a><!-- doxytag: member="VW::FMatrixPlanar::operator=" ref="a86a63d168735339875022c8355ef16d6" args="(const VNL::MatrixFixed&lt; 3, 3, double &gt; m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVW_1_1FMatrixPlanar.html">VW::FMatrixPlanar</a> &amp; VW::FMatrixPlanar::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVNL_1_1MatrixFixed.html">VNL::MatrixFixed</a>&lt; 3, 3, double &gt;&nbsp;</td>
          <td class="paramname"> <em>m</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a05a137f7e460445c3531bee431aa7da5"></a><!-- doxytag: member="VW::FMatrixPlanar::operator=" ref="a05a137f7e460445c3531bee431aa7da5" args="(const FMatrix &amp;F)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVW_1_1FMatrixPlanar.html">VW::FMatrixPlanar</a> &amp; VW::FMatrixPlanar::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVW_1_1FMatrix.html">FMatrix</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>F</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0cdbeca4b99a73ba13e618e352c58493"></a><!-- doxytag: member="VW::FMatrixPlanar::operator==" ref="a0cdbeca4b99a73ba13e618e352c58493" args="(Matrix&lt; double &gt; const &amp;that) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; double  &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equality operator. </p>

</div>
</div>
<a class="anchor" id="adf099168a9c6309e99f1ae786990def8"></a><!-- doxytag: member="VW::FMatrixPlanar::operator[]" ref="adf099168a9c6309e99f1ae786990def8" args="(unsigned r) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double  const* <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>r</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return pointer to given row. </p>
<p>No boundary checking here. </p>

</div>
</div>
<a class="anchor" id="acfbe7f98f9bd824ff8d642ace7395f6e"></a><!-- doxytag: member="VW::FMatrixPlanar::operator[]" ref="acfbe7f98f9bd824ff8d642ace7395f6e" args="(unsigned r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double * <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>r</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>return pointer to given row. </p>
<p>No boundary checking here. </p>

</div>
</div>
<a class="anchor" id="a3bd270c6cbcfb5fe7e1ea9cb28672dc6"></a><!-- doxytag: member="VW::FMatrixPlanar::operator_eq" ref="a3bd270c6cbcfb5fe7e1ea9cb28672dc6" args="(Matrix&lt; double &gt; const &amp;rhs) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operator_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; double  &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return true if *this == rhs. </p>
<p>Two matrices are equal if and only if they have the same dimensions and the same values.</p>
<p>O(m*n). Elements are compared with operator== as default. Change this default with set_compare() at run time or by specializing Matrix_compare at compile time. </p>

</div>
</div>
<a class="anchor" id="a0eae6d0de0a9e4b15f33905325f7df52"></a><!-- doxytag: member="VW::FMatrixPlanar::operatorInfNorm" ref="a0eae6d0de0a9e4b15f33905325f7df52" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operatorInfNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3307db07670668e0e713d1ae139a9cae"></a><!-- doxytag: member="VW::FMatrixPlanar::operatorOneNorm" ref="a3307db07670668e0e713d1ae139a9cae" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::operatorOneNorm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aebbe2d0d79a10b0732d1ad7261cb10bb"></a><!-- doxytag: member="VW::FMatrixPlanar::print" ref="aebbe2d0d79a10b0732d1ad7261cb10bb" args="(std::ostream &amp;os) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Print matrix to os in some hopefully sensible format. </p>

</div>
</div>
<a class="anchor" id="a4b3228f51e4a445a651a529f49aaeb9d"></a><!-- doxytag: member="VW::FMatrixPlanar::Put" ref="a4b3228f51e4a445a651a529f49aaeb9d" args="(unsigned r, unsigned c, doubleconst &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Put </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double  const &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>set element with boundary checks if error checking is on. </p>
<p>put -- Puts value into element at specified row and column. O(1).</p>
<p>Checks for valid range of indices. </p>

</div>
</div>
<a class="anchor" id="a1dc673309070ddaffc84a8985ee939f0"></a><!-- doxytag: member="VW::FMatrixPlanar::Read" ref="a1dc673309070ddaffc84a8985ee939f0" args="(std::istream &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Matrix&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a Matrix from an ascii std::istream. </p>
<p>Automatically determines file size if the input matrix has zero size. This is a static method so you can type &lt;verb&gt; <a class="el" href="classVNL_1_1Matrix.html">Matrix&lt;float&gt;</a> M = Matrix&lt;float&gt;::read(cin); &lt;/verb&gt; which many people prefer to the "&gt;&gt;" alternative. </p>

</div>
</div>
<a class="anchor" id="a7a6980b7a9f7dc98cff9989874a315d9"></a><!-- doxytag: member="VW::FMatrixPlanar::ReadASCII" ref="a7a6980b7a9f7dc98cff9989874a315d9" args="(std::istream &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::ReadASCII </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a Matrix from an ascii std::istream. </p>
<p>Automatically determines file size if the input matrix has zero size. </p>

</div>
</div>
<a class="anchor" id="ad3221c841512da857742c2cdc8cb53f0"></a><!-- doxytag: member="VW::FMatrixPlanar::Resize" ref="ad3221c841512da857742c2cdc8cb53f0" args="(unsigned r, unsigned c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Resize </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resize to r rows by c columns. Old data lost. </p>
<p>returns true if size changed. </p>

</div>
</div>
<a class="anchor" id="af080a0023d9f6630e4585d8b383b8710"></a><!-- doxytag: member="VW::FMatrixPlanar::resize" ref="af080a0023d9f6630e4585d8b383b8710" args="(unsigned int, unsigned int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classVNL_1_1MatrixFixedRef.html">VNL::MatrixFixedRef</a>&lt; m, n, double  &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>int</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resizing a vnl_matrix_ref fails. </p>

</div>
</div>
<a class="anchor" id="a4ef128e2b04c38f9fc79429cea5f7081"></a><!-- doxytag: member="VW::FMatrixPlanar::ReverseTransfer" ref="a4ef128e2b04c38f9fc79429cea5f7081" args="(const VW::Point2D &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVW_1_1Line2D.html">VW::Line2D</a> VW::FMatrix::ReverseTransfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVW_1_1Point2D.html">VW::Point2D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="qr_8tpp.html#aafc737ea9ef91f59cf9acd287fb8d085">c</a>, <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; double &gt;::data</a>, <a class="el" href="point2d_8h_source.html#l00159">VW::Point2D::GetX()</a>, and <a class="el" href="point2d_8h_source.html#l00168">VW::Point2D::GetY()</a>.</p>

<p>Referenced by <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00370">VW::FMPlanarCompute::LeastSquaresFunctionPoints::F()</a>, and <a class="el" href="fmatrixcomputenonlinear_8cpp_source.html#l00121">VW::FMatrixCompute::LeastSquaresFunctionPoints::F()</a>.</p>

</div>
</div>
<a class="anchor" id="af45a131fc2029cfba95673e2455e16e6"></a><!-- doxytag: member="VW::FMatrixPlanar::ReverseTransferPoint" ref="af45a131fc2029cfba95673e2455e16e6" args="(const ElementType &amp;point, VW::Line2D &amp;eline) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VW::FMatrix::ReverseTransferPoint </td>
          <td>(</td>
          <td class="paramtype">const ElementType &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVW_1_1Line2D.html">VW::Line2D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>eline</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="fmatrix_8h_source.html#l00087">VW::FMatrix::AsMatrix()</a>, and <a class="el" href="classVNL_1_1Matrix.html#a7c5d1b0934192972fa6c77c8aa0f4c04">VNL::Matrix&lt; double &gt;::Transpose()</a>.</p>

</div>
</div>
<a class="anchor" id="a35ae0df75f8e397bd6a9100fcf677c26"></a><!-- doxytag: member="VW::FMatrixPlanar::RMS" ref="a35ae0df75f8e397bd6a9100fcf677c26" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVNL_1_1Matrix.html#a34d7b88b6e43815aa9ba7b9ba833ba77">abs_t</a> <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::RMS </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return RMS of all elements. </p>

</div>
</div>
<a class="anchor" id="aff5c94adfdf10c50c421097ae55c055e"></a><!-- doxytag: member="VW::FMatrixPlanar::Rows" ref="aff5c94adfdf10c50c421097ae55c055e" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Rows </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return number of rows. </p>

</div>
</div>
<a class="anchor" id="ae87be7fafd426f9ee5f7567663c79078"></a><!-- doxytag: member="VW::FMatrixPlanar::ScaleColumn" ref="ae87be7fafd426f9ee5f7567663c79078" args="(unsigned col, doublevalue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::ScaleColumn </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scale elements in given column by a factor of T. </p>
<p>Multiply column[column_index] by value. </p>

</div>
</div>
<a class="anchor" id="a4e9f7b2c295c2b992efc0a94bf4808f2"></a><!-- doxytag: member="VW::FMatrixPlanar::ScaleRow" ref="a4e9f7b2c295c2b992efc0a94bf4808f2" args="(unsigned row, doublevalue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::ScaleRow </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Scale elements in given row by a factor of T. </p>
<p>Multiply row[row_index] by value. </p>

</div>
</div>
<a class="anchor" id="aa211aa5409bc801d0fed44d65c25dd20"></a><!-- doxytag: member="VW::FMatrixPlanar::Set" ref="aa211aa5409bc801d0fed44d65c25dd20" args="(doubleconst *d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Set </td>
          <td>(</td>
          <td class="paramtype">double  const *&nbsp;</td>
          <td class="paramname"> <em>d</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fill (laminate) this matrix with the given data. </p>
<p>A synonym for copy_in() </p>

</div>
</div>
<a class="anchor" id="a3709e2eaea0b9eb4197c2f3b72167ba3"></a><!-- doxytag: member="VW::FMatrixPlanar::SetColumn" ref="a3709e2eaea0b9eb4197c2f3b72167ba3" args="(unsigned j, Vector&lt; double &gt; const &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::SetColumn </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; double  &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set j-th colum to v. </p>
<p>Set column[column_index] to given vector. No bounds check. </p>

</div>
</div>
<a class="anchor" id="ac8b884756ccd26369f114543b2f9e066"></a><!-- doxytag: member="VW::FMatrixPlanar::SetColumn" ref="ac8b884756ccd26369f114543b2f9e066" args="(unsigned i, doublevalue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::SetColumn </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the elements of the i'th column to value. </p>
<p>Set column[column_index] to given value. </p>

</div>
</div>
<a class="anchor" id="af37d6c7e5f69eeb882d0485d2a1fff7c"></a><!-- doxytag: member="VW::FMatrixPlanar::SetColumn" ref="af37d6c7e5f69eeb882d0485d2a1fff7c" args="(unsigned i, doubleconst *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::SetColumn </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double  const *&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the elements of the i'th column to v[j] (No bounds checking). </p>
<p>Set column[column_index] to data at given address. </p>

</div>
</div>
<a class="anchor" id="aa008e53c4cff6449118e28d8308959f7"></a><!-- doxytag: member="VW::FMatrixPlanar::SetColumns" ref="aa008e53c4cff6449118e28d8308959f7" args="(unsigned starting_column, Matrix&lt; double &gt; const &amp;M)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::SetColumns </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>starting_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; double  &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>M</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set columns to those in M, starting at starting_column. </p>
<p>Set columns starting at starting_column to given matrix. </p>

<p>Referenced by <a class="el" href="projectionmatrix_8cpp_source.html#l00042">VW::ProjectionMatrix::Compose()</a>.</p>

</div>
</div>
<a class="anchor" id="a75233a9e40259eac0bb7e1f0cf849cf9"></a><!-- doxytag: member="VW::FMatrixPlanar::SetIdentity" ref="a75233a9e40259eac0bb7e1f0cf849cf9" args="(doubleval=double(1))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::SetIdentity </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em> = <code>T(1)</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set this matrix to an identity (or diagonal) matrix. </p>
<p>Fill this matrix with a row*row identity matrix.</p>
<p>Abort if the matrix is not square </p>

<p>Referenced by <a class="el" href="homography2d_8h_source.html#l00066">VW::Homography2D::Homography2D()</a>.</p>

</div>
</div>
<a class="anchor" id="a0cea699795ff2ee5ecf6aa633c49422f"></a><!-- doxytag: member="VW::FMatrixPlanar::SetRow" ref="a0cea699795ff2ee5ecf6aa633c49422f" args="(unsigned i, Vector&lt; double &gt; const &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::SetRow </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Vector.html">Vector</a>&lt; double  &gt; const &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the i-th row. </p>
<p>Set row[row_index] to given vector. No bounds check. </p>

</div>
</div>
<a class="anchor" id="ac8b55c00bcb24d7fcf2d68de80c0214e"></a><!-- doxytag: member="VW::FMatrixPlanar::SetRow" ref="ac8b55c00bcb24d7fcf2d68de80c0214e" args="(unsigned i, doublevalue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::SetRow </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the elements of the i'th row to value. </p>
<p>Set row[row_index] to given value. </p>

</div>
</div>
<a class="anchor" id="af707998ccb85f8d61b95480a28176de5"></a><!-- doxytag: member="VW::FMatrixPlanar::SetRow" ref="af707998ccb85f8d61b95480a28176de5" args="(unsigned i, doubleconst *v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::SetRow </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double  const *&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the elements of the i'th row to v[j] (No bounds checking). </p>
<p>Set row[row_index] to data at given address. No bounds check. </p>

</div>
</div>
<a class="anchor" id="a38883927f7b47ec3f8c7e88e41f6ebdd"></a><!-- doxytag: member="VW::FMatrixPlanar::size" ref="a38883927f7b47ec3f8c7e88e41f6ebdd" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return number of elements. </p>
<p>This equals rows() * cols() </p>

</div>
</div>
<a class="anchor" id="acc663489b8784632af9b648a67d7740b"></a><!-- doxytag: member="VW::FMatrixPlanar::Size" ref="acc663489b8784632af9b648a67d7740b" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return number of elements. </p>
<p>This equals rows() * cols() </p>

</div>
</div>
<a class="anchor" id="a2f3c40b3a1e7f2b09cc567f820f36849"></a><!-- doxytag: member="VW::FMatrixPlanar::Swap" ref="a2f3c40b3a1e7f2b09cc567f820f36849" args="(Matrix&lt; double &gt; &amp;that)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; double  &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>that</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap this matrix with that matrix. </p>

</div>
</div>
<a class="anchor" id="aae8edfae1154aa3f820bd5bf8d8dc87d"></a><!-- doxytag: member="VW::FMatrixPlanar::Transfer" ref="aae8edfae1154aa3f820bd5bf8d8dc87d" args="(const VW::Point2D &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVW_1_1Line2D.html">VW::Line2D</a> VW::FMatrix::Transfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVW_1_1Point2D.html">VW::Point2D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="qr_8tpp.html#aafc737ea9ef91f59cf9acd287fb8d085">c</a>, <a class="el" href="matrix_8h_source.html#l00635">VNL::Matrix&lt; double &gt;::data</a>, <a class="el" href="point2d_8h_source.html#l00159">VW::Point2D::GetX()</a>, and <a class="el" href="point2d_8h_source.html#l00168">VW::Point2D::GetY()</a>.</p>

<p>Referenced by <a class="el" href="fmplanarcomputenonlinear_8cpp_source.html#l00370">VW::FMPlanarCompute::LeastSquaresFunctionPoints::F()</a>, and <a class="el" href="fmatrixcomputenonlinear_8cpp_source.html#l00121">VW::FMatrixCompute::LeastSquaresFunctionPoints::F()</a>.</p>

</div>
</div>
<a class="anchor" id="a60457e945b5b983b3a4e9fbfa0653a06"></a><!-- doxytag: member="VW::FMatrixPlanar::TransferPoint" ref="a60457e945b5b983b3a4e9fbfa0653a06" args="(const ElementType &amp;point, VW::Line2D &amp;eline) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VW::FMatrix::TransferPoint </td>
          <td>(</td>
          <td class="paramtype">const ElementType &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVW_1_1Line2D.html">VW::Line2D</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>eline</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="fmatrix_8h_source.html#l00087">VW::FMatrix::AsMatrix()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c5d1b0934192972fa6c77c8aa0f4c04"></a><!-- doxytag: member="VW::FMatrixPlanar::Transpose" ref="a7c5d1b0934192972fa6c77c8aa0f4c04" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Transpose </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return transpose. </p>
<p>Returns new matrix with rows and columns transposed.</p>
<p>O(m*n). </p>

<p>Reimplemented in <a class="el" href="classVW_1_1RotationMatrix.html#a50aa33fbdf3d8a4be75729dd10e26978">VW::RotationMatrix</a>.</p>

<p>Referenced by <a class="el" href="fmatrix_8h_source.html#l00215">VW::FMatrix::ReverseTransferPoint()</a>, and <a class="el" href="homography2d_8h_source.html#l00217">VW::Homography2D::TransferLine()</a>.</p>

</div>
</div>
<a class="anchor" id="a16b330765547529c3dffe01a9d3220a6"></a><!-- doxytag: member="VW::FMatrixPlanar::Update" ref="a16b330765547529c3dffe01a9d3220a6" args="(Matrix&lt; double &gt; const &amp;, unsigned top=0, unsigned left=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;double &gt;&amp; <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::Update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVNL_1_1Matrix.html">Matrix</a>&lt; double  &gt; const &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>top</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>left</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set values of this matrix to those of M, starting at [top,left]. </p>
<p>Replaces the submatrix of THIS matrix, starting at top left corner, by the elements of matrix m. O(m*n).</p>
<p>This is the reverse of extract(). </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a394794c6c1f9a966c3b222c7ea7e177a"></a><!-- doxytag: member="VW::FMatrixPlanar::data" ref="a394794c6c1f9a966c3b222c7ea7e177a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ** <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::<a class="el" href="classVNL_1_1Matrix.html#a394794c6c1f9a966c3b222c7ea7e177a">data</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="rotationmatrix_8cpp_source.html#l00248">VW::RotationMatrix::Angle()</a>, <a class="el" href="rotationmatrix_8cpp_source.html#l00273">VW::RotationMatrix::Axis()</a>, <a class="el" href="projectionmatrix_8cpp_source.html#l00042">VW::ProjectionMatrix::Compose()</a>, <a class="el" href="essentialmatrix_8cpp_source.html#l00066">VW::EssentialMatrix::Constrain()</a>, <a class="el" href="homography2d_8h_source.html#l00314">VW::Homography2DCovariance::ForceSymmetry()</a>, <a class="el" href="fmatrixaffine_8h_source.html#l00319">VW::FMatrixAffineCovariance::ForceSymmetry()</a>, <a class="el" href="fmatrix_8h_source.html#l00272">VW::FMatrixCovariance::ForceSymmetry()</a>, <a class="el" href="homography2d_8h_source.html#l00167">VW::Homography2D::GetTransferError2()</a>, <a class="el" href="rotationmatrix_8cpp_source.html#l00320">VW::RotationMatrix::InverseRotate()</a>, <a class="el" href="projectionmatrix_8h_source.html#l00143">VW::ProjectionMatrix::operator=()</a>, <a class="el" href="homography2d_8h_source.html#l00299">VW::Homography2DCovariance::operator=()</a>, <a class="el" href="homography2d_8h_source.html#l00257">VW::Homography2D::operator=()</a>, <a class="el" href="fmatrixaffine_8h_source.html#l00305">VW::FMatrixAffineCovariance::operator=()</a>, <a class="el" href="fmatrix_8h_source.html#l00257">VW::FMatrixCovariance::operator=()</a>, <a class="el" href="fmatrix_8h_source.html#l00157">VW::FMatrix::operator=()</a>, <a class="el" href="essentialmatrix_8h_source.html#l00099">VW::EssentialMatrix::operator=()</a>, <a class="el" href="projectionmatrix_8h_source.html#l00127">VW::ProjectionMatrix::Project()</a>, <a class="el" href="projectionmatrix_8h_source.html#l00108">VW::ProjectionMatrix::ProjectionMatrix()</a>, <a class="el" href="fmatrix_8h_source.html#l00187">VW::FMatrix::ReverseTransfer()</a>, <a class="el" href="essentialmatrix_8h_source.html#l00129">VW::EssentialMatrix::ReverseTransfer()</a>, <a class="el" href="rotationmatrix_8cpp_source.html#l00310">VW::RotationMatrix::Rotate()</a>, <a class="el" href="rotationmatrix_8cpp_source.html#l00058">VW::RotationMatrix::Set()</a>, <a class="el" href="rotationmatrix_8cpp_source.html#l00124">VW::RotationMatrix::SetFromXYZEuler()</a>, <a class="el" href="rotationmatrix_8cpp_source.html#l00165">VW::RotationMatrix::SetFromYXZEuler()</a>, <a class="el" href="rotationmatrix_8cpp_source.html#l00145">VW::RotationMatrix::SetFromZXYEuler()</a>, <a class="el" href="rotationmatrix_8cpp_source.html#l00206">VW::RotationMatrix::SetFromZXZEuler()</a>, <a class="el" href="rotationmatrix_8cpp_source.html#l00186">VW::RotationMatrix::SetFromZYXEuler()</a>, <a class="el" href="rotationmatrix_8cpp_source.html#l00117">VW::RotationMatrix::SetIdentity()</a>, <a class="el" href="fmatrix_8h_source.html#l00176">VW::FMatrix::Transfer()</a>, <a class="el" href="essentialmatrix_8h_source.html#l00118">VW::EssentialMatrix::Transfer()</a>, <a class="el" href="homography2d_8h_source.html#l00179">VW::Homography2D::TransferPoint()</a>, <a class="el" href="homography2d_8h_source.html#l00325">VW::Homography2DCovariance::TransferUncertainty()</a>, <a class="el" href="fmatrixaffine_8h_source.html#l00330">VW::FMatrixAffineCovariance::TransferUncertainty()</a>, <a class="el" href="fmatrix_8h_source.html#l00283">VW::FMatrixCovariance::TransferUncertainty()</a>, <a class="el" href="rotationmatrix_8h_source.html#l00285">VW::RotationMatrix::Transpose()</a>, and <a class="el" href="rotationmatrix_8cpp_source.html#l00342">VW::RotationMatrix::WriteBinary()</a>.</p>

</div>
</div>
<a class="anchor" id="a5c190b4e2f78d4d0ba046c19730b7bad"></a><!-- doxytag: member="VW::FMatrixPlanar::MIN_LINESET_SIZE" ref="a5c190b4e2f78d4d0ba046c19730b7bad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classVW_1_1FMatrix.html#a5c190b4e2f78d4d0ba046c19730b7bad">VW::FMatrix::MIN_LINESET_SIZE</a> = 0<code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9e2c90d6bb01a12921c74fe39dd7440d"></a><!-- doxytag: member="VW::FMatrixPlanar::MIN_POINTSET_SIZE" ref="a9e2c90d6bb01a12921c74fe39dd7440d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classVW_1_1FMatrix.html#a9e2c90d6bb01a12921c74fe39dd7440d">VW::FMatrix::MIN_POINTSET_SIZE</a> = 7<code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a27de974eac35a79aa41281fc3c3b8a92"></a><!-- doxytag: member="VW::FMatrixPlanar::MIN_SET_SIZE" ref="a27de974eac35a79aa41281fc3c3b8a92" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classVW_1_1Transform.html#a27de974eac35a79aa41281fc3c3b8a92">VW::Transform::MIN_SET_SIZE</a> = 4<code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aafcfc0276d08bc9d6017277c37d13ca0"></a><!-- doxytag: member="VW::FMatrixPlanar::NAME" ref="aafcfc0276d08bc9d6017277c37d13ca0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char *const <a class="el" href="classVW_1_1FMatrix.html#aafcfc0276d08bc9d6017277c37d13ca0">VW::FMatrix::NAME</a> = &quot;FMatrix&quot;<code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classVW_1_1Transform.html#ae58dcbd8b4a6338d5f824303af146e82">VW::Transform</a>.</p>

</div>
</div>
<a class="anchor" id="af91a774473dbda01863adad84753302f"></a><!-- doxytag: member="VW::FMatrixPlanar::num_cols" ref="af91a774473dbda01863adad84753302f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::<a class="el" href="classVNL_1_1Matrix.html#af91a774473dbda01863adad84753302f">num_cols</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3127ff55911a8a63e45247949a7692d3"></a><!-- doxytag: member="VW::FMatrixPlanar::num_rows" ref="a3127ff55911a8a63e45247949a7692d3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classVNL_1_1Matrix.html">VNL::Matrix</a>&lt; double  &gt;::<a class="el" href="classVNL_1_1Matrix.html#a3127ff55911a8a63e45247949a7692d3">num_rows</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac59691ac1bce954bf0d136023b20edac"></a><!-- doxytag: member="VW::FMatrixPlanar::NUM_VIEWS" ref="ac59691ac1bce954bf0d136023b20edac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classVW_1_1FMatrix.html#ac59691ac1bce954bf0d136023b20edac">VW::FMatrix::NUM_VIEWS</a> = 2<code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classVW_1_1Transform.html#ab3b3579bbf33816616e79b38f1a2b7a8">VW::Transform</a>.</p>

<p>Referenced by <a class="el" href="fmatrix_8h_source.html#l00099">VW::FMatrix::GetNumViews()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="fmatrixplanar_8h_source.html">fmatrixplanar.h</a></li>
<li><a class="el" href="fmatrixplanar_8cpp.html">fmatrixplanar.cpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on Sun Mar 21 09:55:54 2010 for VW by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
